<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>始于珞尘</title>
  
  <subtitle>从中二到中三</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hiberabyss.github.io/"/>
  <updated>2021-02-10T07:01:06.356Z</updated>
  <id>https://hiberabyss.github.io/</id>
  
  <author>
    <name>Hongbo Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「C++」typeid 介绍</title>
    <link href="https://hiberabyss.github.io/2021/02/09/cpp-typeid/"/>
    <id>https://hiberabyss.github.io/2021/02/09/cpp-typeid/</id>
    <published>2021-02-09T11:32:06.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p><code>typeid</code> 是 c++ 中的一个关键字，它和 <code>sizeof</code> 类似，它是一个运算符，能获取到 c++ 的类型信息。</p><p><code>typeid</code> 能够对多态对象在运行时获取其真实的类型信息。</p><a id="more"></a><h1 id="typeid-使用方式"><a href="#typeid-使用方式" class="headerlink" title="typeid 使用方式"></a>typeid 使用方式</h1><p>typeid 有两种使用方式：</p><ul><li><code>typeid(type)</code> 例如 <code>typeid(int)</code></li><li><code>typeid(expression)</code> 例如 <code>typeid(variable_name)</code></li></ul><p>typeid 会返回一个 <code>std::type_info</code> 类型，它的定义如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">type_info</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">// 名称是按照编译器自己的命名体系来返回，不同类的 name 不同</span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> type_info&amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> type_info&amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">before</span><span class="params">(<span class="keyword">const</span> type_info&amp; rhs)</span> <span class="keyword">const</span></span>;  <span class="comment">// 类型内部定义时的实现顺序，不同编译器可能不一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编译时或运行时判定"><a href="#编译时或运行时判定" class="headerlink" title="编译时或运行时判定"></a>编译时或运行时判定</h1><p>如果对象没有多态性质的话，可以在编译时期就决定它的对象类型：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span> :</span> <span class="keyword">public</span> Point &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> y_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Point* p = <span class="keyword">new</span> Point2D();</span><br><span class="line">  assert(typid(*p) == <span class="keyword">typeid</span>(Point));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于存在多态的类型，会在运行时判定：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">  <span class="keyword">virtual</span> ~Point();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span> :</span> <span class="keyword">public</span> Point &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> y_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Point* p = <span class="keyword">new</span> Point2D();</span><br><span class="line">  assert(typid(*p) == <span class="keyword">typeid</span>(Point2D));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;typeid&lt;/code&gt; 是 c++ 中的一个关键字，它和 &lt;code&gt;sizeof&lt;/code&gt; 类似，它是一个运算符，能获取到 c++ 的类型信息。&lt;/p&gt;&lt;p&gt;&lt;code&gt;typeid&lt;/code&gt; 能够对多态对象在运行时获取其真实的类型信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://hiberabyss.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>「VimTips」 快速执行 Normal 命令</title>
    <link href="https://hiberabyss.github.io/2021/02/05/vim-fast-normal/"/>
    <id>https://hiberabyss.github.io/2021/02/05/vim-fast-normal/</id>
    <published>2021-02-05T15:19:49.000Z</published>
    <updated>2021-02-10T07:01:06.372Z</updated>
    
    <content type="html"><![CDATA[<p>在批量对一些行做一些简单修改时，使用 <code>normal</code> 命令会很方便。 例如可以通过 <code>%normal A,</code> 在文件所有行的末尾添加一个 <code>,</code> 字符。 但 <code>normal</code> 命令会频繁地触发 <code>InsertEnter</code>、<code>InsertLeave</code> 等事件，一些插件例如 <code>airline</code> 会监控这些事件来执行某些操作， 这会导致 <code>normal</code> 命令执行特别慢，处理每一行时都会有一些卡顿。</p><p>本文会介绍如何屏蔽已安装插件的影响，能够快速地执行 <code>normal</code> 命令。</p><a id="more"></a><h1 id="通过选项-eventignore-来避免触发事件"><a href="#通过选项-eventignore-来避免触发事件" class="headerlink" title="通过选项 eventignore 来避免触发事件"></a>通过选项 <code>eventignore</code> 来避免触发事件</h1><p>Vim 里有个 <code>eventignore</code> 选项，通过配置它能够忽略某些特定或所有的事件。下面是帮助文档里的描述：</p><blockquote><p>A list of autocommand event names, which are to be ignored. When set to “all” or when “all” is one of the items, all autocommand events are ignored, autocommands will not be executed.</p></blockquote><p>有了这个选项之后就可以通过如下地步骤来让 <code>normal</code> 命令快速执行：</p><ol><li>执行前屏蔽所有事件 <code>set eventignore=all</code></li><li>执行 normal 命令 <code>:%noraml I&quot;A&quot;</code></li><li>恢复 eventignore 选项 <code>set eventignore=</code></li></ol><p>上面这几个步骤可以封装成一个命令，下面的代码就是把上面的 3 个步骤封装成命令 <code>Normal</code>：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">NormalIgnoreAllEvents</span><span class="params">(args)</span> <span class="title">range</span></span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">l:cur_eventignore</span> = &amp;eventignore</span><br><span class="line">  <span class="keyword">set</span> eventignore=<span class="keyword">all</span></span><br><span class="line">  <span class="keyword">execute</span>(<span class="built_in">printf</span>(<span class="string">'%d,%dnormal %s'</span>, <span class="variable">a:firstline</span>, <span class="variable">a:lastline</span>, <span class="variable">a:args</span>))</span><br><span class="line">  <span class="keyword">let</span> &amp;eventignore = <span class="variable">l:cur_eventignore</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">command! -nargs=<span class="number">1</span> -<span class="built_in">range</span> Normal <span class="symbol">&lt;line1&gt;</span>,<span class="symbol">&lt;line2&gt;</span><span class="keyword">call</span> <span class="variable">s:NormalIgnoreAllEvents</span>(<span class="string">'&lt;args&gt;'</span>)</span><br></pre></td></tr></table></figure><p>把上面的代码放到 <code>.vimrc</code> 里之后就可以通过 <code>%Normal A,</code> 的方式来别面其它插件的影响， 快速执行 <code>normal</code> 命令。</p><p>上面的 <code>Normal</code> 命令定义中通过 <code>-range</code> 让它支持指定一个执行的区间， 同时在函数定义的最后加上了 <code>range</code>，这样函数就能取到 <code>a:firstline</code> 和 <code>a:lastline</code> 两个参数， 同时这个函数也只会被调用一次。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2020/04/26/vim-edit-binary/">如何使用 Vim 编辑二进制文件</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在批量对一些行做一些简单修改时，使用 &lt;code&gt;normal&lt;/code&gt; 命令会很方便。 例如可以通过 &lt;code&gt;%normal A,&lt;/code&gt; 在文件所有行的末尾添加一个 &lt;code&gt;,&lt;/code&gt; 字符。 但 &lt;code&gt;normal&lt;/code&gt; 命令会频繁地触发 &lt;code&gt;InsertEnter&lt;/code&gt;、&lt;code&gt;InsertLeave&lt;/code&gt; 等事件，一些插件例如 &lt;code&gt;airline&lt;/code&gt; 会监控这些事件来执行某些操作， 这会导致 &lt;code&gt;normal&lt;/code&gt; 命令执行特别慢，处理每一行时都会有一些卡顿。&lt;/p&gt;&lt;p&gt;本文会介绍如何屏蔽已安装插件的影响，能够快速地执行 &lt;code&gt;normal&lt;/code&gt; 命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>竞价广告排序策略</title>
    <link href="https://hiberabyss.github.io/2020/05/07/auction-advertisement/"/>
    <id>https://hiberabyss.github.io/2020/05/07/auction-advertisement/</id>
    <published>2020-05-07T10:18:50.000Z</published>
    <updated>2021-02-10T07:01:06.352Z</updated>
    
    <content type="html"><![CDATA[<p>从毕业到现在一直都在从事广告行业，却从来没有写过广告相关的技术文章，也是挺不应该的。 今天就先写一篇来介绍下业内常用的竞价广告排序策略。</p><a id="more"></a><h1 id="概要介绍"><a href="#概要介绍" class="headerlink" title="概要介绍"></a>概要介绍</h1><p>广告行业常见术语：</p><ul><li><code>CPM</code> Cost Per Thousand，千次曝光价格；最后一个字母 M 其实是罗马数字计数单位，表示 1000；</li><li><code>CPC</code> Cost Per Click，单次点击价格</li><li><code>CTR</code> Click Through Rae，点击率；点击数除以曝光数；</li><li><code>CVR</code> Click Value Rate，转化率；转化数除以点击数；这里的转化目标是多种多样的，可以是一个下载或者是用户填的一个表单预约；</li><li><code>pCTR</code> <code>pCVR</code> 预估点击率和预估转化率；当广告系统收到一次广告请求时，会基于请求里的用户信息和位置信息， 以及广告的历史播放数据来计算出每个广告的预估点击率和预估转化率，这两个指标会影响广告的最终排序结果。</li></ul><p>广告投放播放过程中有四个参与方：</p><ul><li>广告主：花钱投广告，去推广自己的产品；例如可口可乐、红旗汽车等；</li><li>流量方：有大量活跃用户，会发送广告请求，展示广告进行流量变现；例如腾讯视频、QQ 空间等；</li><li>用户：观看广告，对于感兴趣的广告会进行点击、下载或购买等后续操作；</li><li>广告平台：连接广告主和流量方，广告主在广告平台投放广告，流量方从广告平台拉取广告进行展示； 广告平台对广告进行排序以保证流量方收益最大化、广告主能按照合理的价格拿到广告展示机会、用户体验不会受到太大的影响；</li></ul><p>广告的排序本质上是一个多方博弈的结果，最终达到一个纳什均衡的状态。</p><h2 id="广告检索和网页搜索的区别"><a href="#广告检索和网页搜索的区别" class="headerlink" title="广告检索和网页搜索的区别"></a>广告检索和网页搜索的区别</h2><ul><li>网页搜索只需要针对用户的搜索体验进行优化即可（优化召回率和准确率），而广告检索是广告主、流量方、用户的多目标优化问题。</li><li>网页评分是一个相对静态的过程，按天或周进行更新；而广告是会动态变化的，广告主随时可能会调整广告出价，暂停广告等。</li></ul><h1 id="竞价广告排序发展历程"><a href="#竞价广告排序发展历程" class="headerlink" title="竞价广告排序发展历程"></a>竞价广告排序发展历程</h1><p>互联网广告最开始的投放模式和电视广告很像：分时分位置进行售卖，这里就需要销售人员去进行售卖， 售卖价格会相对较高，小的广告主无法参与进来。</p><h2 id="GFP-Generalized-First-Price"><a href="#GFP-Generalized-First-Price" class="headerlink" title="GFP (Generalized First Price)"></a>GFP (Generalized First Price)</h2><p>Yahoo 在它的搜索广告中提出了一种新的广告计费方式：</p><ul><li>广告主可以为广告选择特定的关键词，并设定一个价格</li><li>对用户搜索的关键词，按广告主的出价进行排序并返回</li><li>当用户点击时，按照广告主的出价直接进行扣费</li></ul><p>这种广告售卖方式高度自动化，不需要销售人员介入，同时很多小的广告主也可以参与进来， 提高流量的竞争激烈程度，进而可以提高流量的总收益。</p><p>GFP 的问题是无法让系统达到一个纳什均衡的状态，广告主有动力不断小幅度下调自己的出价以较低价格拿量。 这样可能会导致广告系统收入处于一个持续波动的状态。 我们假定广告主能接受的最高真实出价是 $ P_{real} $，广告主是期望以不超过 $P_{real}$ 的成本拿到量。</p><h2 id="GSP-Generalized-Second-Pricce"><a href="#GSP-Generalized-Second-Pricce" class="headerlink" title="GSP (Generalized Second Pricce)"></a>GSP (Generalized Second Pricce)</h2><p>鉴于 GFP 的缺点，谷歌提出了 GSP，也就是按照第二名的出价来计费，同时谷歌还引入了质量分数的概念， 广告的排序分数按照如下的公式计算：</p><p>$$ Score = bid * quality $$</p><p>实际扣费时按照下面的公式来计算：</p><p>$$ ecpm_{second} = \frac {bid_{second} * quality_{second}} { quality_{first}} \le bid_{first} $$</p><p>我们可以证明使用 GSP 方式可以让系统到达一个纳什均衡的状态，广告主按照自己的正式意愿 $P_{real}$ 出价时是对自己最优的结果。 我们可以简单证明下，假设其它广告主的出价为 $P_{other}$，则可以分三种情况来讨论：</p><ul><li>$ P_{other} &gt; P_{real} $：此时广告主最优出价为 $ \le P_{real} $ ，此时都拿不到量；</li><li>$ P_{other} = P_{real} $：此时广告主最优出价为 $ P_{real} $；</li><li>$ P_{other} \lt P_{real} $：此时广告主最优出价为 $ \le P_{real} $，此时可以以 $ P_{other} $ 价格拿量；</li></ul><p>综合上面三种情况，广告主按真实意愿 $ P_{real} $ 出价时能利益最大化。</p><h2 id="VCG（Vickrey-Clarke-Groves）"><a href="#VCG（Vickrey-Clarke-Groves）" class="headerlink" title="VCG（Vickrey Clarke Groves）"></a>VCG（Vickrey Clarke Groves）</h2><p>VCG 是考虑广告对其它广告的影响，按照广告参与竞争后造成别的广告主的收益损失来计费：</p><p>$$ Cost_A = V_{OtherWithoutA} - V_{OtherWithA} $$</p><p>下面是一个具体的示例：</p><p><img src="/img/posts/de13103f4b636f6e24ab192b69b574c3-1588908384.jpg" alt></p><p>VCG 目前只有 Facebook 在用；在只有一个广告位的时候，VCG 和 GSP 是等价的。VCG 是广告主收益（社会效益）最优的分配方式。</p><p>VCG 的缺点是：</p><ul><li>短期内会造成广告平台收入下降；</li><li>VCG 规则过于复杂，可能会让广告主难以理解。</li></ul><h1 id="广告计费方式"><a href="#广告计费方式" class="headerlink" title="广告计费方式"></a>广告计费方式</h1><h2 id="CPM"><a href="#CPM" class="headerlink" title="CPM"></a>CPM</h2><p>这种是直接按照展示曝光计费，目前一般只有合约会使用这种计费方式，竞价很少会使用这种计费方式。 这种计费方式基本只会使用到广告平台的定向能力，而且由于别的广告有点击、转化之类的优化目标， 而 CPM 广告没有类似的优化目标，最终会导致 CPM 广告拿到点击率和转化率都很低的劣质流量。 在排序过程中的 ecpm 为：</p><p>$$ ecpm_{cpm} = bid $$</p><h2 id="CPC"><a href="#CPC" class="headerlink" title="CPC"></a>CPC</h2><p>按点击进行收费，会使用到广告平台的点击率预测能力。容易拿到一些点击率高但转化率很低的流量， 例如一些少儿频道。排序过程中的 ecpm 按如下公式计算：</p><p>$$ ecpm_{cpc} = bid \times pCtr \times 1000 $$</p><h2 id="CPA-Cost-Per-Action"><a href="#CPA-Cost-Per-Action" class="headerlink" title="CPA (Cost Per Action)"></a>CPA (Cost Per Action)</h2><p>按每个 Action 进行收费，这里的 Action 可以是一次下载、一次购买或者是一个表单预约。这种收费方式是广告主比较希望的： 直接按照转化出价，不需要自己考虑转化率，都交给广告平台去计算，而广告平台数据更多， 相比广告主能够更准确地计算点击率和转化率。这种方式排序 ecpm 计算公式计算如下：</p><p>$$ ecpm_{cpa} = bid \times pCtr \times pCvr \times 1000 $$</p><p>这种计费方式的问题是，在广告刚开始投放时，没有历史数据，无法进行准确的 pCtrv 和 pCvr 预估，需要对广告进行探索， 而广告平台对 CPA 计费方式的广告进行探索时的成本很高，很有可能收不上来钱，极端情况下，如果广告主不回传任何转化数据， 则探索期的所有流量都会被浪费掉。广告平台对 CPA 广告的谨慎探索会导致 CPA 广告积累数据比较慢，很难起量。 同时，由于转化数量相对较少，可能会造成广告系统收入出现比较大的波动。</p><h2 id="oCPM-oCPC-oCPA"><a href="#oCPM-oCPC-oCPA" class="headerlink" title="oCPM / oCPC / oCPA"></a>oCPM / oCPC / oCPA</h2><p>和前面几种计费方式不同，oCPA 广告是按照转化去排序，但按照曝光（oCPM）或者点击（oCPC）去收费； 这种方式有 CPA 计费方式的优点，既广告主可以直接按转化出价，广告平台会尽量达成广告主的出价。 同时，广告平台前期的广告探索也能收回成本。oCPA 也能促使广告主尽早回传转化数据， 这样 oCPA 广告才能比较有竞争力，才能和别的广告去竞争。oCPA 的排序 ecpm 计算和 CPA 方式一致：</p><p>$$ ecpm_{ocpa} = bid \times pCtr \times pCvr \times 1000 $$</p><p>如果是 oCPM ，则每个曝光的收费为（简化模型，实际还要考虑乘以 GSP 调价系数）：</p><p>$$ Cost = bid \times pCtr \times pCvr $$</p><p>如果是 oCPC，则每个点击的收费为：</p><p>$$ Cost = bid \times pCvr $$</p><p>oCPA 也被称作智能出价，意思是广告系统会动态调整广告的 CPM 或者 CPC 出价，以使得广告的转化价格能达到预期。</p><p>oCPA 成本达成一般是指实际的转化价格和广告主设定的转化价格的差距在正负 20% 以内。目前业内一般会有 oCPA 赔付机制， 赔付广告主超出成本部分的花费，让广告平台和广告主一起承担广告早期的探索成本。赔付一般会预设一些前提要求：</p><ul><li>会设定赔付期，例如3天，只会对赔付期内的超成本部分进行赔付；</li><li>实际转化成本要高出一个阈值，例如 10\% 或者 20\%；</li><li>在赔付期内有超过一定数量的转化，例如 5 个</li></ul><h1 id="新广告探索"><a href="#新广告探索" class="headerlink" title="新广告探索"></a>新广告探索</h1><p>新广告探索本质是一个 EE (Exploration and Exploitation) 问题，可以使用 ϵ-greedy 算法来解决：</p><ul><li>以 ϵ 的概率去探索新广告；</li><li>以 1-ϵ 的概率去选择当前效果最好的广告；</li></ul><p>通过使用 Simpson 采样的方法来设定新广告的点击率；</p><h1 id="粗排和精排的区别"><a href="#粗排和精排的区别" class="headerlink" title="粗排和精排的区别"></a>粗排和精排的区别</h1><ul><li>粗排实现广告的定向，粗排最重要的指标是优质广告的召回率和性能；</li><li>精排需要做到收益最大化和广告的准确个性化推荐；</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/20694813" rel="external nofollow noopener noreferrer" target="_blank">谈谈广告平台的竞价原理：GFP,GSP,VCG</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从毕业到现在一直都在从事广告行业，却从来没有写过广告相关的技术文章，也是挺不应该的。 今天就先写一篇来介绍下业内常用的竞价广告排序策略。&lt;/p&gt;
    
    </summary>
    
    
      <category term="广告" scheme="https://hiberabyss.github.io/tags/%E5%B9%BF%E5%91%8A/"/>
    
      <category term="竞价" scheme="https://hiberabyss.github.io/tags/%E7%AB%9E%E4%BB%B7/"/>
    
  </entry>
  
  <entry>
    <title>基于 Seafile 自建网盘</title>
    <link href="https://hiberabyss.github.io/2020/05/06/custom-cloud-driver/"/>
    <id>https://hiberabyss.github.io/2020/05/06/custom-cloud-driver/</id>
    <published>2020-05-06T18:50:13.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>现在公司给配置了 iMac 和 Macbook，平时在公司时就用 iMac，在家的时候会用 Macbook，多个终端就涉及到一些数据的同步， 例如一些配置文件、写了一半的 PPT 等。最开始尝试过使用国内的微云等网盘来进行同步，但发现同步速度很慢， 而且经常出现一些莫名其妙的同步错误。后面用过一段时间的 Dropbox，但在家时使用的翻墙工具很不稳定， 经常出现无法连接 Dropbox 的问题，而且 Dropbox 的免费空间也很小，要是同步一些大文件就显的不够用。</p><p>因为在公司可以申请一些个人使用的开发容器，磁盘空间有 500GB 左右，就考虑可以自己搭建一个同步网盘， 这样就不会被限速，而且空间也只受硬盘大小的限制；唯一的缺点就是需要连上公司的 VPN 才能使用网盘， 但毕竟也会经常同步一些公司内部的资料，连 VPN 才能使用也是一种安全保险，避免一不小心就 “高压线了”。</p><a id="more"></a><h1 id="如何搭建-Seafile-网盘服务"><a href="#如何搭建-Seafile-网盘服务" class="headerlink" title="如何搭建 Seafile 网盘服务"></a>如何搭建 Seafile 网盘服务</h1><p>可以很方便的使用 docker 来搭建 Seafile 服务：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo docker run -d --name seafile \</span><br><span class="line">  -e SEAFILE_SERVER_HOSTNAME=seafile.example.com \</span><br><span class="line">  -v /data/seafile-data:/shared \</span><br><span class="line">  -p 80:80 \</span><br><span class="line">  seafileltd/seafile:latest</span><br></pre></td></tr></table></figure><p>然后在浏览器里通过机器 IP 访问对应的 Web 服务创建账号，再下载 Seafile <a href="https://www.seafile.com/download/" rel="external nofollow noopener noreferrer" target="_blank">客户端</a>就可以使用了。 我是在 <code>/etc/hosts</code> 里加上了类似下面的配置，这样就可以直接通过 <code>hbliu.com</code> 来访问 Seafile 服务了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.0.123 hbliu.com</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在公司给配置了 iMac 和 Macbook，平时在公司时就用 iMac，在家的时候会用 Macbook，多个终端就涉及到一些数据的同步， 例如一些配置文件、写了一半的 PPT 等。最开始尝试过使用国内的微云等网盘来进行同步，但发现同步速度很慢， 而且经常出现一些莫名其妙的同步错误。后面用过一段时间的 Dropbox，但在家时使用的翻墙工具很不稳定， 经常出现无法连接 Dropbox 的问题，而且 Dropbox 的免费空间也很小，要是同步一些大文件就显的不够用。&lt;/p&gt;&lt;p&gt;因为在公司可以申请一些个人使用的开发容器，磁盘空间有 500GB 左右，就考虑可以自己搭建一个同步网盘， 这样就不会被限速，而且空间也只受硬盘大小的限制；唯一的缺点就是需要连上公司的 VPN 才能使用网盘， 但毕竟也会经常同步一些公司内部的资料，连 VPN 才能使用也是一种安全保险，避免一不小心就 “高压线了”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网盘" scheme="https://hiberabyss.github.io/tags/%E7%BD%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>博客中自动插入剪贴板图片链接</title>
    <link href="https://hiberabyss.github.io/2020/05/06/blog-insert-image/"/>
    <id>https://hiberabyss.github.io/2020/05/06/blog-insert-image/</id>
    <published>2020-05-06T15:37:47.000Z</published>
    <updated>2021-02-10T07:01:06.352Z</updated>
    
    <content type="html"><![CDATA[<p>我是通过 Vim 写 Markdown 的方式来写博客，这种方式在需要插入剪贴板里的图片时不是很方便。 之前我是通过一些图床工具来实现剪贴板图片插入，但这里会存在两个问题：</p><ol><li>图床链接有可能会失效，这样博客里的图片就变成了不可访问的状态；</li><li>在网络不好的时候，本地上传图片可能要很久，特别是我使用的是高分辨率的 imac，截图时图片大小会很大。</li></ol><p>鉴于刚才提到的问题，我希望通过如下的方式来插入图片：</p><ol><li>通过一个 Shell 工具来保存剪贴板里的截图到博客网站的某个子目录里，并输出对应的 Markdown 图片链接；</li><li>添加自定义的 Vim 命令来插入 Shell 工具输出的 Markdown 图片链接。</li></ol><p>下面是 Shell 脚本代码，主要是基于 <code>pngpaste</code> 读取剪贴板里的图片，并按照 <code>md5-timestamp.jpg</code> 文件名保存到特定目录：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">IMG_DIR=<span class="string">"img/posts"</span></span><br><span class="line">DEST_DIR=<span class="string">"<span class="variable">$HOME</span>/Dropbox/blog/source/<span class="variable">$IMG_DIR</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">prepare</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> ! <span class="built_in">which</span> pngpaste &amp;&gt; /dev/zero; <span class="keyword">then</span></span><br><span class="line">    brew install pngpaste</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">markdown_link</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"![](/<span class="variable">$IMG_DIR</span>/<span class="variable">$1</span>)"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">  prepare</span><br><span class="line">  <span class="built_in">cd</span> <span class="variable">$DEST_DIR</span></span><br><span class="line">  <span class="built_in">local</span> timestamp=$(date +%s)</span><br><span class="line">  <span class="built_in">local</span> filename=<span class="string">"<span class="variable">$&#123;timestamp&#125;</span>.jpg"</span></span><br><span class="line"></span><br><span class="line">  pngpaste <span class="string">"<span class="variable">$filename</span>"</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">local</span> finalname=<span class="string">"<span class="variable">$(md5sum $filename | awk '&#123;print $1&#125;')</span>-<span class="variable">$&#123;timestamp&#125;</span>.jpg"</span></span><br><span class="line">  mv <span class="string">"<span class="variable">$filename</span>"</span> <span class="string">"<span class="variable">$finalname</span>"</span></span><br><span class="line">  <span class="built_in">local</span> md_link=$(markdown_link <span class="string">"<span class="variable">$finalname</span>"</span>)</span><br><span class="line">  <span class="comment"># echo "$md_link" | pbcopy</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"<span class="variable">$md_link</span>"</span></span><br><span class="line">&#125;</span><br><span class="line">main <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure><p>把上面的 Shell 脚本保存为 <code>blogimg</code> 并添加可执行权限，然后在 vimrc 里加上如下的配置：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">command! -nargs=<span class="number">0</span> InsertImg :r !blogimg</span><br></pre></td></tr></table></figure><p>后面就可以通过执行 <code>InsertImg</code> 来直接插入剪贴板图片对应的链接：</p><p><img src="/img/posts/c71d4089ae88c60aebc0916f408c18a5-1588752367.jpg" alt></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是通过 Vim 写 Markdown 的方式来写博客，这种方式在需要插入剪贴板里的图片时不是很方便。 之前我是通过一些图床工具来实现剪贴板图片插入，但这里会存在两个问题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;图床链接有可能会失效，这样博客里的图片就变成了不可访问的状态；&lt;/li&gt;&lt;li&gt;在网络不好的时候，本地上传图片可能要很久，特别是我使用的是高分辨率的 imac，截图时图片大小会很大。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;鉴于刚才提到的问题，我希望通过如下的方式来插入图片：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;通过一个 Shell 工具来保存剪贴板里的截图到博客网站的某个子目录里，并输出对应的 Markdown 图片链接；&lt;/li&gt;&lt;li&gt;添加自定义的 Vim 命令来插入 Shell 工具输出的 Markdown 图片链接。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;下面是 Shell 脚本代码，主要是基于 &lt;code&gt;pngpaste&lt;/code&gt; 读取剪贴板里的图片，并按照 &lt;code&gt;md5-timestamp.jpg&lt;/code&gt; 文件名保存到特定目录：&lt;/p&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;IMG_DIR=&lt;span class=&quot;string&quot;&gt;&quot;img/posts&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DEST_DIR=&lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$HOME&lt;/span&gt;/Dropbox/blog/source/&lt;span class=&quot;variable&quot;&gt;$IMG_DIR&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;prepare&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ! &lt;span class=&quot;built_in&quot;&gt;which&lt;/span&gt; pngpaste &amp;amp;&amp;gt; /dev/zero; &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    brew install pngpaste&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;fi&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;markdown_link&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;![](/&lt;span class=&quot;variable&quot;&gt;$IMG_DIR&lt;/span&gt;/&lt;span class=&quot;variable&quot;&gt;$1&lt;/span&gt;)&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  prepare&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$DEST_DIR&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt; timestamp=$(date +%s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt; filename=&lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$&amp;#123;timestamp&amp;#125;&lt;/span&gt;.jpg&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  pngpaste &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$filename&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt; finalname=&lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$(md5sum $filename | awk &#39;&amp;#123;print $1&amp;#125;&#39;)&lt;/span&gt;-&lt;span class=&quot;variable&quot;&gt;$&amp;#123;timestamp&amp;#125;&lt;/span&gt;.jpg&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  mv &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$filename&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$finalname&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt; md_link=$(markdown_link &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$finalname&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;# echo &quot;$md_link&quot; | pbcopy&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$md_link&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;main &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$@&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;把上面的 Shell 脚本保存为 &lt;code&gt;blogimg&lt;/code&gt; 并添加可执行权限，然后在 vimrc 里加上如下的配置：&lt;/p&gt;&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;command! -nargs=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; InsertImg :r !blogimg&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;后面就可以通过执行 &lt;code&gt;InsertImg&lt;/code&gt; 来直接插入剪贴板图片对应的链接：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/img/posts/c71d4089ae88c60aebc0916f408c18a5-1588752367.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Blog" scheme="https://hiberabyss.github.io/tags/blog/"/>
    
      <category term="图床" scheme="https://hiberabyss.github.io/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>使用 Vim 查看 Fiddler 生成的 saz 格式 session 包</title>
    <link href="https://hiberabyss.github.io/2020/05/06/vim-open-saz-file/"/>
    <id>https://hiberabyss.github.io/2020/05/06/vim-open-saz-file/</id>
    <published>2020-05-06T14:32:05.000Z</published>
    <updated>2021-02-10T07:01:06.372Z</updated>
    
    <content type="html"><![CDATA[<p>Fiddler 是 Windows 下很流行的 Http 抓包工具，它可以把抓到的 Http 请求保存为 saz 格式。 在工作中调试后台服务时，同事经常会发过来一个 saz 格式的文件，但我是用的 macOS 系统， 而 Fiddler 没有 macOS 的版本，就没法直接查看 saz 格式文件。</p><p>后来通过 Google 发现 Fiddler 其实是一个 zip 包，Http 的请求和回包都保存在特定的文件里：</p><ul><li><code>sessionid#_c.txt</code> 客户端请求</li><li><code>sessionid#_s.txt</code> 服务端回包</li></ul><p>而最新版本的 Vim 是可以直接识别 zip 包并打开对应的文件的，这样我们就可以直接用 Vim 查看 saz 格式的文件了。 先在 vimrc 里加上如下的配置：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">autocmd</span> BufReadCmd *.saz <span class="keyword">call</span> zip#Browse(<span class="built_in">expand</span>(<span class="string">"&lt;amatch&gt;"</span>))</span><br></pre></td></tr></table></figure><p>然后就可以直接用 Vim 打开 saz 文件了：</p><p><img src="/img/posts/0f6a442b6a5d380493489cec0ff34d15-1588749137.jpg" alt></p><p>如果想要可以直接双击打开 saz 文件，可以安装 GUI 版本的 <a href="https://github.com/qvacua/vimr" rel="external nofollow noopener noreferrer" target="_blank">VimR</a>。</p><a id="more"></a><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/05/03/add-async-support-for-vim-plugin/">给 Vim 插件添加上异步调用的功能</a></li><li><a href="https://hiberabyss.github.io/2018/04/24/vim-plug-rest-console/">实现类 Postman 功能的 VIM 插件</a></li><li><a href="https://hiberabyss.github.io/2018/04/13/vim-file-jumper/">Vim 文件快速跳转插件</a></li><li><a href="https://hiberabyss.github.io/2018/03/21/vim-plug-introduction/">VIM 插件管理工具 vim-plug 简明教程</a></li><li><a href="https://hiberabyss.github.io/2018/02/28/vim-project-configuration/">「VIM」基于项目的 VIM 配置</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Fiddler 是 Windows 下很流行的 Http 抓包工具，它可以把抓到的 Http 请求保存为 saz 格式。 在工作中调试后台服务时，同事经常会发过来一个 saz 格式的文件，但我是用的 macOS 系统， 而 Fiddler 没有 macOS 的版本，就没法直接查看 saz 格式文件。&lt;/p&gt;&lt;p&gt;后来通过 Google 发现 Fiddler 其实是一个 zip 包，Http 的请求和回包都保存在特定的文件里：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;sessionid#_c.txt&lt;/code&gt; 客户端请求&lt;/li&gt;&lt;li&gt;&lt;code&gt;sessionid#_s.txt&lt;/code&gt; 服务端回包&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;而最新版本的 Vim 是可以直接识别 zip 包并打开对应的文件的，这样我们就可以直接用 Vim 查看 saz 格式的文件了。 先在 vimrc 里加上如下的配置：&lt;/p&gt;&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;autocmd&lt;/span&gt; BufReadCmd *.saz &lt;span class=&quot;keyword&quot;&gt;call&lt;/span&gt; zip#Browse(&lt;span class=&quot;built_in&quot;&gt;expand&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;amatch&amp;gt;&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;然后就可以直接用 Vim 打开 saz 文件了：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/img/posts/0f6a442b6a5d380493489cec0ff34d15-1588749137.jpg&quot; alt&gt;&lt;/p&gt;&lt;p&gt;如果想要可以直接双击打开 saz 文件，可以安装 GUI 版本的 &lt;a href=&quot;https://github.com/qvacua/vimr&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;VimR&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
      <category term="Fiddler" scheme="https://hiberabyss.github.io/tags/fiddler/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 Vim 编辑二进制文件</title>
    <link href="https://hiberabyss.github.io/2020/04/26/vim-edit-binary/"/>
    <id>https://hiberabyss.github.io/2020/04/26/vim-edit-binary/</id>
    <published>2020-04-26T14:04:52.000Z</published>
    <updated>2021-02-10T07:01:06.372Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间参加公司内部的一个技术比赛：实现一个打印自己 MD5 值的最小 elf64 格式二进制文件。 在这个过程中需要对二进制文件的某些字节进行修改、删除等编辑操作，本文介绍如果通过 Vim 来编辑二进制文件。</p><a id="more"></a><h1 id="基于-xxd-命令来实现"><a href="#基于-xxd-命令来实现" class="headerlink" title="基于 xxd 命令来实现"></a>基于 xxd 命令来实现</h1><p>先设定 buffer 和文件的编码格式为 utf-8 ：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> encoding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">set</span> fileencoding=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure><p>打开二进制文件，设定 binary 模式 <code>set binary</code>， 在 Vim 里执行 <code>%!xxd -g1</code> 即可用类似下面的界面编辑二进制文件字节：</p><p><img src="https://raw.githubusercontent.com/hiberabyss/pictures/master/20200426214430.png" alt></p><p>再执行 <code>:%!xxd -r</code> 转换成原始文件的格式。</p><h1 id="使用-Vim-插件-Vinarise"><a href="#使用-Vim-插件-Vinarise" class="headerlink" title="使用 Vim 插件 Vinarise"></a>使用 Vim 插件 Vinarise</h1><p><a href="https://github.com/Shougo/vinarise.vim" rel="external nofollow noopener noreferrer" target="_blank">Vinarise</a> 是一个支持二进制编辑的插件，安装之后执行 <code>Vinarise</code> 即可按二进制的方式编辑文件。</p><p>Vinarise 提供了很多方便的功能，例如移动等操作都是以字节为单位的，<code>/</code> 可以直接按二进制序列进行搜索， <code>g/</code> 则可以俺字符串进行搜索。</p><p>Vinarise 的不足之处是对删除的操作支持不够，例如不支持 <code>d</code> 这个操作，虽然可以通过 <code>x</code> 删除一整个字节，但是不支持 <code>undo</code> 操作。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2021/02/05/vim-fast-normal/">「VimTips」 快速执行 Normal 命令</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间参加公司内部的一个技术比赛：实现一个打印自己 MD5 值的最小 elf64 格式二进制文件。 在这个过程中需要对二进制文件的某些字节进行修改、删除等编辑操作，本文介绍如果通过 Vim 来编辑二进制文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
      <category term="binary" scheme="https://hiberabyss.github.io/tags/binary/"/>
    
  </entry>
  
  <entry>
    <title>通过 Github V4 API 来了解 GraphQL</title>
    <link href="https://hiberabyss.github.io/2018/05/22/graphql-introduction-via-github-api/"/>
    <id>https://hiberabyss.github.io/2018/05/22/graphql-introduction-via-github-api/</id>
    <published>2018-05-22T23:42:23.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>前几天看到一篇名为 <a href="https://segmentfault.com/a/1190000014770363#articleHeader21" rel="external nofollow noopener noreferrer" target="_blank">现代后端开发者必备技能</a> 的博客. 其中有一个条目提到了 GraphQL, 称它为 <code>REST 2.0</code>, 再加上之前偶然间看到最新版的 Github API 使用了 GraphQL, 便想了解一下它到底是个什么东东.</p><p>GraphQL 是 Graph Query Language 的简称, 在 Github <a href="https://developer.github.com/v4/" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a> 中指出了 GraphQL 的几个特点:</p><ul><li><code>A Specification</code> 可以在 API Server 上定义 Schema, 客户端发起的 query 请求会基于 Schema 进行验证;</li><li><code>Strongly typed</code> 强类型; 可以在 Schema 中指定某个 field 的类型, 以及不同对象之间的关系;</li><li><code>Introspective</code> 客户端可以通过 query 获取详细的 Schema 定义;</li><li><code>Hierarchical</code> API 调用是基于 query 中指定的层级关系及 fields 进行返回的, 不会返回不必要的冗余信息;</li><li><code>An application layer</code> GraphQL 不是一种数据存储模型或者数据库查询语言, 它可以连接不同的数据存储源;</li></ul><a id="more"></a><p>下图展示了 GraphQL 的工作模型:</p><p><img src="graphql_data_sources.png" alt></p><p>Github 之所以转向 GraphQL, 是因为它更加地灵活:</p><ul><li>可以精确地定义所需要的数据, 减少数据冗余;</li><li>可以只通过一个 GraphQL 请求就得到之前需要好几个 REST 请求才能获取的数据.</li></ul><p>下面是 Github 官方文档解释为什么使用 GraphQL 的原文:</p><blockquote><p>GitHub chose GraphQL for our API v4 because it offers significantly more flexibility for our integrators. The ability to define precisely the data you want—and only the data you want—is a powerful advantage over the REST API v3 endpoints. GraphQL lets you replace multiple REST requests with a single call to fetch the data you specify.</p></blockquote><h1 id="GraphQL-基本概念介绍"><a href="#GraphQL-基本概念介绍" class="headerlink" title="GraphQL 基本概念介绍"></a>GraphQL 基本概念介绍</h1><h2 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h2><p>Schema 定义了 GraphQL API 的类型系统, 可以简单把它类比成 MySQL 中数据库中的各个表的 Schema 定义. Schema 定义了 GraphQL 查询可以操作的数据内容, 客户端的查询会基于 Schema 进行校验和执行.</p><p>下面我们可以给出一个简单的 Github 中当前用户 <code>viewer</code> 的示例 Schema 定义:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type User&#123;</span><br><span class="line">    <span class="comment">// Comment: `!` menas the field is required</span></span><br><span class="line">    name: <span class="built_in">String</span>!</span><br><span class="line">    email: <span class="built_in">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Query &#123;</span><br><span class="line">    viewer: User!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的 Schema 定义好并添加到 API Server 中后, 我们便可以通过类似如下的查询去获取我们期望的数据:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">query &#123; </span><br><span class="line">  viewer &#123;</span><br><span class="line">    name</span><br><span class="line">    email</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在 <a href="https://developer.github.com/v4/explorer/" rel="external nofollow noopener noreferrer" target="_blank">Github GraphQL Explorer</a> 执行上面的查询, 就可以得到类似如下的输出:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>: &#123;</span><br><span class="line">    <span class="attr">"viewer"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Hongbo Liu"</span>,</span><br><span class="line">      <span class="attr">"email"</span>: <span class="string">"hbliu@freewheel.tv"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Scalar"><a href="#Scalar" class="headerlink" title="Scalar"></a>Scalar</h2><p>Scalar 其实指的就是基本数据类型, 包括 <code>String</code>, <code>Int</code>, <code>Bool</code> 等.</p><h2 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h2><p>Field 是客户端从 API Server 获取的某个内容, 例如某个字段或者某个对象等. 可以简单把 field 理解成是对象的成员变量. 在 GraphQL 的查询中, 所有的操作必须指向最底层的 field , 即这个 field 的类型是 Scalar 类型.</p><h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><p>Connection 表明的是和当前对象相关联的一些别的对象. 例如对于 Github 中的当前用户 <code>viewer</code>, 它会有相关联的 repositories , 我们便可以在其中定义 <code>RepositoryConnection</code>.</p><h2 id="Edge"><a href="#Edge" class="headerlink" title="Edge"></a>Edge</h2><p>它表示 Node 之间的 Connection, 当查询一个 connection 时, 通过 connection 达到别的节点.</p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>Node 可以理解成节点对象, 我们最终就是会获取 Node 中的不同 Field.</p><h1 id="基于-Github-练习如何使用-GraphQL"><a href="#基于-Github-练习如何使用-GraphQL" class="headerlink" title="基于 Github 练习如何使用 GraphQL"></a>基于 Github 练习如何使用 GraphQL</h1><p>我们可以使用 curl 来往 <code>https://api.github.com</code> 发送 GraphQL 请求, 这需要我们先获取一个 Github 的 Token 并把它放置在 Header 中. 例如我们可以通过下面的命令获取整个 Github API 的 Schema:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -H "Authorization: bearer your-github-token" https://api.github.com/graphql</span><br></pre></td></tr></table></figure><p>我们可以通过之前介绍过的 <a href="https://hiberabyss.github.io/2018/04/24/vim-plug-rest-console/">vim rest console 插件</a> 来发送获取当前用户名的请求:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1527052364483.png" width="682"></p><p>当然更方便的方式还是通过 <a href="https://developer.github.com/v4/explorer/" rel="external nofollow noopener noreferrer" target="_blank">Github GraphQL Explorer</a> 来发送请求. 例如我们可以在其中执行下面的查询来获取当前用户创建的 5 个 repo:</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  viewer &#123;</span><br><span class="line">    repositories(first: 5, isFork: false) &#123;</span><br><span class="line">      edges &#123;</span><br><span class="line">        node &#123;</span><br><span class="line">          name</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的结果如下图所示:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1527052574052.png" width="1410"></p><p>我们还可以通过上图中的最右侧边栏查看 GraphQL 的 Schema.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文只是简要介绍了 GraphQL 中的一些基本概念, 以及如何进行数据查询. 后续还需要研究如何设计 GraphQL Schema 并启动对应的 API Server, 以及如何通过 GraphQL 进行数据的修改等.</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.jianshu.com/p/203dd28eac4f" rel="external nofollow noopener noreferrer" target="_blank">GraphQL初探：一种强大的DSQL</a></li><li><a href="https://www.jianshu.com/p/af7ac20f2c64" rel="external nofollow noopener noreferrer" target="_blank">GraphQL 实战：Github V4 API使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天看到一篇名为 &lt;a href=&quot;https://segmentfault.com/a/1190000014770363#articleHeader21&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;现代后端开发者必备技能&lt;/a&gt; 的博客. 其中有一个条目提到了 GraphQL, 称它为 &lt;code&gt;REST 2.0&lt;/code&gt;, 再加上之前偶然间看到最新版的 Github API 使用了 GraphQL, 便想了解一下它到底是个什么东东.&lt;/p&gt;&lt;p&gt;GraphQL 是 Graph Query Language 的简称, 在 Github &lt;a href=&quot;https://developer.github.com/v4/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt; 中指出了 GraphQL 的几个特点:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;A Specification&lt;/code&gt; 可以在 API Server 上定义 Schema, 客户端发起的 query 请求会基于 Schema 进行验证;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Strongly typed&lt;/code&gt; 强类型; 可以在 Schema 中指定某个 field 的类型, 以及不同对象之间的关系;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Introspective&lt;/code&gt; 客户端可以通过 query 获取详细的 Schema 定义;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Hierarchical&lt;/code&gt; API 调用是基于 query 中指定的层级关系及 fields 进行返回的, 不会返回不必要的冗余信息;&lt;/li&gt;&lt;li&gt;&lt;code&gt;An application layer&lt;/code&gt; GraphQL 不是一种数据存储模型或者数据库查询语言, 它可以连接不同的数据存储源;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Web" scheme="https://hiberabyss.github.io/categories/web/"/>
    
    
      <category term="GraphQL" scheme="https://hiberabyss.github.io/tags/graphql/"/>
    
  </entry>
  
  <entry>
    <title>基于 Quorum 集群搭建讲解如何从 docker-compose 迁移到 Kubernetes</title>
    <link href="https://hiberabyss.github.io/2018/05/21/setup-quorum-kubernetes-cluster-step-by-step/"/>
    <id>https://hiberabyss.github.io/2018/05/21/setup-quorum-kubernetes-cluster-step-by-step/</id>
    <published>2018-05-21T18:19:05.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常会遇到搭建多节点集群得需求, 例如摩根推出的基于以太坊的区块链 <a href="https://github.com/jpmorganchase/quorum" rel="external nofollow noopener noreferrer" target="_blank">Quorum</a>. 对于这种搭建多借点得需求, 我一般都是先通过 docker-compose 在本地实现多节点, 然后再基于 docker-compose 迁移到 Kubernetes .</p><p>这样做是因为基于 docker-compose 来实现要简单很多:</p><ul><li>调试很方便;</li><li>多节点间通过 Volume Map 可以很容易地实现数据共享;</li></ul><p>同时, 我们在实现 docker-compose 多节点阶段的很多工作, 如创建 Docker Image 及编写 <code>entrypoint.sh</code> 等, 都可以在往 Kubernetes 上迁移时被复用到. 基于 docker-compose 的多节点环境也能作为开发环境使用.</p><a id="more"></a><h1 id="基于本机-Volume-Map-数据共享的多借点搭建"><a href="#基于本机-Volume-Map-数据共享的多借点搭建" class="headerlink" title="基于本机 Volume Map 数据共享的多借点搭建"></a>基于本机 Volume Map 数据共享的多借点搭建</h1><p>在网上搜索 Quorum 的集群搭建时搜索到了 <a href="https://github.com/lucassaldanha/quorum-docker-Nnodes" rel="external nofollow noopener noreferrer" target="_blank">这个</a> 实现方法. 它主要是通过 Shell 脚本提前生成好每个节点所需要得数据, 然后再分别 map 到对应的节点中.</p><p>原方案因为 geth 的更新, 在创建 contract 的时候会报错, 我对这个问题做了修复, 把修复好之后的 代码存放在 <a href="https://github.com/hiberabyss/quorum/tree/master/docker-deploy" rel="external nofollow noopener noreferrer" target="_blank">Github</a> 上.</p><h2 id="运行-Quorum-集群"><a href="#运行-Quorum-集群" class="headerlink" title="运行 Quorum 集群"></a>运行 Quorum 集群</h2><ol><li><p>首先执行初始化脚本 <code>./setup.sh</code> , 生成节点需要的数据及对应的 <code>docker-compose.yml</code> 文件; 其中 <code>setup.sh</code> 可以接收一个指定节点数量得参数;</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  docker-deploy git:(master) ./setup.sh 5</span><br><span class="line">[1] Configuring for 5 nodes.</span><br><span class="line">[2] Creating Enodes and static-nodes.json.</span><br><span class="line">[3] Creating Ether accounts and genesis.json.</span><br><span class="line">WARN [05-22|04:52:46] No etherbase set and no accounts found as default</span><br><span class="line">WARN [05-22|04:52:49] No etherbase set and no accounts found as default</span><br><span class="line">WARN [05-22|04:52:52] No etherbase set and no accounts found as default</span><br><span class="line">WARN [05-22|04:52:55] No etherbase set and no accounts found as default</span><br><span class="line">WARN [05-22|04:52:58] No etherbase set and no accounts found as default</span><br><span class="line">[4] Creating Quorum keys and finishing configuration.</span><br><span class="line">Node 1 public key: lxXXlk1QBVoR9Y7C6/Ok13oXmqK8Vf0H1YREln9z8Gg=</span><br><span class="line">Node 2 public key: wLBfII80GiQK+1SSRU/7feuY9uHgtDY6gbNUGHJUGUA=</span><br><span class="line">Node 3 public key: KL6AOgHe/odYTGUw8uXAUuBHN2XTzv7qboylTL8FFjM=</span><br><span class="line">Node 4 public key: TgHZCt5cCnYq5k2PvUUYoYZLGGAmitFtvc1WSUgDeGQ=</span><br><span class="line">Node 5 public key: JkFVrzMKOocv0LLMdd7kIXLAMXgpvp49QNQLjKC61WI=</span><br></pre></td></tr></table></figure></li><li><p>紧接着就可以调用 <code>docker-compose up -d</code> 来启动集群;</p></li><li>集群启动后会创建 5 个 Quorum 的 container, 我们可以进入任一个 container 执行创建 smart contract 的操作: <img src="http://on2hdrotz.bkt.clouddn.com/blog/1526965078961.png" width="941"></li><li>这里创建的 smart contract 只是一个简单的整数存取, 我们在 js 文件里创建了一个 <code>storage</code> 的 contract 对象, 可以通过它来调用 smart contract 的操作: <img src="http://on2hdrotz.bkt.clouddn.com/blog/1526965259018.png" width="492"></li><li>我们可以进入别的节点, 加载我们之前创建的 smart contract : <img src="http://on2hdrotz.bkt.clouddn.com/blog/1526965507179.png" width="750"></li><li>然后读取 smart contract 保存的整数值: <img src="http://on2hdrotz.bkt.clouddn.com/blog/1526965565536.png" width="377"></li></ol><p>由此可见整个集群是正常工作的.</p><h1 id="去除数据共享的本机多节点搭建"><a href="#去除数据共享的本机多节点搭建" class="headerlink" title="去除数据共享的本机多节点搭建"></a>去除数据共享的本机多节点搭建</h1><p>由于 Kubernetes 上不同 POD 之间共享数据相对会比较麻烦, 而上一个实现方法需要各个节点能够 共享提前生成好的数据. 经过分析我们可以发现不同节点需要共享的数据主要包括以下这些:</p><ul><li>每个节点的 <code>static-nodes.json</code> 需要填写上其它节点的 IP ;</li><li>每个节点的 <code>tm.conf</code> 文件中需要包括别得节点在 Quorum 系统中的 ID ;</li></ul><p>这里我们可以通过 http server 的方式来实现不同节点间的数据共享:</p><ul><li>我们可以在节点内部获取 IP 及 ID 等信息, 将它们保存在文件 <code>env.sh</code> 中;</li><li>然后通过 <code>python -m SimpleHTTPServer 80 &amp;</code> 启动一个 http server ;</li><li>别的节点就可以通过访问 <code>nodename/env.sh</code> 来获取必要得其它节点的信息;</li></ul><p>基于上面的思路, 我实现了不需要通过 Volume Map 共享数据的本机多节点集群得搭建. 具体得代码放在了 <a href="https://github.com/hiberabyss/quorum/tree/master/noscript-docker" rel="external nofollow noopener noreferrer" target="_blank">noscript-docker</a>, 其中主要得逻辑处理都在文件 <code>entrypoint.sh</code> 中.</p><h1 id="实现在-Kubernetes-上搭建多机集群"><a href="#实现在-Kubernetes-上搭建多机集群" class="headerlink" title="实现在 Kubernetes 上搭建多机集群"></a>实现在 Kubernetes 上搭建多机集群</h1><p>其实上一步已经完成了大部分的工作, 接下来我们只需要创建对应的 <code>statefulset</code> 文件即可. 这里我们基于 helm 来实现对应得脚本文件. 对应的 <code>templates/statefulset.yaml</code> 文件 内容如下所示:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">quorum</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">quorum</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.replicaCount</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">podManagementPolicy:</span> <span class="string">Parallel</span></span><br><span class="line">  <span class="attr">updateStrategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">OnDelete</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">quorum</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">quorum</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">hbliu/quorum-k8s:latest</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NODE_NUMBER</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"<span class="template-variable">&#123;&#123; .Values.replicaCount &#125;&#125;</span>"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NODE_PREFIX</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">"quorum-"</span></span><br></pre></td></tr></table></figure><p>其中的配置信息都存放在了 <code>values.yaml</code> 文件中:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">replicaCount:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">image:</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">hbliu/quorum-k8s</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/hiberabyss/quorum/tree/master/helm/quorum" rel="external nofollow noopener noreferrer" target="_blank">这里</a> 存放了 完整的 helm 包内容.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文首先介绍了如何基于 Volume 映射实现多机节点间的数据共享来搭建多机节点; 接着通过 http server 的方式去除不同节点间的数据共享依赖, 最后再基于它来实现 Kubernetes 的部署脚本.</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2017/12/01/k8s-run-commands-on-multiple-nodes/">在 Kubernetes 的多个 Nodes 上执行命令</a></li><li><a href="https://hiberabyss.github.io/2017/11/22/k8s-persistent-volume/">利用 AWS 的 EBS 为 kubernetes 集群添加持久化存储</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常会遇到搭建多节点集群得需求, 例如摩根推出的基于以太坊的区块链 &lt;a href=&quot;https://github.com/jpmorganchase/quorum&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Quorum&lt;/a&gt;. 对于这种搭建多借点得需求, 我一般都是先通过 docker-compose 在本地实现多节点, 然后再基于 docker-compose 迁移到 Kubernetes .&lt;/p&gt;&lt;p&gt;这样做是因为基于 docker-compose 来实现要简单很多:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;调试很方便;&lt;/li&gt;&lt;li&gt;多节点间通过 Volume Map 可以很容易地实现数据共享;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;同时, 我们在实现 docker-compose 多节点阶段的很多工作, 如创建 Docker Image 及编写 &lt;code&gt;entrypoint.sh&lt;/code&gt; 等, 都可以在往 Kubernetes 上迁移时被复用到. 基于 docker-compose 的多节点环境也能作为开发环境使用.&lt;/p&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="https://hiberabyss.github.io/categories/kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="https://hiberabyss.github.io/tags/kubernetes/"/>
    
      <category term="Quorum" scheme="https://hiberabyss.github.io/tags/quorum/"/>
    
      <category term="Blockchain" scheme="https://hiberabyss.github.io/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>Shell 脚本里遇到的一些坑</title>
    <link href="https://hiberabyss.github.io/2018/05/16/shell-script-tips/"/>
    <id>https://hiberabyss.github.io/2018/05/16/shell-script-tips/</id>
    <published>2018-05-16T23:21:02.000Z</published>
    <updated>2021-02-10T07:01:06.360Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写 Shell 脚本的时候遇到了一些坑, 稍不留意就会踩到, 在这里和大家分享一下.</p><a id="more"></a><h1 id="使用-gt-或-lt-等进行数字的大小比较"><a href="#使用-gt-或-lt-等进行数字的大小比较" class="headerlink" title="使用 &gt; 或 &lt; 等进行数字的大小比较"></a>使用 <code>&gt;</code> 或 <code>&lt;</code> 等进行数字的大小比较</h1><p>在 Shell 脚本里有需要对数字进行比较的地方, 发现当数字变为两位数之后结果就会不对. 仔细检查了源代码, 发现是错误地使用了 <code>&gt;</code> 进行了数字的比较. 但 <code>&lt;</code> 和 <code>&gt;</code> 其实都是用于字符串比较, 它会按顺序比较每一个字符的大小. 例如对于如下的代码:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [[ 3 &gt; 2  ]]; then echo 'yes'; else echo 'no'; fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: yes</span></span><br><span class="line"></span><br><span class="line">if [[ 10 &gt; 2  ]]; then echo 'yes'; else echo 'no'; fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: no</span></span><br></pre></td></tr></table></figure><p>可以看到 <code>10 &gt; 2</code> 的返回结果是 false , 和我们的预期是不一致的. 这里应该使用 <code>-gt</code> 进行比较:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [[ 10 -gt 2  ]]; then echo 'yes'; else echo 'no'; fi&lt;Paste&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Output: yes</span></span><br></pre></td></tr></table></figure><p>更多相关资料可以通过 <code>man test</code> 查看.</p><h1 id="Shell-脚本里变量的作用域"><a href="#Shell-脚本里变量的作用域" class="headerlink" title="Shell 脚本里变量的作用域"></a>Shell 脚本里变量的作用域</h1><p>假设有这样一个需求希望你用 Shell 脚本来实现: 输出五行 <code>01234</code>.</p><p>你可能很快就会写出下面的代码:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">print_num() &#123;</span><br><span class="line">    for (( i = 0; i &lt; 5; i++ )); do</span><br><span class="line">        echo -n $i</span><br><span class="line">    done</span><br><span class="line">    echo ""</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print_line() &#123;</span><br><span class="line">    for (( i = 0; i &lt; 5; i++ )); do</span><br><span class="line">        print_num</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print_line</span><br></pre></td></tr></table></figure><p>然后当你执行的时候会发现输出结果只有一行 <code>01234</code>.</p><p>这是为什么呢? 秘密就藏在变量 <code>i</code> 里. Shell 脚本里的变量默认都是全局变量, 当我们执行完一次 <code>print_num</code> 函数后, <code>i</code> 就变成了 5, 因为 <code>i</code> 是全局变量, 其值的改变也能反映到函数 <code>print_line</code> 里, 当 <code>print_num</code> 返回之后, <code>print_line</code> 的循环条件也就不满足了.</p><p>怎么修复这个问题呢? 我们可以先在 <code>print_line</code> 的 for 循环前加上 <code>local i</code> 的声明. 发现结果还是一样的, 这说明在函数内部被声明成 <code>local</code> 的变量, 在其后续被调用的函数里还是依然可见的.</p><p>我们再尝试在 <code>print_num</code> 的 for 循环前面加上 <code>local i</code> 的声明呢? 这次发现结果是和我们的预期一致的:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01234</span><br><span class="line">01234</span><br><span class="line">01234</span><br><span class="line">01234</span><br><span class="line">01234</span><br></pre></td></tr></table></figure><p>上面的例子告诫我们, 在定义变量时, 如果它不是全局变量, 要养成加上 <code>local</code> 声明的好习惯!</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Shell 作为一种脚本语言, 语法检查没有 C++ 之类的编程语言严格, 则虽然可以带来很大的灵活性, 但无形中也增加了犯错的可能性. 本文会不断更新我在编写 Shell 脚本时遇到的坑!</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/04/05/shell-file-description/">Bash 里的文件描述符</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写 Shell 脚本的时候遇到了一些坑, 稍不留意就会踩到, 在这里和大家分享一下.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://hiberabyss.github.io/categories/linux/"/>
    
    
      <category term="Shell" scheme="https://hiberabyss.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 入门教程</title>
    <link href="https://hiberabyss.github.io/2018/05/08/kafka-demo/"/>
    <id>https://hiberabyss.github.io/2018/05/08/kafka-demo/</id>
    <published>2018-05-08T12:03:15.000Z</published>
    <updated>2018-05-09T16:12:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>Kafka 现在在我们公司使用的很广泛, 如用作 AdServer 的日志收集和 Counter 服务的消息系统等.</p><p>本文会先介绍下 Kafka 的一些基本概念, 然后介绍如何搭建 Kafka 集群和如何使用, 最后会简要介绍下 Kafka 文件存储的实现原理.</p><a id="more"></a><h1 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h1><ul><li><code>Broker</code> 可以简单理解为一个 Kafka 节点, 多个 Broker 节点构成整个 Kafka 集群;</li><li><code>Topic</code> 某种类型的消息的合集;<ul><li><code>Partition</code> 它是 Topic 在物理上的分组, 多个 Partition 会被分散地存储在不同的 Kafka 节点上; 单个 Partition 的消息是保证有序的, 但整个 Topic 的消息就不一定是有序的;</li><li><code>Segment</code> 包含消息内容的指定大小的文件, 由 index 文件和 log 文件组成; 一个 Partition 由多个 Segment 文件组成<ul><li><code>Offset</code> Segment 文件中消息的索引值, 从 0 开始计数</li></ul></li><li><code>Replica (N)</code> 消息的冗余备份, 表现为每个 Partition 都会有 N 个完全相同的冗余备份, 这些备份会被尽量分散存储在不同的机器上;</li></ul></li><li><code>Producer</code> 通过 Broker 发布新的消息到某个 Topic 中;</li><li><code>Consumer</code> 通过 Broker 从某个 Topic 中获取消息;</li></ul><h1 id="如何使用-Kafka"><a href="#如何使用-Kafka" class="headerlink" title="如何使用 Kafka"></a>如何使用 Kafka</h1><p>首先介绍下如何搭建 Kafka 集群. 我们基于 docker-compose 来搭建一个 2 个节点的集群, <a href="https://github.com/wurstmeister/kafka-docker" rel="external nofollow noopener noreferrer" target="_blank">这里</a> 是详细的介绍文档.</p><h2 id="搭建-Kafka-集群"><a href="#搭建-Kafka-集群" class="headerlink" title="搭建 Kafka 集群"></a>搭建 Kafka 集群</h2><p>首先编写一个 <code>docker-compose.yml</code> 文件:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wurstmeister/zookeeper</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"2181:2181"</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wurstmeister/kafka</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9092"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_HOST_NAME:</span> <span class="number">192.168</span><span class="number">.99</span><span class="number">.100</span></span><br><span class="line">      <span class="attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="string">zookeeper:2181</span></span><br><span class="line">      <span class="attr">KAFKA_CREATE_TOPICS:</span> <span class="string">test:1:1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br></pre></td></tr></table></figure><p>其中 <code>KAFKA_ADVERTISED_HOST_NAME</code> 需要被替换成你本机的 IP 地址, 不能是 <code>localhost</code> <code>0.0.0.0</code> 之类的地址. <code>KAFKA_CREATE_TOPICS</code> 是为了演示可以在 Kafka 集群启动的时候创建一些默认的 Topic; <code>test:1:1</code> 的含义是默认创建一个名字为 <code>test</code>, Partition 和 Replica 数量都为 1 的 Topic.</p><p>在 <code>docker-compose.yml</code> 文件所在的目录执行 <code>docker-compose up -d --scale kafka=2</code> 就会在本机启动一个有两个节点的 Kafka 集群:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Kafka git:(master) docker-compose up -d --scale kafka=2</span><br><span class="line">Creating network "kafka_default" with the default driver</span><br><span class="line">Creating kafka_kafka_1     ... done</span><br><span class="line">Creating kafka_kafka_2     ... done</span><br><span class="line">Creating kafka_zookeeper_1 ... done</span><br><span class="line">➜  Kafka git:(master) docker ps</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                  CREATED                  STATUS              PORTS                                                NAMES</span><br><span class="line">d5927ffbd582        wurstmeister/kafka       "start-kafka.sh"         Less than a second ago   Up 6 seconds        0.0.0.0:32774-&gt;9092/tcp                              kafka_kafka_2</span><br><span class="line">17916afee832        wurstmeister/zookeeper   "/bin/sh -c '/usr/sb…"   Less than a second ago   Up 7 seconds        22/tcp, 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp   kafka_zookeeper_1</span><br><span class="line">578c02c01fd9        wurstmeister/kafka       "start-kafka.sh"         Less than a second ago   Up 6 seconds        0.0.0.0:32773-&gt;9092/tcp                              kafka_kafka_1</span><br></pre></td></tr></table></figure><p>两个节点的 Kafka 集群已经成功启动, 节点对应的 container 名分别为 <code>kafka_kafka_1</code> 和 <code>kafka_kafka_2</code>.</p><h2 id="通过-Cli-工具演示生产和消费消息"><a href="#通过-Cli-工具演示生产和消费消息" class="headerlink" title="通过 Cli 工具演示生产和消费消息"></a>通过 Cli 工具演示生产和消费消息</h2><p>Kafka 官方自带了一些 cli 工具, 可以进入到 container 内部去访问这些命令:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Kafka git:(master) docker exec -it kafka_kafka_1 bash</span><br><span class="line">bash-4.4# $KAFKA_HOME/bin/kafka-topics.sh --describe --zookeeper kafka_zookeeper_1:2181</span><br><span class="line">Topic:test      PartitionCount:1        ReplicationFactor:1     Configs:</span><br><span class="line">        Topic: test     Partition: 0    Leader: 1001    Replicas: 1001  Isr: 1001</span><br></pre></td></tr></table></figure><p>上面的命令列出了当前 Kafka 集群的所有 Topic.</p><p>我自己更喜欢直接在宿主机访问 Kafka 集群, 这就需要先安装上 kafka , 在 macOS 中可以通过 <code>brew install kafka</code> 来安装.</p><p>安装完成后的使用方法和上面类似, 如列出所有 topic :</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Kafka git:(master) kafka-topics --describe --zookeeper localhost:2181</span><br><span class="line">Topic:test      PartitionCount:1        ReplicationFactor:1     Configs:</span><br><span class="line">        Topic: test     Partition: 0    Leader: 1001    Replicas: 1001  Isr: 1001</span><br></pre></td></tr></table></figure><p>接下来我们来演示如何生产与消费消息.</p><p><strong>创建一个新的 Topic:</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Kafka git:(master) kafka-topics --create --topic chat --partitions 3 --zookeeper localhost:2181 --replication-factor 2</span><br><span class="line">Created topic "chat".</span><br></pre></td></tr></table></figure><p>新创建的 Topic 名字为 chat, partition 数为 3, replica 数为 2. 可以通过下面的命令验证 Topic 是否成功创建:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  Kafka git:(master) kafka-topics --describe --zookeeper localhost:2181</span><br><span class="line">Topic:chat      PartitionCount:3        ReplicationFactor:2     Configs:</span><br><span class="line">        Topic: chat     Partition: 0    Leader: 1001    Replicas: 1001,1002     Isr: 1001,1002</span><br><span class="line">        Topic: chat     Partition: 1    Leader: 1002    Replicas: 1002,1001     Isr: 1002,1001</span><br><span class="line">        Topic: chat     Partition: 2    Leader: 1001    Replicas: 1001,1002     Isr: 1001,1002</span><br><span class="line">Topic:test      PartitionCount:1        ReplicationFactor:1     Configs:</span><br><span class="line">        Topic: test     Partition: 0    Leader: 1001    Replicas: 1001  Isr: 1001</span><br></pre></td></tr></table></figure><p><strong>创建生产者和消费者进程</strong></p><p>消息的生产和消费都需要知道对应的 Broker 地址, 如果在 docker 宿主机上访问的话就需要知道对应的映射端口. 我们可以通过下面的命令获取:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1525811302856.png" width="527"></p><p>然后通过下面的命令分别去创建消息生产者和消费者:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-console-producer --broker-list localhost:32773 --topic chat</span><br><span class="line">kafka-console-consumer --bootstrap-server localhost:32773 --topic chat --from-beginning</span><br></pre></td></tr></table></figure><p>在生产者中输入消息, 就可以在消费者中看到对应的消息输出了, 效果如下图所示:</p><p><img src="kafka_cli.gif" alt></p><p>可以通过 <code>&lt;Ctrl-c&gt;</code> 来退出这两个进程.</p><h1 id="文件存储原理介绍"><a href="#文件存储原理介绍" class="headerlink" title="文件存储原理介绍"></a>文件存储原理介绍</h1><p>我们先回顾下前面关于 Topic chat 的一些信息:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Topic:chat      PartitionCount:3        ReplicationFactor:2     Configs:</span><br><span class="line">        Topic: chat     Partition: 0    Leader: 1001    Replicas: 1001,1002     Isr: 1001,1002</span><br><span class="line">        Topic: chat     Partition: 1    Leader: 1002    Replicas: 1002,1001     Isr: 1002,1001</span><br><span class="line">        Topic: chat     Partition: 2    Leader: 1001    Replicas: 1001,1002     Isr: 1001,1002</span><br></pre></td></tr></table></figure><p>从上面可以看出 ID 为 1001 的节点 (kafka_kafka_1) 存储了 Partition 0 和 Partitiont 2 的 Leader 部分, 同时也存储了 Partition 1 的一个备份.</p><p><strong>Partition 是按照下面的算法分布到多个 Kafka 节点:</strong></p><ul><li>将所有 N 个 Broker 和待分配的 M 个Partition排序;</li><li>将第 i 个 Partition 分配到第 (i mod N) 个Broker上;</li><li>将第 i 个 Partition 的第 j 个副本分配到第 ((i + j) mod N) 个Broker上.</li></ul><p><strong>接下来我们看一看 Partition 具体是怎么存储的</strong></p><p>我们可以登录到节点 1001 内部看下对应的文件存储:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  blog git:(hexo) ✗ docker exec -it kafka_kafka_1 bash</span><br><span class="line">bash-4.4# cd /kafka/kafka-logs-578c02c01fd9/</span><br><span class="line">bash-4.4# ls -d chat*</span><br><span class="line">chat-0  chat-1  chat-2</span><br></pre></td></tr></table></figure><p>可以看到每一个 Partition 都是和一个目录对应的, 同时每一个目录里都包含了一个 index 文件和 log 文件:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash-4.4# ls -lh chat-0</span><br><span class="line">total 16</span><br><span class="line">-rw-r--r--    1 root     root       10.0M May  8 20:52 00000000000000000000.index</span><br><span class="line">-rw-r--r--    1 root     root          77 May  8 20:35 00000000000000000000.log</span><br><span class="line">-rw-r--r--    1 root     root       10.0M May  8 20:52 00000000000000000000.timeindex</span><br><span class="line">-rw-r--r--    1 root     root          10 May  8 20:52 00000000000000000001.snapshot</span><br><span class="line">-rw-r--r--    1 root     root           8 May  8 20:35 leader-epoch-checkpoint</span><br></pre></td></tr></table></figure><p>其中 log 文件存储实际的消息内容, 而和它同名的 index 文件存储消息的索引数据. log 的文件名存放的是上一个 log 文件中最后一个消息的 offset 值.</p><p><strong>可以按照下面的方法找到指定 offset 对应的消息</strong></p><ul><li>首先定位到对应的 segment ; 这个直接根据文件名进行二分查找就可以找到对应的 segement 了;</li><li>再在 segment 的 index 文件中顺序查找到 offset 在 log 文件中的位置; index 文件会被映射到内存中.</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Kafka 通过给 Topic 指定多个 Partition, 而各个 Partition 分布在不同的节点上, 这样便能提供比较好的并发能力. 同时, 对于 Partition 还可以指定对应的 Replica 数, 这也极大地提高了数据存储的安全性, 防止出现数据丢失.</p><p>基于文件名去辅助定位消息的设计还是很巧妙的!</p><p>最开始计划写本文时是想通过设计一个聊天的场景来讲解的, 发送者是消息生产者, 接受者是消息的消费者, 对于每个用户都去生成一个对应的 Topic. 后来觉得工作量有些略大, 就放弃了. 或许想学习 Go 的 Kafaka SDK <a href="https://godoc.org/github.com/Shopify/sarama" rel="external nofollow noopener noreferrer" target="_blank">sarama</a> 的时候就会去实现这个示例.</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://scala.cool/2018/03/learning-kafka-1/" rel="external nofollow noopener noreferrer" target="_blank">Kafka 学习笔记（一） ：为什么需要 Kafka？</a></li><li><a href="http://colobu.com/2014/08/06/kafka-quickstart/" rel="external nofollow noopener noreferrer" target="_blank">Kafka快速入门</a></li><li><a href="https://tech.meituan.com/kafka-fs-design-theory.html" rel="external nofollow noopener noreferrer" target="_blank">Kafka文件存储机制那些事</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kafka 现在在我们公司使用的很广泛, 如用作 AdServer 的日志收集和 Counter 服务的消息系统等.&lt;/p&gt;&lt;p&gt;本文会先介绍下 Kafka 的一些基本概念, 然后介绍如何搭建 Kafka 集群和如何使用, 最后会简要介绍下 Kafka 文件存储的实现原理.&lt;/p&gt;
    
    </summary>
    
      <category term="Tool" scheme="https://hiberabyss.github.io/categories/tool/"/>
    
    
      <category term="Kafka" scheme="https://hiberabyss.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>给 maupassant 主题添加文章版权信息和推荐阅读功能</title>
    <link href="https://hiberabyss.github.io/2018/05/06/hexo-copyright-recommendations/"/>
    <id>https://hiberabyss.github.io/2018/05/06/hexo-copyright-recommendations/</id>
    <published>2018-05-06T18:14:22.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>在网上看过别人的博客主题后, 发现我现在用的 maupassant 主题缺少了两个实用的功能: 在文章末尾添加版权信息和相关文章推荐阅读.</p><p>既然缺少功能, 那就参照别人的代码添加上对应的功能呗, 这就是我为什么选择自己搭建独立博客的原因: 可以随心所欲地进行定制化.</p><a id="more"></a><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>下面是按照本文步骤操作完成之后的效果:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1525645916729.png" width="754"></p><p>其中第一部分推荐阅读是通过插件 <a href="https://github.com/huiwang/hexo-recommended-posts" rel="external nofollow noopener noreferrer" target="_blank">hexo-recommended-posts</a> 来实现的, 它不仅可以推荐你自己的博客, 还可以推荐别人的相关博客. 如果有比较多人使用这个插件的话, 不仅能帮读者快速找到感兴趣的内容, 同时也能增加自己博客的流量.</p><h1 id="在文章末尾自动添加版权信息"><a href="#在文章末尾自动添加版权信息" class="headerlink" title="在文章末尾自动添加版权信息"></a>在文章末尾自动添加版权信息</h1><p>我们先在主题的 <code>_config.yml</code> 中添加一些配置信息:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">author:</span> <span class="string">"Hongbo Liu"</span></span><br></pre></td></tr></table></figure><p>然后在 <code>layout/post.pug</code> 文件中添加相关代码:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if theme.post_copyright.enable == true</span><br><span class="line">  div</span><br><span class="line">    ul.post-copyright</span><br><span class="line">      li.post-copyright-author</span><br><span class="line">        strong 本文作者：</span><br><span class="line">        = theme.post_copyright.author</span><br><span class="line">      li.post-copyright-link</span><br><span class="line">        strong 本文链接：</span><br><span class="line">        a(href=&apos;/&apos; + page.path)= page.permalink</span><br><span class="line">      li.post-copyright-license</span><br><span class="line">        strong 版权声明：</span><br><span class="line">        | 本博客所有文章除特别声明外，均采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/cn/&quot; rel=&quot;external nofollow&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 3.0 CN&lt;/a&gt; 许可协议。转载请注明出处！</span><br><span class="line">  br</span><br></pre></td></tr></table></figure><p>最后在 <code>source/css/style.scss</code> 样式文件中添加对应的样式描述:</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Custom styles.</span></span><br><span class="line"><span class="selector-class">.post-copyright</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">2em</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">3px</span> solid <span class="number">#FF1700</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#F9F9F9</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="selector-tag">li</span> &#123;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">8px</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文章推荐功能支持"><a href="#文章推荐功能支持" class="headerlink" title="文章推荐功能支持"></a>文章推荐功能支持</h1><p>先安装 hexo-recommended-posts :</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-recommended-posts --save</span><br></pre></td></tr></table></figure><p>安装完这个 hexo 插件后直接执行 <code>hexo recommend</code> , 其实就已经可以添加推荐文章支持. 如下图所示:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1525647516111.png" width="418"></p><p>但这里的推荐文章是和博客正文混在一起的, 而且样式也不好看. 我们还是把它放在正文后面, 使用和版权信息类似的样式.</p><p>首先我们还是需要在主题的 <code>_config.yml</code> 文件中添加一些配置信息:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">recommended_posts:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后同样也是在 <code>layout/post.pug</code> 文件中添加相关的代码:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if theme.recommended_posts.enable == true</span><br><span class="line">  div.recommended_posts</span><br><span class="line">    h3() 推荐阅读</span><br><span class="line">    - var post_list = recommended_posts(page, site)</span><br><span class="line">    - for (var i in post_list)</span><br><span class="line">        li</span><br><span class="line">          a(href=post_list[i].permalink, target=&apos;_blank&apos;)= post_list[i].title</span><br></pre></td></tr></table></figure><p>再在 <code>source/css/style.scss</code> 中添加样式配置:</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.recommended_posts</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">3px</span> solid <span class="number">#6f42c1</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f5f0fa</span>;</span><br><span class="line">    <span class="selector-tag">li</span> &#123; <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123; <span class="attribute">color</span>: blue; &#125;</span><br><span class="line">    <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">text-decoration</span>:underline;<span class="attribute">color</span>: red&#125;</span><br><span class="line">    a:visited &#123; color: green; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们还需要在博客的 <code>_config.yml</code> 文件中添加插件相关的配置信息:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">recommended_posts:</span></span><br><span class="line">  <span class="attr">autoDisplay:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>现在当我们执行下列命令后便可以在博客中看到推荐文章相关的信息:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo recommend</span><br><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>完整的代码存放在 <a href="https://github.com/hiberabyss/maupassant-hexo/blob/499d5ef3f73b6735cd5cf848438055501208a59b/layout/post.pug" rel="external nofollow noopener noreferrer" target="_blank">Github</a> 上面.</p><p>这里的代码修改还是很简单的, 不过因为对 Pug 的语法不熟悉, 导致浪费了不少时间, 还是应该好好了解下这门 html 的模版语言的. 在后面的参考链接中我也列出了 pug 的一些学习文档.</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="http://stevenshi.me/2017/05/26/hexo-add-copyright/" rel="external nofollow noopener noreferrer" target="_blank">hexo文章末尾添加版权信息</a></li><li><a href="https://github.com/huiwang/hexo-recommended-posts" rel="external nofollow noopener noreferrer" target="_blank">hexo-recommended-posts</a></li><li><a href="https://github.com/pugjs/pug-zh-cn/blob/master/Readme_zh-cn.md" rel="external nofollow noopener noreferrer" target="_blank">Pug - 模板引擎</a></li><li><a href="http://www.url.com" rel="external nofollow noopener noreferrer" target="_blank">Pug 官方文档</a></li><li><a href="https://hamger.github.io/2017/04/07/pug%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/" rel="external nofollow noopener noreferrer" target="_blank">pug模板语法</a></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/03/19/hexo-gitalk-integration/">给 Hexo 博客集成 gitalk 评论系统</a></li><li><a href="https://hiberabyss.github.io/2017/03/13/hexo-tutorial/">Hexo 入门教程</a></li><li><a href="https://hiberabyss.github.io/2017/03/13/hexo-source-code-backup/">Hexo 源文件备份</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网上看过别人的博客主题后, 发现我现在用的 maupassant 主题缺少了两个实用的功能: 在文章末尾添加版权信息和相关文章推荐阅读.&lt;/p&gt;&lt;p&gt;既然缺少功能, 那就参照别人的代码添加上对应的功能呗, 这就是我为什么选择自己搭建独立博客的原因: 可以随心所欲地进行定制化.&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://hiberabyss.github.io/categories/hexo/"/>
    
    
      <category term="Hexo" scheme="https://hiberabyss.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>用 go 实现简易版的请求限流和流量统计</title>
    <link href="https://hiberabyss.github.io/2018/05/04/request-limit-and-qps-statistics/"/>
    <id>https://hiberabyss.github.io/2018/05/04/request-limit-and-qps-statistics/</id>
    <published>2018-05-04T00:03:49.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目需要用到限流和统计流量的功能, 便用 go 基于计数器的原理简单地实现了这两个功能.</p><a id="more"></a><h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><p>限流的要求是在指定的时间间隔内, server 最多只能服务指定数量的请求. 实现的原理是我们启动一个计数器, 每次服务请求会把计数器加一, 同时到达指定的时间间隔后会把计数器清零; 这个计数器的实现代码如下所示:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RequestLimitService <span class="keyword">struct</span> &#123;</span><br><span class="line">Interval time.Duration</span><br><span class="line">MaxCount <span class="keyword">int</span></span><br><span class="line">Lock     sync.Mutex</span><br><span class="line">ReqCount <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRequestLimitService</span><span class="params">(interval time.Duration, maxCnt <span class="keyword">int</span>)</span> *<span class="title">RequestLimitService</span></span> &#123;</span><br><span class="line">reqLimit := &amp;RequestLimitService&#123;</span><br><span class="line">Interval: interval,</span><br><span class="line">MaxCount: maxCnt,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ticker := time.NewTicker(interval)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&lt;-ticker.C</span><br><span class="line">reqLimit.Lock.Lock()</span><br><span class="line">fmt.Println(<span class="string">"Reset Count..."</span>)</span><br><span class="line">reqLimit.ReqCount = <span class="number">0</span></span><br><span class="line">reqLimit.Lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> reqLimit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(reqLimit *RequestLimitService)</span> <span class="title">Increase</span><span class="params">()</span></span> &#123;</span><br><span class="line">reqLimit.Lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> reqLimit.Lock.Unlock()</span><br><span class="line"></span><br><span class="line">reqLimit.ReqCount += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(reqLimit *RequestLimitService)</span> <span class="title">IsAvailable</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">reqLimit.Lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> reqLimit.Lock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> reqLimit.ReqCount &lt; reqLimit.MaxCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务请求的时候, 我们会对当前计数器和阈值进行比较, 只有未超过阈值时才进行服务:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> RequestLimit = NewRequestLimitService(<span class="number">10</span> * time.Second, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> RequestLimit.IsAvailable() &#123;</span><br><span class="line">RequestLimit.Increase()</span><br><span class="line">fmt.Println(RequestLimit.ReqCount)</span><br><span class="line">io.WriteString(w, <span class="string">"Hello world!\n"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Reach request limiting!"</span>)</span><br><span class="line">io.WriteString(w, <span class="string">"Reach request limit!\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Server Started!"</span>)</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, helloHandler)</span><br><span class="line">http.ListenAndServe(<span class="string">":8000"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码放在了 <a href="https://github.com/hiberabyss/JustDoIt/blob/master/RequestLimit/request_limit.go" rel="external nofollow noopener noreferrer" target="_blank">Github</a> 上.</p><h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><p>在代码中我们的默认设定是在 10 秒钟内最多只服务 5 个请求. 我们可以每次并行发送 3 个请求看返回结果:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  JustDoIt git:(master) seq 3 | xargs -P10 -I% curl localhost:8000</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">➜  JustDoIt git:(master) seq 3 | xargs -P10 -I% curl localhost:8000</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Reach request limit!</span><br></pre></td></tr></table></figure><p>可以看到发送到第 6 个请求时就触发了限流操作, 和我们预期的行为是一致的.</p><h1 id="流量统计"><a href="#流量统计" class="headerlink" title="流量统计"></a>流量统计</h1><p>流量统计的实现原理也是类似, 先启动一个计数器, 每次请求都会把计数器加一, 同时再启动一个定时器, 每隔一秒就会把当前计数器的值保存下来, 然后再把计数器清零. 代码如下:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> QPS []CountQPS</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CountQPS <span class="keyword">struct</span> &#123;</span><br><span class="line">CountPerSecond <span class="keyword">int</span></span><br><span class="line">Timestamp      <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CounterService <span class="keyword">struct</span> &#123;</span><br><span class="line">CountQPS</span><br><span class="line">CountAll       <span class="keyword">int</span></span><br><span class="line">Lock           sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCounterService</span><span class="params">()</span> *<span class="title">CounterService</span></span> &#123;</span><br><span class="line">counter := &amp;CounterService&#123;&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ticker := time.NewTicker(time.Second)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&lt;-ticker.C</span><br><span class="line">counter.Lock.Lock()</span><br><span class="line">counter.Timestamp = time.Now().Unix()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> counter.CountPerSecond &gt; <span class="number">0</span> &#123;</span><br><span class="line">QPS = <span class="built_in">append</span>(QPS, CountQPS&#123;counter.CountPerSecond, counter.Timestamp&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">counter.CountPerSecond = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">counter.Lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(counter *CounterService)</span> <span class="title">Increase</span><span class="params">()</span></span> &#123;</span><br><span class="line">counter.Lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> counter.Lock.Unlock()</span><br><span class="line"></span><br><span class="line">counter.CountAll++</span><br><span class="line">counter.CountPerSecond++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码保存在 <a href="https://github.com/hiberabyss/JustDoIt/blob/master/QPSstatic/QPS_static.go" rel="external nofollow noopener noreferrer" target="_blank">Github</a> 上.</p><p>在上面的代码中我们只是把每秒的统计值保存在一个 slice 中, 在实际的项目时间中我们可以把这个信息保存在 influxdb 这样的数据库或者 Kafka 中.</p><h2 id="功能测试-1"><a href="#功能测试-1" class="headerlink" title="功能测试"></a>功能测试</h2><p>在上面的完整代码中我们还实现了一个 <code>get_cnt</code> 的 api , 通过它可以打印出当前的所有流量统计值. 让我们来先发送一些请求, 然后看结果是否符合预期:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  JustDoIt git:(master) seq 2 | xargs -P10 -I% curl localhost:8000</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">➜  JustDoIt git:(master) seq 5 | xargs -P10 -I% curl localhost:8000</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br><span class="line">➜  JustDoIt git:(master) curl localhost:8000/get_cnt</span><br><span class="line">timestamp,query_per_second</span><br><span class="line">1525496731,2</span><br><span class="line">1525496734,5</span><br><span class="line">total: 7</span><br></pre></td></tr></table></figure><p>可以看到这个结果也是符合预期的!</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文给出的限流和流量统计的方法是比较简单基础的实现, 在某些情况下会有问题, 如参考文献中提到的在限流时间间隔的特定时间点 发送请, 可能会导致实际流量是设计限制流量的两倍. 但本文的方法用在 demo 类的项目中应该也是没什么问题的 :)</p><p>欢迎大家多多留言交流!</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="http://www.kissyu.org/2016/08/13/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" rel="external nofollow noopener noreferrer" target="_blank">接口限流算法总结</a></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/03/23/golang-slice-analyze/">「Golang」Slice 详解</a></li><li><a href="https://hiberabyss.github.io/2018/03/14/unix-socket-programming/">使用 Go 进行 Socket 编程</a></li><li><a href="https://hiberabyss.github.io/2018/03/12/implement-ping-command-via-golang/">使用 golang 实现 ping 命令</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近项目需要用到限流和统计流量的功能, 便用 go 基于计数器的原理简单地实现了这两个功能.&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://hiberabyss.github.io/categories/go/"/>
    
    
      <category term="Go" scheme="https://hiberabyss.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>利用 Surfingkeys 快速分享博客到开发者头条或掘金</title>
    <link href="https://hiberabyss.github.io/2018/05/03/surfingkeys-blog-share/"/>
    <id>https://hiberabyss.github.io/2018/05/03/surfingkeys-blog-share/</id>
    <published>2018-05-03T14:15:12.000Z</published>
    <updated>2021-02-10T07:01:06.360Z</updated>
    
    <content type="html"><![CDATA[<p>为了能给博客增加访问量 (虽然访问量依然很低 [捂脸]), 我经常会把写好的博客分享到开发者头条和掘金.</p><p>之前是装了开发者头条和掘金的 Chrome 插件, 每次都分别需要点一下插件进行分享. 但单单是为了分享文章就要装两个插件也是很不值得了, 而且这两个插件平时也基本都用不上, 我也是一般都是在分享完博客之后就把它们关闭了. 这里强烈安利一款 Chrome 插件 <a href="https://chrome.google.com/webstore/detail/steward-a-command-launche/dnkhdiodfglfckibnfcjbgddcgjgkacd" rel="external nofollow noopener noreferrer" target="_blank">Steward</a>, 号称是 Chrome 上的 Alfred , 通过它可以很方便地开启或者关闭某个特定插件.</p><p>后来发现通过插件进行分享时只是简单地打开了一个网页, 同时添加上了你博客的网址和标题. 就是类似下面这样一个网址:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://toutiao.io/contribute?url=your_blog_url_encoded&amp;title=your_blog_title_encoded</span><br></pre></td></tr></table></figure><p>打开网页谁不会呀, 只要能获取到页面的 url 和 title . 这时想起我常用的 Chrome 插件 Surfingkeys 提供了映射特定的按键到某个 javascript 函数的功能, 通过 javascript 来获取页面的 url 和 tile 就再容易不过了! 当我们实现这个 javascript 函数之后 就能按几个键打开开发者头条和掘金的分享页面了, 说干就干, Let’s start to hack it out!</p><a id="more"></a><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>先让大家看下最终效果是什么样子的吧, 这样才更有动力!</p><p><img src="chrome_share.gif" alt></p><p>当在我的一篇博客上按 <code>pub</code> 三个按键时可以看到开发者头条和掘金的分享页面就被自动打开了! 如果你也想实现一样的效果就可以接着往下看了.</p><h1 id="Surfingkeys-介绍"><a href="#Surfingkeys-介绍" class="headerlink" title="Surfingkeys 介绍"></a>Surfingkeys 介绍</h1><p><a href="https://chrome.google.com/webstore/detail/surfingkeys/gfbliohnnapiefjpjlpjnehglfpaknnc" rel="external nofollow noopener noreferrer" target="_blank">Surfingkeys</a> 是一款开源的能让你用 Vim 的方式操作网页的 Chrome 插件.</p><p>例如你可以通过 <code>j/k</code> 来上下翻滚网页, 通过 <code>E/R</code> 来左右切换 tab 页, 通过 <code>yy</code> 来复制当前网页的标题, 通过 <code>ymc</code> 来复制列表的某个 column 等, 甚至还可以通过 <code>yG</code> 来给整个网页截屏. 总之, 这个插件很强大, 你可以通过 <code>?</code> 来查看它所有的默认按键.</p><p>我之前也用过别的类似的插件, 如 cVim, Vimium 等, 但它们要么功能不够丰富, 要么有时 Scroll 的时候会有问题, Surfinkeys 是目前所有这类插件中我觉得最好用的!</p><h1 id="添加按键映射"><a href="#添加按键映射" class="headerlink" title="添加按键映射"></a>添加按键映射</h1><p>安利完 Surfingkeys 后我们来看下怎么添加我们想要的按键映射吧.</p><p>首相我们需要打开 Surfkingkeys 的 <a href="chrome-extension://gfbliohnnapiefjpjlpjnehglfpaknnc/pages/options.html" rel="external nofollow noopener noreferrer" target="_blank">设置</a> 页面. 在设置页面中添加以下代码:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mapkey(<span class="string">'pub'</span>, <span class="string">'publish page into Juejin or Toutiao'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = <span class="built_in">encodeURIComponent</span>(<span class="built_in">document</span>.location.href)</span><br><span class="line">    <span class="keyword">var</span> title = <span class="built_in">encodeURIComponent</span>(<span class="built_in">document</span>.title)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toutiao = <span class="string">"https://toutiao.io/contribute?"</span></span><br><span class="line">    toutiao += <span class="string">"url="</span> + url + <span class="string">"&amp;title="</span> + title + <span class="string">"&amp;platform=chrome_extension"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> juejin = <span class="string">"https://juejin.im/new-entry?"</span></span><br><span class="line">    juejin += <span class="string">"url="</span> + url + <span class="string">"&amp;title="</span> + title</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.open(toutiao)</span><br><span class="line">    <span class="built_in">window</span>.open(juejin)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>好了, 大工告成, 现在我们在任意一个页面按 <code>pub</code> 之后便会自动打开开发者头条和掘金对 这个网页的分享页面.</p><h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p>自己在用 Hexo 写博客的时候实现了一些 Vim 命令, 可以新建博客, 启动 hexo server, 部署, 打开当前博客对应的网页等. 可以考虑在有时间的时候把这些命令封装成一个 vim 插件, 到时也可以考虑添加上这个分享博客的命令.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了能给博客增加访问量 (虽然访问量依然很低 [捂脸]), 我经常会把写好的博客分享到开发者头条和掘金.&lt;/p&gt;&lt;p&gt;之前是装了开发者头条和掘金的 Chrome 插件, 每次都分别需要点一下插件进行分享. 但单单是为了分享文章就要装两个插件也是很不值得了, 而且这两个插件平时也基本都用不上, 我也是一般都是在分享完博客之后就把它们关闭了. 这里强烈安利一款 Chrome 插件 &lt;a href=&quot;https://chrome.google.com/webstore/detail/steward-a-command-launche/dnkhdiodfglfckibnfcjbgddcgjgkacd&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Steward&lt;/a&gt;, 号称是 Chrome 上的 Alfred , 通过它可以很方便地开启或者关闭某个特定插件.&lt;/p&gt;&lt;p&gt;后来发现通过插件进行分享时只是简单地打开了一个网页, 同时添加上了你博客的网址和标题. 就是类似下面这样一个网址:&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;https://toutiao.io/contribute?url=your_blog_url_encoded&amp;amp;title=your_blog_title_encoded&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;打开网页谁不会呀, 只要能获取到页面的 url 和 title . 这时想起我常用的 Chrome 插件 Surfingkeys 提供了映射特定的按键到某个 javascript 函数的功能, 通过 javascript 来获取页面的 url 和 tile 就再容易不过了! 当我们实现这个 javascript 函数之后 就能按几个键打开开发者头条和掘金的分享页面了, 说干就干, Let’s start to hack it out!&lt;/p&gt;
    
    </summary>
    
      <category term="Tool" scheme="https://hiberabyss.github.io/categories/tool/"/>
    
    
      <category term="Chrome" scheme="https://hiberabyss.github.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>给 Vim 插件添加上异步调用的功能</title>
    <link href="https://hiberabyss.github.io/2018/05/03/add-async-support-for-vim-plugin/"/>
    <id>https://hiberabyss.github.io/2018/05/03/add-async-support-for-vim-plugin/</id>
    <published>2018-05-03T12:04:55.000Z</published>
    <updated>2021-02-10T07:01:06.352Z</updated>
    
    <content type="html"><![CDATA[<p>一些 Vim 插件可能因为计算密集或者是访问网络资源导致命令调用特别慢, 进而导致 Vim 的操作界面被 hang 住, 时不时地 hang 一下还是很影响流畅度和编码心情的 ):</p><p>还好在 neovim/vim8 中添加了对异步调用的支持, 我们可以利用 job 机制让耗时的操作在后台执行, 然后通过 callback 机制把处理结束后的结果输出. 加上异步操作后, 各种操作都如丝般润滑, 再也不用担心卡顿了 (:</p><p>下面我就以插件 <a href="https://github.com/ianva/vim-youdao-translater" rel="external nofollow noopener noreferrer" target="_blank">vim-youdao-translater</a> 为例来介绍如何给插件添加上异步调用的功能.</p><a id="more"></a><h1 id="vim-youdao-translater-介绍"><a href="#vim-youdao-translater-介绍" class="headerlink" title="vim-youdao-translater 介绍"></a>vim-youdao-translater 介绍</h1><p>这个插件是可以在 Vim 中调用有道词典在线版来翻译英文单词, <a href="https://github.com/ianva/vim-youdao-translater/tree/dev-async" rel="external nofollow noopener noreferrer" target="_blank">官方 repo 库</a> 中有详细的使用介绍.</p><p>但这个插件最开始不是异步调用方式, 因为需要访问有道的网络 api , 经常会在翻译的时候会出现卡顿的情况. 我便提交了 Pull Request , 在 neovim/vim8 里把翻译过程变成了异步调用. 可以通过 <a href="https://hiberabyss.github.io/2018/03/21/vim-plug-introduction/">vim-plug</a> 的方式安装异步调用的版本:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/ianva/vim-youdao-translater.git'</span>, &#123;<span class="string">'branch'</span>: <span class="string">'dev-async'</span>&#125;</span><br></pre></td></tr></table></figure><p>安装完成后我们便可以通过 <code>:Ydc</code> 翻译光标所在位置的单词了.</p><h1 id="如何添加异步调用"><a href="#如何添加异步调用" class="headerlink" title="如何添加异步调用"></a>如何添加异步调用</h1><p>我添加的这个异步调用是通过 neovim/vim8 的 job 机制来实现的, 它的功能和 <code>system</code> 函数类似, 用来执行外部程序, 但不同于 <code>system</code> 调用, 使用 job 执行程序的时候不会等待程序结束时再返回, 而是直接返回, 同时可以在启动 job 的时候增加回调函数来处理外部程序执行的结果.</p><p>启动 job 的函数为 <code>jobstart</code> (neovim) 或 <code>job_start</code> (vim8), 可以通过 <code>:help jobstart(</code> 或 <code>:help job_start(</code> 来查看它们的详细使用文档.</p><p>具体到 youdao-translater 这个插件, 我们需要通过 jobstart 等来执行一个 python 脚本以执行翻译的操作. 先上代码吧:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s:translator_file</span> = <span class="built_in">expand</span>(<span class="string">'&lt;sfile&gt;:p:h'</span>) . <span class="string">"/../youdao.py"</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s:translator</span> = &#123;<span class="string">'stdout_buffered'</span>: <span class="variable">v:true</span>, <span class="string">'stderr_buffered'</span>: <span class="variable">v:true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">translator</span>.<span class="title">on_stdout</span><span class="params">(jobid, data, event)</span></span></span><br><span class="line">    <span class="keyword">if</span> !empty(<span class="variable">a:data</span>) | <span class="keyword">echo</span> <span class="keyword">join</span>(<span class="variable">a:data</span>) | <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s:translator</span>.on_stderr = <span class="function"><span class="keyword">function</span><span class="params">(s:translator.on_stdout)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">translator</span>.<span class="title">start</span><span class="params">(lines)</span></span></span><br><span class="line">    <span class="keyword">let</span> python_cmd = ydt#GetAvailablePythonCmd()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">empty</span>(python_cmd)</span><br><span class="line">        <span class="keyword">echoerr</span> <span class="string">"[YouDaoTranslator] [Error]: Python package neeeds to be installed!"</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> cmd = <span class="built_in">printf</span>(<span class="string">"%s %s %s"</span>, python_cmd, <span class="variable">s:translator_file</span>, <span class="variable">a:lines</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">exists</span>(<span class="string">'*jobstart'</span>)</span><br><span class="line">        <span class="keyword">return</span> jobstart(cmd, self)</span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">exists</span>(<span class="string">'*job_start'</span>)</span><br><span class="line">        <span class="keyword">return</span> job_start(cmd, &#123;<span class="string">'out_cb'</span>: <span class="string">"ydt#VimOutCallback"</span>&#125;)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="built_in">system</span>(cmd)</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure><p>这里调用 <code>jobstart</code> 的时候是用面向对象的方式来写的, <code>s:translator.on_stdout</code> 是对 stdout 内容的回调函数, 可以看出我们只是简单地调用 <code>echo</code> 把 python 脚本输出的翻译结果打印了出来.</p><p>调用 <code>job_start</code> 时的工作机制类似, 只不过是使用了不同的回调函数, 因为 neovim he vim8 的回调函数的参数是不一样的. 函数 <code>ydt#VimOutCallback</code> 的实现如下所示:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">ydt</span>#<span class="title">VimOutCallback</span><span class="params">(chan, msg)</span></span></span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">a:msg</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure><p>这里函数之所以起了这样一个名字, 是因为用到了 vim 的 autoload 机制, 上面的函数是保存在文件 <code>autoload/ydt.vim</code> 中的, 所以函数名需要以 <code>ydt#</code> 开头.</p><p>Vim 的 autoload 机制可以提高 Vim 的启动速度, 因为 autoload 目录下的脚本不会在启动时被加载, 它们只有在有关函数被用到时才会找到对应的文件, 然后把整个文件都加载进来.</p><p>当实现了上面的异步调用接口之后, 我们便可以实现对应的函数调用和命令了:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">YoudaoCursorTranslate</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">call</span> <span class="variable">s:translator</span>.start(<span class="built_in">expand</span>(<span class="string">"&lt;cword&gt;"</span>))</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">command! Ydc <span class="keyword">call</span> <span class="symbol">&lt;SID&gt;</span>YoudaoCursorTranslate()</span><br></pre></td></tr></table></figure><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2020/05/06/vim-open-saz-file/">使用 Vim 查看 Fiddler 生成的 saz 格式 session 包</a></li><li><a href="https://hiberabyss.github.io/2018/04/24/vim-plug-rest-console/">实现类 Postman 功能的 VIM 插件</a></li><li><a href="https://hiberabyss.github.io/2018/04/13/vim-file-jumper/">Vim 文件快速跳转插件</a></li><li><a href="https://hiberabyss.github.io/2018/03/21/vim-plug-introduction/">VIM 插件管理工具 vim-plug 简明教程</a></li><li><a href="https://hiberabyss.github.io/2018/02/28/vim-project-configuration/">「VIM」基于项目的 VIM 配置</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些 Vim 插件可能因为计算密集或者是访问网络资源导致命令调用特别慢, 进而导致 Vim 的操作界面被 hang 住, 时不时地 hang 一下还是很影响流畅度和编码心情的 ):&lt;/p&gt;&lt;p&gt;还好在 neovim/vim8 中添加了对异步调用的支持, 我们可以利用 job 机制让耗时的操作在后台执行, 然后通过 callback 机制把处理结束后的结果输出. 加上异步操作后, 各种操作都如丝般润滑, 再也不用担心卡顿了 (:&lt;/p&gt;&lt;p&gt;下面我就以插件 &lt;a href=&quot;https://github.com/ianva/vim-youdao-translater&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;vim-youdao-translater&lt;/a&gt; 为例来介绍如何给插件添加上异步调用的功能.&lt;/p&gt;
    
    </summary>
    
      <category term="Vim" scheme="https://hiberabyss.github.io/categories/vim/"/>
    
    
      <category term="Vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>实现类 Postman 功能的 VIM 插件</title>
    <link href="https://hiberabyss.github.io/2018/04/24/vim-plug-rest-console/"/>
    <id>https://hiberabyss.github.io/2018/04/24/vim-plug-rest-console/</id>
    <published>2018-04-24T18:09:10.000Z</published>
    <updated>2021-02-10T07:01:06.372Z</updated>
    
    <content type="html"><![CDATA[<p>在实现 Web Server API 的时候, 经常需要发送指定的 http 请求来验证对应的返回是否符合预期. 我们可以通过 Postman 来实现这个功能, 但这就需要在编辑器和 Postman 这两个软件之间来回的切换, 当修改代码的频次比较高时来回的界面切换还是比较影响效率的.</p><p>作为资深 Vim 党, 就在想能不能直接在 Vim 里面就实现类似 Postman 的功能: 发送请求, 然后在一个新的 Vim 窗口里显示返回结果.</p><p>还真找到了一个实现了这个功能的插件 <a href="https://github.com/diepm/vim-rest-console" rel="external nofollow noopener noreferrer" target="_blank">vim-rest-console</a>, 通过这个插件, 我们可以在一个 Vim 窗口里编辑 http 请求, 按 <code>&lt;Ctrl-j&gt;</code> 之后就可以在另外一个 split 的窗口中显示 http 请求的返回结果. 效果如下图所示:</p><p><img src="vim-rest-console.gif" alt></p><p>这个插件是通过 curl 发送 http 请求, 然后把命令的输出放在了一个 split 的 Vim window 里面.</p><a id="more"></a><h1 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h1><p>可以通过 vim-plug 进行安装, 在 <code>.vimrc</code> 文件中添加下面这行, 然后执行 <code>:PlugInstall vim-rest-console</code>:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/diepm/vim-rest-console'</span></span><br></pre></td></tr></table></figure><p>插件的使用也很简单:</p><ul><li>首先需要在文件类型为 <code>rest</code> 的窗口里编辑 http 请求; 可以通过编辑 <code>.rest</code> 结尾的文件或者是通过 <code>set ft=rest</code> 来实现;</li><li>然后把光标放在对应的 http 请求块中, 按 <code>&lt;Ctrl-j&gt;</code> 就会发送对应的请求并在一个新的窗口中显示求情对应的返回结果;</li></ul><p>这里就需要解释下什么是请求块, 以及一个请求块包含了哪些内容.</p><h1 id="http-请求块"><a href="#http-请求块" class="headerlink" title="http 请求块"></a>http 请求块</h1><p>一个 http 请求块有两种起始标志:</p><ol><li>以 http 或 https 开头的 host 名;</li><li><code>--</code> 标志行; 这个和 <code>全局变量定义</code> 功能有关, 后面会有更详细的介绍;</li></ol><p>而 http 请求块的结束标志是下一个 http 请求块的起始标志或者是文件的结束行.</p><p>还是举一个实际的例子更容易理解一些. 例如在下面的代码中就定义了两个请求块:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># http request block1</span><br><span class="line">http://localhost:9200</span><br><span class="line">GET /_cat/nodes?v</span><br><span class="line"></span><br><span class="line"># http request block2</span><br><span class="line">http://localhost:9200</span><br><span class="line"></span><br><span class="line">POST /testindex/testtype</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;some name&quot;,</span><br><span class="line">    &quot;value&quot;: &quot;some value&quot;,</span><br><span class="line">    &quot;date&quot;: &quot;2015-01-01&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中以 <code>#</code> 开始的行表示是注释信息, 也可以通过 <code>//</code> 来对行进行注释.</p><h2 id="http-请求块的组成"><a href="#http-请求块的组成" class="headerlink" title="http 请求块的组成"></a>http 请求块的组成</h2><p>在确定了一个 http 请求块的范围之后, 我们可以接着了解下一个请求块内部是有那几部分组成的:</p><ul><li>请求的 host ; (也可以没有 host , 但需要在块的开始加上 <code>--</code> 行, 表示使用全局定义的 host)</li><li>可选的 cUrl 选项; 如 <code>-i</code> 等;</li><li>可选的 Header 等; 如 <code>Connection: keep-alive</code> 等;</li><li>请求操作及对应的 endpoint ;</li><li>可选的请求数据;</li></ul><p>下面是一个包含了所有部分的示例 http 请求块:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># POSTing to an ElasticSearch service.</span><br><span class="line">http://example.com/elasticsearch</span><br><span class="line"></span><br><span class="line">-i</span><br><span class="line"></span><br><span class="line">// Specify optional headers.</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line"></span><br><span class="line">POST /index/type?pretty</span><br><span class="line">&#123;</span><br><span class="line">    &quot;key&quot;: &quot;a key&quot;,</span><br><span class="line">    &quot;value&quot;: &quot;a value&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同一个 http 请求块中可以添加多个 endpoint 请求, 他们会被按顺序依次执行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://localhost:1208</span><br><span class="line">POST /set_score</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;hbliu&quot;,</span><br><span class="line">    &quot;score&quot;: &quot;99&quot;</span><br><span class="line">&#125;</span><br><span class="line">GET /get_score?name=hbliu</span><br></pre></td></tr></table></figure><p>当我们运行上面的请求块时, 就就会先设置 score 值, 紧接着就会去查询对应的 score 是否被成功更新. 两个请求的结果会被同时放在一个 window 里.</p><h1 id="全局变量定义"><a href="#全局变量定义" class="headerlink" title="全局变量定义"></a>全局变量定义</h1><p>我们可以定义一些全局的值, 包括 curl option, Header 以及一些变量等, 他们必须要在 host 之后定义. 全局变量定义的范围是从文件第一行到第一个 <code>--</code> 行. 还是先举一个例子吧:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// global definition</span><br><span class="line">http://localhost:1208</span><br><span class="line"></span><br><span class="line">-i</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line"></span><br><span class="line">name = hbliu</span><br><span class="line">--</span><br><span class="line"></span><br><span class="line">GET /get_score?name=:name</span><br></pre></td></tr></table></figure><p>在上面的例子里我们在全局变量定义区:</p><ul><li>定义了一个全局的 host ; 当后面的请求块中没有定义 host 时就会使用这个全局 host 发送请求;</li><li>定义了 curl option 和 Header , 这部分内容会和后面请求块中对应的内容进行合并;</li><li>定义了变量, 在后面的请求快中可以通过 <code>:key</code> 的方式来应用这个变量; 在上面的例子中, <code>:name</code> 最后会被替换成 <code>hbliu</code>.</li></ul><p>到现在 vim-rest-console 的主要功能基本都介绍完了, 你可以在 <a href="https://github.com/diepm/vim-rest-console/blob/master/doc/vim-rest-console.txt" rel="external nofollow noopener noreferrer" target="_blank">这里</a> 查看更详细的文档, 或者查看 <a href="https://raw.githubusercontent.com/diepm/vim-rest-console/master/sample.rest" rel="external nofollow noopener noreferrer" target="_blank">示例</a>.</p><p>我自己在使用这个插件的过程中感觉有一些地方不是很方便, 于是做了一些改进.</p><h1 id="一些改进"><a href="#一些改进" class="headerlink" title="一些改进"></a>一些改进</h1><p>主要包括以下几个改进:</p><ul><li>增加了 <code>gx</code> map , 可以在浏览器中打开对应的 http 请求, 主要是对 <code>GET</code> 类型的请求比较有用;</li><li>在执行一个请求块时, 只连续执行光标下的所有非空行的请求; 这样就可以在一个请求块里共用同一个 host 名, 单独发送不同的请求;</li><li>过滤掉返回结果中加上 <code>-i</code> 选项后 curl 命令的 Header 输出;</li><li>删除了返回结果中为空行的第一行;</li><li>自动根据返回结果中的 Header 设置输出窗口的文件类型.</li></ul><p>改进后的插件可以通过下面的方法进行安装:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/hiberabyss/vim-rest-console'</span></span><br></pre></td></tr></table></figure><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2020/05/06/vim-open-saz-file/">使用 Vim 查看 Fiddler 生成的 saz 格式 session 包</a></li><li><a href="https://hiberabyss.github.io/2018/05/03/add-async-support-for-vim-plugin/">给 Vim 插件添加上异步调用的功能</a></li><li><a href="https://hiberabyss.github.io/2018/04/13/vim-file-jumper/">Vim 文件快速跳转插件</a></li><li><a href="https://hiberabyss.github.io/2018/03/21/vim-plug-introduction/">VIM 插件管理工具 vim-plug 简明教程</a></li><li><a href="https://hiberabyss.github.io/2018/02/28/vim-project-configuration/">「VIM」基于项目的 VIM 配置</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实现 Web Server API 的时候, 经常需要发送指定的 http 请求来验证对应的返回是否符合预期. 我们可以通过 Postman 来实现这个功能, 但这就需要在编辑器和 Postman 这两个软件之间来回的切换, 当修改代码的频次比较高时来回的界面切换还是比较影响效率的.&lt;/p&gt;&lt;p&gt;作为资深 Vim 党, 就在想能不能直接在 Vim 里面就实现类似 Postman 的功能: 发送请求, 然后在一个新的 Vim 窗口里显示返回结果.&lt;/p&gt;&lt;p&gt;还真找到了一个实现了这个功能的插件 &lt;a href=&quot;https://github.com/diepm/vim-rest-console&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;vim-rest-console&lt;/a&gt;, 通过这个插件, 我们可以在一个 Vim 窗口里编辑 http 请求, 按 &lt;code&gt;&amp;lt;Ctrl-j&amp;gt;&lt;/code&gt; 之后就可以在另外一个 split 的窗口中显示 http 请求的返回结果. 效果如下图所示:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;vim-rest-console.gif&quot; alt&gt;&lt;/p&gt;&lt;p&gt;这个插件是通过 curl 发送 http 请求, 然后把命令的输出放在了一个 split 的 Vim window 里面.&lt;/p&gt;
    
    </summary>
    
      <category term="Vim" scheme="https://hiberabyss.github.io/categories/vim/"/>
    
    
      <category term="Vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Vim 文件快速跳转插件</title>
    <link href="https://hiberabyss.github.io/2018/04/13/vim-file-jumper/"/>
    <id>https://hiberabyss.github.io/2018/04/13/vim-file-jumper/</id>
    <published>2018-04-13T15:51:22.000Z</published>
    <updated>2021-02-10T07:01:06.372Z</updated>
    
    <content type="html"><![CDATA[<p>日常使用 VIM 的时候经常有跳转到特定目录下某个文件的需求:</p><ul><li>使用 vimwiki 记笔记时会默认把所有笔记保存在目录 <code>~/vimwiki</code> 下, 当我们想查看某个笔记时就打开那个目录下的某个文件;</li><li>我平时会写一些 shell 工具, 保存在 <code>~/bin</code> 目录下, 就会有在这个目录下创建或者打开文件的需求;</li><li>如果你用 ultisnip 之类的插件的话, 就需要经常编辑不同类型文件对应的 snippets 文件;</li><li>…</li></ul><p>根据我个人的使用经验, <code>在特定目录下打开某个文件</code> 的需求还是很多的, 于是便写了插件 <a href="https://github.com/hiberabyss/filejumper" rel="external nofollow noopener noreferrer" target="_blank">FileJumper</a> 来实现这个需求.</p><p>这个插件提供了下面这些功能:</p><ul><li>通过一行配置能快速定义和某个目录绑定的 <code>command</code>;</li><li>通过执行 <code>command filename</code> 能快速打开对应目录下的某个文件, 能通过 <code>tab</code> 键补全文件名;</li><li>能通过指定不同的 vim 命令以不同的模式打开文件, 如 <code>command filename vnew</code> 等;</li></ul><p>下面就会介绍如何安装, 配置已经使用这个插件.</p><a id="more"></a><h1 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h1><p>可以通过 vim-plug 进行安装:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/hiberabyss/FileJumper'</span></span><br></pre></td></tr></table></figure><p>安装完成后通过配置变量 <code>g:file_jumper_command</code> 来定义不同的 command, 下面是插件默认的配置:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:file_jumper_command</span> = &#123;</span><br><span class="line">            \ <span class="string">"Gbin"</span>: &#123;<span class="string">'dir'</span>: <span class="built_in">expand</span>(<span class="string">"$HOME/bin"</span>), <span class="string">'extension'</span>: <span class="string">''</span>&#125;,</span><br><span class="line">            \ <span class="string">"Gwiki"</span>: &#123;<span class="string">'dir'</span>: <span class="variable">g:myvimwikidir</span>, <span class="string">'extension'</span>: <span class="string">'.wiki'</span>, <span class="string">'keymap'</span>: <span class="string">'&lt;Leader&gt;wg'</span>&#125;,</span><br><span class="line">            \ &#125;</span><br></pre></td></tr></table></figure><ul><li><code>Gbin</code> 之类的是命令名;</li><li><code>dir</code> 表示和这个命令绑定的目录;</li><li><code>extension</code> 表示对应目录下的文件的默认后缀名, 在打开文件时会被自动添加上去;</li><li><code>keymap</code> 表示给这个命令映射一个快捷键;</li></ul><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>执行 <code>Gbin pyserver</code> 就会默认通过 <code>tabnew ~/bin/pyserver</code> 来打开对应的文件:</p><p><img src="vim_file_jumper.gif" alt></p><p>在上面的演示中, 我们只输入了 <code>py</code> 然后按 <code>tab</code> 键就可以自动补全文件名 <code>pyserver</code>.</p><p>我们也可以通过添加 vim 命令来决定文件的打开方式:</p><p><img src="vim_file_jumper1.gif" alt></p><p>从上面的演示中可以看出在使用了 <code>vnew</code> 或者 <code>e</code> 之后, vim 打开文件的方式会和默认的不一样. 我们也可以使用 <code>bot vnew</code> 之类的复合命令.</p><p>希望你能喜欢这个插件, 如果遇到什么问题或者有什么建议, 欢迎 Comment 或者再 github 上提交 issue.</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2020/05/06/vim-open-saz-file/">使用 Vim 查看 Fiddler 生成的 saz 格式 session 包</a></li><li><a href="https://hiberabyss.github.io/2018/05/03/add-async-support-for-vim-plugin/">给 Vim 插件添加上异步调用的功能</a></li><li><a href="https://hiberabyss.github.io/2018/04/24/vim-plug-rest-console/">实现类 Postman 功能的 VIM 插件</a></li><li><a href="https://hiberabyss.github.io/2018/03/21/vim-plug-introduction/">VIM 插件管理工具 vim-plug 简明教程</a></li><li><a href="https://hiberabyss.github.io/2018/02/28/vim-project-configuration/">「VIM」基于项目的 VIM 配置</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日常使用 VIM 的时候经常有跳转到特定目录下某个文件的需求:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;使用 vimwiki 记笔记时会默认把所有笔记保存在目录 &lt;code&gt;~/vimwiki&lt;/code&gt; 下, 当我们想查看某个笔记时就打开那个目录下的某个文件;&lt;/li&gt;&lt;li&gt;我平时会写一些 shell 工具, 保存在 &lt;code&gt;~/bin&lt;/code&gt; 目录下, 就会有在这个目录下创建或者打开文件的需求;&lt;/li&gt;&lt;li&gt;如果你用 ultisnip 之类的插件的话, 就需要经常编辑不同类型文件对应的 snippets 文件;&lt;/li&gt;&lt;li&gt;…&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;根据我个人的使用经验, &lt;code&gt;在特定目录下打开某个文件&lt;/code&gt; 的需求还是很多的, 于是便写了插件 &lt;a href=&quot;https://github.com/hiberabyss/filejumper&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;FileJumper&lt;/a&gt; 来实现这个需求.&lt;/p&gt;&lt;p&gt;这个插件提供了下面这些功能:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;通过一行配置能快速定义和某个目录绑定的 &lt;code&gt;command&lt;/code&gt;;&lt;/li&gt;&lt;li&gt;通过执行 &lt;code&gt;command filename&lt;/code&gt; 能快速打开对应目录下的某个文件, 能通过 &lt;code&gt;tab&lt;/code&gt; 键补全文件名;&lt;/li&gt;&lt;li&gt;能通过指定不同的 vim 命令以不同的模式打开文件, 如 &lt;code&gt;command filename vnew&lt;/code&gt; 等;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下面就会介绍如何安装, 配置已经使用这个插件.&lt;/p&gt;
    
    </summary>
    
      <category term="Vim" scheme="https://hiberabyss.github.io/categories/vim/"/>
    
    
      <category term="Vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>关于栈内存分布的一道有趣的面试题</title>
    <link href="https://hiberabyss.github.io/2018/04/11/stack-memory/"/>
    <id>https://hiberabyss.github.io/2018/04/11/stack-memory/</id>
    <published>2018-04-11T17:02:51.000Z</published>
    <updated>2021-02-10T07:01:06.360Z</updated>
    
    <content type="html"><![CDATA[<p>偶然间看到了下面一道面试题:</p><blockquote><p>对于下面的代码, 实现函数 hijack</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hijack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x = %d\n"</span>, x);</span><br><span class="line">    hijack();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x = %d\n"</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使得输出结果为:</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = 100</span><br><span class="line">x = 150</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>在 hijack 函数为空的情况下, 上面函数两次输出值肯定都是 100. 这道题的难点就在于如何在没有传入 x 地址的情况下, 在 hijack 函数中修改 x 的值.</p><p>要修改 x 的值就必须知道它的地址, 那除了参数传递之外, 还有没有别的途径来获取调用函数的局部变量呢? 简单分析下就可以发现是可以做到的:</p><ul><li>函数的局部变量都是存储在栈上的;</li><li>栈上存储空间的变化是有规律的;</li><li>我们可以在被调用函数声明一个局部变量 y, 再计算出 y 和 x 之间的距离, 这样就可以得到 x 的地址!</li></ul><p>上面这个方法需要我们分析在函数调用时, 栈空间是如何分配的.</p><h1 id="栈内存是如何分配的"><a href="#栈内存是如何分配的" class="headerlink" title="栈内存是如何分配的"></a>栈内存是如何分配的</h1><p>在函数调用时, 栈内存是按下面的布局进行分配的:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 地址从高到低</span><br><span class="line"></span><br><span class="line">[caller0_eip, caller0_ebp] --&gt; local variables ... --&gt; argN, ... arg1 --&gt; [caller1_eip, caller1_ebp]</span><br></pre></td></tr></table></figure><p>其中 caller_eip 存储的是调用函数的返回地址; caller_ebp 存储的是调用函数的栈基址 <code>caller1_ebp = &amp;caller0_ebp</code>. 在 64 位系统中 caller_eip 和 caller_ebp 都是 8 个字节大小, <code>int</code> 类型变量是 4 个字节.</p><p>同时 sp 和 ebp 中的地址按 16 字节对齐的, 也就是地址的最后四位必须都为 0 , 如果地址不满足这个条件, 就会额外补充一些空间.</p><p>好了, 我们先在 hijack 函数里定义局部变量变量 y :</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hijack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们来分析下栈内存的布局:</p><p><img src="stack_memory.jpg" alt></p><p>在为 x 和 y 分配内存时, sp 寄存器因为是按 16 字节对齐的, 所以会多了 12 个字节的填充内容.</p><p>从图中可以看出 x 和 y 之间的距离是 <code>&amp;x - &amp;y = 12 + 8 + 8 + 8 + 4 = 32</code> 个字节.</p><p>其实我们也可以通过直接打印出 x , y 的地址来计算它们之间的距离:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;y = %p\n"</span>, &amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&amp;x = %p\n"</span>, x, &amp;x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Result is:</span></span><br><span class="line"><span class="comment">// &amp;x = 0x7ffee7cd6e1c</span></span><br><span class="line"><span class="comment">// &amp;y = 0x7ffee7cd6dfc</span></span><br></pre></td></tr></table></figure><p>计算出距离后我们就可以写代码实现了 :)</p><h1 id="具体的代码实现"><a href="#具体的代码实现" class="headerlink" title="具体的代码实现"></a>具体的代码实现</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hijack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    *(&amp;y + <span class="number">32</span>/<span class="keyword">sizeof</span>(<span class="keyword">int</span>)) = <span class="number">150</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x = %d\n"</span>, x);</span><br><span class="line">    hijack();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x = %d\n"</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果为:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x = 100</span><br><span class="line">x = 150</span><br></pre></td></tr></table></figure><p>这段代码还要注意下面两点:</p><ul><li>栈是从高地址往低地址增长的, y 的地址需要 + delta 来找到 x 的地址;</li><li>C 语言中 <code>(int *) + 1</code> 相当于是往前移动了 <code>sizeof(int)</code> 个字节, 而我们之前得到的距离是按字节来计算的, 因此需要 <code>32/sizeof(int)</code>;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;偶然间看到了下面一道面试题:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;对于下面的代码, 实现函数 hijack&lt;/p&gt;&lt;/blockquote&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hijack&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;x = %d\n&quot;&lt;/span&gt;, x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    hijack();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;x = %d\n&quot;&lt;/span&gt;, x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;使得输出结果为:&lt;/p&gt;&lt;/blockquote&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;x = 100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x = 150&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Interview" scheme="https://hiberabyss.github.io/categories/interview/"/>
    
    
      <category term="memory" scheme="https://hiberabyss.github.io/tags/memory/"/>
    
  </entry>
  
  <entry>
    <title>如何部署多节点 Tendermint 集群</title>
    <link href="https://hiberabyss.github.io/2018/04/11/deploy-multiple-tendermint-nodes/"/>
    <id>https://hiberabyss.github.io/2018/04/11/deploy-multiple-tendermint-nodes/</id>
    <published>2018-04-11T10:47:28.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>这几天在忙着搭建多节点的 TenderMint 节点, 中间遇到了一些坑, 会通过这篇博客记录下整个过程. 欢迎感兴趣的同学多多交流!</p><a id="more"></a><h1 id="基于-docker-compose-搭建"><a href="#基于-docker-compose-搭建" class="headerlink" title="基于 docker-compose 搭建"></a>基于 docker-compose 搭建</h1><p>本来是想直接在本机启动多个 <code>tendermint node</code> 节点来实现的, 后来觉得每个 node 都得设置不同的主目录, 会有点麻烦, 关键是还不能很方便地在别的环境运行.</p><p>这种搭建多节点的任务还是通过 docker 比较方便, 而且也有官方的 docker image <code>tendermint/tendermint</code>. 我们可以通过 docker-compose 来启动多个 container.</p><p>通过<a href="http://tendermint.readthedocs.io/en/master/deploy-testnets.html" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a>我们知道启动 tendermint 集群需要下面几个步骤:</p><ul><li>每个 node 都需要通过 <code>tendermint init</code> 来进行初始化;</li><li>需要有一个包含所有 validator 节点 public key 的 <code>genesis.json</code> 文件, 然后用这个文件覆盖所有节点对应的文件; 在我们的示例中所有的节点都是 validator 节点;</li><li>通过 <code>tendermint show_node_id</code> 获取节点的 ID, 并通过参数 <code>--p2p.persistent_peers=ID1@node1:46656,ID2@node2:46656</code> 来传入种子 peer;</li></ul><p>这里想吐槽下官方文档和最新的代码不一致, 上面的最后一点中的 ID 在文档中没有提及, 但在最新版本的 tendermint 中, 这个 ID 又是必须的. 后来在 github 上提交了 issue 才知道怎么去获取这个 ID.</p><p>对应于上面环境准备需要做的工作, 我通过脚本文件 <code>./init_data.sh</code> 做了自动化的处理:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --rm -v `<span class="built_in">pwd</span>`/node1_data:/tendermint tendermint/tendermint init</span><br><span class="line">docker run --rm -v `<span class="built_in">pwd</span>`/node2_data:/tendermint tendermint/tendermint init</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Node1 ID: <span class="variable">$(docker run --rm -v `pwd`/node1_data:/tendermint tendermint/tendermint show_node_id)</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Node2 ID: <span class="variable">$(docker run --rm -v `pwd`/node2_data:/tendermint tendermint/tendermint show_node_id)</span>"</span></span><br><span class="line"></span><br><span class="line">cat node2_data/config/genesis.json | jq <span class="string">".validators |= .+ <span class="variable">$(cat node1_data/config/genesis.json | jq '.validators')</span>"</span> &gt; final_genesis.json</span><br><span class="line"></span><br><span class="line">cp ./final_genesis.json ./node2_data/config/genesis.json</span><br><span class="line">cp ./final_genesis.json ./node1_data/config/genesis.json</span><br></pre></td></tr></table></figure><p>其中打印出来的节点 ID 会在后面的 <code>docker-compose.yml</code> 文件中用到.</p><p>然后我们就可以通过 <code>docker-compose.yml</code> 启动多个 container 了, 这里我们启动两个节点:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2.0'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tm_node1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">hbliu/tendermint</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">tm_node1</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">tm_node1</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'46667:46657'</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./node1_data:/tendermint</span></span><br><span class="line">    <span class="attr">entrypoint:</span> <span class="string">["bash",</span> <span class="string">"-c"</span><span class="string">,</span> <span class="string">"tendermint node --p2p.persistent_peers=d902b83f46131a80a82df2198a704889c5833284@tm_node2:46656 --moniker=`hostname` --proxy_app=kvstore --consensus.create_empty_blocks=false"</span><span class="string">]</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">tm_node2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">tendermint/tendermint</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">tm_node2</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">tm_node2</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NODE2_ID=5fc11b1d4ab4274476a2243e321e0daa47a36f3a</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'46668:46657'</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./node2_data:/tendermint</span></span><br><span class="line">    <span class="attr">entrypoint:</span> <span class="string">["bash",</span> <span class="string">"-c"</span><span class="string">,</span> <span class="string">"tendermint node --p2p.persistent_peers=59ef92d5c6a408a59e4a1d599a8aff0d4ef37785@tm_node1:46656 --moniker=`hostname` --proxy_app=kvstore --consensus.create_empty_blocks=false"</span><span class="string">]</span></span><br></pre></td></tr></table></figure><p>接下来我们就可以通过下面的步骤来启动有两个节点的 tendermint 集群:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./init_data.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用上面脚本的输出的节点 ID 分别去替换 docker-compose.yml 文件中的节点 ID</span></span><br><span class="line"></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>成功启动之后我们可以通过 <code>curl -s localhost:46667/net_info</code> 中的结果来判断两个节点有没有相互识别.</p><p>具体的代码放在了 <a href="https://github.com/hiberabyss/tendermint-deploy/tree/master/docker-compose-local" rel="external nofollow noopener noreferrer" target="_blank">Github</a>.</p><h1 id="通过-Kubernetes-来部署"><a href="#通过-Kubernetes-来部署" class="headerlink" title="通过 Kubernetes 来部署"></a>通过 Kubernetes 来部署</h1><p>上面基于 docker-compose 的方法一般只能在单机运行, 只适合用来做一些简单验证或搭建开发环境. 通过 Kubernetes 部署的话我们就能很方便地实现集群的部署及扩容.</p><p>部署一个 tendermint 节点大致需要下面三部分工作:</p><ul><li>初始化工作;</li><li>通过 <code>abci-cli</code> 启动应用进程;</li><li>启动 <code>tendermint node</code> 进程;</li></ul><p>对应于这三部分工作我们用一个 pod 里的三个 container 来实现:</p><ul><li><code>initContainers</code> 用来实现初始化相关的工作;</li><li>运行 <code>abci-cli</code> 的容器 <code>tm</code>;</li><li>运行 <code>tendermint node</code> 进程的容器 <code>app</code></li></ul><p>其中 <code>tm</code> 容器因为还需要给其他节点提供 ID 和 public key 信息, 所以我们还在其中启动了一个 http server, 它提供了两个接口:</p><ul><li><code>host:port/node_id</code> 输出当前 tendermint node 的 ID;</li><li><code>host:port/pub_key</code> 输出当前 tendermint node 的 public key;</li></ul><p><a href="https://github.com/hiberabyss/tendermint-deploy/blob/master/docker/tmnode_server.go" rel="external nofollow noopener noreferrer" target="_blank">这里</a> 是这个 http server 的代码.</p><p>我把这个 http server 加入到官方的 image 里制作了一个新的 image <code>hbliu/tendermint</code>:</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> tendermint/tendermint:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./tmnode_server /usr/bin/</span></span><br></pre></td></tr></table></figure><p>接着我们就可以在文件 <code>app.yaml</code> 中实现对应的 service, statefulset 了. 相关的代买也都放在了 <a href="https://github.com/hiberabyss/tendermint-deploy/tree/master/k8s" rel="external nofollow noopener noreferrer" target="_blank">Github</a>.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="http://tendermint.readthedocs.io/en/master/deploy-testnets.html" rel="external nofollow noopener noreferrer" target="_blank">Deploy a Testnet</a></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/04/02/tendermint-introduction-1/">区块链框架 Tendermint 入门教程</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天在忙着搭建多节点的 TenderMint 节点, 中间遇到了一些坑, 会通过这篇博客记录下整个过程. 欢迎感兴趣的同学多多交流!&lt;/p&gt;
    
    </summary>
    
      <category term="Blockchain" scheme="https://hiberabyss.github.io/categories/blockchain/"/>
    
    
      <category term="Tendermint" scheme="https://hiberabyss.github.io/tags/tendermint/"/>
    
  </entry>
  
  <entry>
    <title>Bash 里的文件描述符</title>
    <link href="https://hiberabyss.github.io/2018/04/05/shell-file-description/"/>
    <id>https://hiberabyss.github.io/2018/04/05/shell-file-description/</id>
    <published>2018-04-05T17:19:03.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>在 Shell 编程里经常会用到重定向操作, 它本质上是对文件描述符进行操作, 本文会对 Shell 脚本里的文件描述符做一个详细的介绍.</p><a id="more"></a><h1 id="默认标准文件描述符"><a href="#默认标准文件描述符" class="headerlink" title="默认标准文件描述符"></a>默认标准文件描述符</h1><p>每个进程启动时默认都会有三个标准的文件描述符:</p><ul><li><code>stdin</code> 0 号描述符, 代表输入设备, 进程从它读入数据;</li><li><code>stdout</code> 1 号描述符, 进程往其中写入数据;</li><li><code>stderr</code> 2 号描述符, 进程会往其中写入错误信息;</li></ul><p>这三个描述符默认是对应同一个 tty 设备, 这样我们便可以在终端中输入数据和获取进程的输出.</p><p>默认的文件描述符也是可以被替换的, 例如我们可以替换掉 stdout 到一个文件, 这样命令的输出就不是打印到终端, 而是被输出到文件中:</p><p><img src="shell-fd.gif" alt></p><p>在上面的 demo 中, 我们先是通过 <code>exec 1 &gt; /tmp/stdout</code> 把 stdout 指向了文件 <code>/tmp/stdout</code>, 紧接着我们执行了两条命令 <code>ls</code> 和 <code>pwd</code>, 可以看到此时终端已经没有了命令的输出. 当我们通过 <code>exec 1 &gt;&amp;2</code> 恢复 stdout 后, 可以发现文件 <code>/tmp/stdout</code> 里存储了之前命令的输出.</p><p>其中 <code>exec</code> 是一个 bash 内置命令, 不同于在终端中执行命令时会 fork 一个子进程, 通过 <code>exec</code> 执行的命令会直接修改当前的 shell 进程, 可以通过它执行命令来修改当前 shell 的 context.</p><p>如果你想使坏的话可以在别人的 <code>~/.bashrc</code> 里加入 <code>exec 1 &gt; /tmp/stdout</code>, 这样新开的所有的终端窗口里都看不到命令的输出, 要是因此被打概不负责 :) .</p><h1 id="文件描述符的操作"><a href="#文件描述符的操作" class="headerlink" title="文件描述符的操作"></a>文件描述符的操作</h1><p>Shell 中对文件描述符的操作由三部分组成: <code>(Left, Operation, Right)</code>:</p><ul><li>Left 可以是 0-9 的数字, 代表第 n 号文件描述符;<ul><li>Left 还可以为 <code>&amp;</code>, 表示同时操作 <code>stdout</code> 和 <code>stderr</code></li></ul></li><li>Right 可以是文件名或 0-9 的数字, 当 Right 是数字时必须要加上 <code>&amp;</code> 符号, 表示引用第 n 号文件描述符;<ul><li>Right 还可以为 <code>&amp;-</code>, 此时表示关闭 Left 描述符, 例如 <code>2&lt;&amp;-</code> 表示关闭 stderr;</li></ul></li><li>Operation 可以为 <code>&lt;</code> 或 <code>&gt;</code>;<ul><li>为 <code>&lt;</code> 时表示以读模式复制 Right 到 Left, 此时如果没有指定 Left 的话, 则为默认值 0;</li><li>当为 <code>&gt;</code> 表示以写模式复制 Right 到 Left, 此时如果没有指定 Left 的话, 则为默认值 1;</li><li>Operation 和 Left 之间不能有空格;</li><li>当 Right 为文件名时, Operation 和 Right 可以有空格, 否则也不能有空格;</li></ul></li></ul><p>当存在多个文件描述符的操作时, 会按照从左往右的顺序依次执行. 例如通过命令 <code>cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-</code> 就可以交换 stdin 和 stdout.</p><p>我们通过下面的例子来验证上面的文件描述符交换是否生效:</p><ul><li>首先把默认的 stderr 重定向到文件 <code>/tmp/stderr</code> 中, 这样在终端中就不会看到错误输出了;</li><li>当交换完 stderr 和 stdout 后, 我们就可以在 <code>/tmp/stderr</code> 文件中看到命令的正常输出了;</li></ul><p>让我们来开始实验吧:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  test exec 2&gt; /tmp/stderr</span><br><span class="line">➜  test ls</span><br><span class="line">a.txt</span><br><span class="line">➜  test ls 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-</span><br><span class="line">➜  test cat /tmp/stderr</span><br><span class="line">a.txt</span><br></pre></td></tr></table></figure><p>和我们的预期时一致的!</p><h2 id="一些示例"><a href="#一些示例" class="headerlink" title="一些示例"></a>一些示例</h2><ul><li><p>用文件重载 stdin :</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  <span class="built_in">test</span> cat 0&lt; a.txt</span><br><span class="line">hello</span><br><span class="line">➜  <span class="built_in">test</span> cat &lt; a.txt <span class="comment"># same with last command</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure></li><li><p>把 stderr 和 stdout 都过滤掉</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls not_exist 1&gt; /dev/zero 2&gt;&amp;1</span><br><span class="line"><span class="comment"># another way</span></span><br><span class="line">ls not_exist &amp;&gt; /dev/zero</span><br></pre></td></tr></table></figure></li><li><p>处理上一个命令的错误输出:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  blog git:(hexo) ls not_exist 2&gt;&amp;1 | sed <span class="string">'s/not_exist/error/g'</span></span><br><span class="line">ls: error: No such file or directory</span><br><span class="line"><span class="comment"># another way</span></span><br><span class="line">➜  blog git:(hexo) ls not_exist |&amp; sed <span class="string">'s/not_exist/error/g'</span></span><br><span class="line">ls: error: No such file or directory</span><br></pre></td></tr></table></figure></li><li><p>把标准输出转入到错误输出上: <code>echo hello 1&gt;&amp;2</code></p></li></ul><h1 id="Process-Substitution"><a href="#Process-Substitution" class="headerlink" title="Process Substitution"></a><a href="https://www.gnu.org/software/bash/manual/html_node/Process-Substitution.html" rel="external nofollow noopener noreferrer" target="_blank">Process Substitution</a></h1><p>在 bash 中提供了两个特殊的操作, 它们都可以被直接当成文件名使用:</p><ul><li><code>&lt;(cmd)</code> : 可以看作是一个可读文件, <code>cmd</code> 命令的输出是这个文件的内容;</li><li><code>&gt;(cmd)</code> : 可以看作是一个可写文件, <code>cmd</code> 会接受输入并进行处理;</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>利用 <code>&lt;(cmd)</code> 来验证一对公私钥是否匹配:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  blog git:(hexo) diff &lt;(ssh-keygen -y -e -f ~/.ssh/id_rsa) &lt;(ssh-keygen -y -e -f ~/.ssh/id_rsa.pub)</span><br><span class="line">➜  blog git:(hexo)</span><br></pre></td></tr></table></figure><p>利用 <code>&gt;(cmd)</code> 来对错误信息进行处理, 同时保证错 stderr 信息不回变成 stdout:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  blog git:(hexo) ls not_exist 2&gt; &gt;(sed <span class="string">'s/not_exist/keep_error/g'</span>)</span><br><span class="line">ls: keep_error: No such file or directory</span><br><span class="line">➜  blog git:(hexo)</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="http://mixedvolume.blogspot.com/2004/12/file-descriptors-in-bourne-shell.html" rel="external nofollow noopener noreferrer" target="_blank">File Descriptors in Bourne shell</a></li><li><a href="https://www.gnu.org/software/bash/manual/html_node/Process-Substitution.html" rel="external nofollow noopener noreferrer" target="_blank">Process Substitution</a></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/05/16/shell-script-tips/">Shell 脚本里遇到的一些坑</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Shell 编程里经常会用到重定向操作, 它本质上是对文件描述符进行操作, 本文会对 Shell 脚本里的文件描述符做一个详细的介绍.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://hiberabyss.github.io/categories/linux/"/>
    
    
      <category term="Shell" scheme="https://hiberabyss.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>GDB 实现原理介绍</title>
    <link href="https://hiberabyss.github.io/2018/04/04/gdb-internal/"/>
    <id>https://hiberabyss.github.io/2018/04/04/gdb-internal/</id>
    <published>2018-04-04T16:46:08.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>GDB 是调试程序的利器, 它可以在代码中设置断点, 在程序运行过程中修改变量值等. 你是不是也很好奇 GDB 是如何实现这些功能的? 本文会解答你的疑问, 并通过一些简单的代码来模拟其中的实现细节.</p><a id="more"></a><h1 id="ptrace-介绍"><a href="#ptrace-介绍" class="headerlink" title="ptrace 介绍"></a>ptrace 介绍</h1><p>GDB 中的魔法般的操作底层都是通过 ptrace 调用来实现的, 在介绍 GDB 的具体实现细节前, 我们先来好好了解下 ptrace 调用.</p><p>从名字就可以看出 ptrace 系统调用是用于进程跟踪的, 当进程调用了 ptrace 跟踪某个进程之后:</p><ul><li>调用 ptrace 的进程会变成被跟踪进程的父进程;</li><li>被跟踪进程的进程状态被标记为 <code>TASK_TRACED</code>;</li><li>发送给被跟踪子进程的信号 (SIGKILL 除外) 会被转发给父进程, 而子进程会被阻塞;</li><li>父进程收到信号后, 可以对子进程进行检查和修改, 然后让子进程继续执行;</li></ul><p>在 <code>man ptrace</code> 中可以找到 ptrace 的定义原型:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="keyword">pid_t</span> pid, <span class="keyword">void</span> *addr, <span class="keyword">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure><p>其中 <code>request</code> 参数指定了我们要使用 ptrace 的什么功能, 大致可以分为以下几类:</p><ul><li>PTRACE_ATTACH 或 PTRACE_TRACEME 建立进程间的跟踪关系;<ul><li>PTRACE_TRACEME 是被跟踪子进程调用的, 表示让父进程来跟踪自己, 通常是通过 GDB 启动新进程的时候使用;</li><li>PTRACE_ATTACH 是父进程调用 attach 到已经运行的子进程中; 这个命令会有权限的检查, non-root 的进程不能 attach 到 root 进程中;</li></ul></li><li>PTRACE_PEEKTEXT, PTRACE_PEEKDATA, PTRACE_PEEKUSR 等读取子进程内存/寄存器中保留的值;</li><li>PTRACE_POKETEXT, PTRACE_POKEDATA, PTRACE_POKEUSR 等修改被跟踪进程的内存/寄存器;</li><li>PTRACE_CONT，PTRACE_SYSCALL, PTRACE_SINGLESTEP 控制被跟踪进程以何种方式继续运行;<ul><li>PTRACE_SYSCALL 会让被调用进程在每次 进入/退出 系统调用时都触发一次 SIGTRAP; strace 就是通过调用它来实现的, 在每次进入系统调用的时候读取出系统调用参数, 在退出系统调用的时候读取出返回值;</li><li>PTRACE_SINGLESTEP 会在每执行完一条指令后都触发一次 SIGTRAP; GDB 的 nexti, next 命令都是通过它来实现的;</li></ul></li><li>PTRACE_DETACH, PTRACE_KILL 脱离进程间的跟踪关系;<ul><li>当父进程在子进程之前结束时, trace 关系会被自动解除;</li></ul></li></ul><p>参数 pid 表示的是要跟踪进程的 pid, addr 表示要监控的被跟踪子进程的地址.</p><h1 id="GDB-断点的实现原理"><a href="#GDB-断点的实现原理" class="headerlink" title="GDB 断点的实现原理"></a>GDB 断点的实现原理</h1><p>当我们用 GDB 设置断点时, GDB 会把断点处的指令修改成 <code>int 3</code>, 同时把断点信息及修改前的指令保存起来. 当被调试子进程运行到断点处时, 便会执行 <code>int 3</code>命令, 从而产生 SIGTRAP 信号. 由于 GDB 已经用 ptrace 和调试进程建立了跟踪关系, 此时的 SIGTRAP 信号会被发送给 GDB, GDB 通过和已有的断点信息做对比 (通过指令位置) 来判断这次 SIGTRAP 是不是一个断点.</p><p>如果是断点的话, 就回等待用户的输入以做进一步的处理. 如果用户的命令是继续执行的话, GDB 就会先恢复断点处的指令, 然后执行对应的代码.</p><p>可以看到断点的实现中需要 GDB 去修改被跟踪子进程的内存 (代码也是保存在内存中的), 下面就先介绍下如何通过 ptrace 去修改子进程的内存.</p><h2 id="修改子进程内存"><a href="#修改子进程内存" class="headerlink" title="修改子进程内存"></a>修改子进程内存</h2><p>我们通过下面的例子来演示父进程如何修改子进程的内存:</p><ul><li>父进程创建子进程, 并先让子进程 sleep 一段时间以保证父进程能更早运行;</li><li>父进程通过 <code>PTRACE_ATTACH</code> 来和子进程建立跟踪关系;</li><li>父进程修改子进程的内存数据;</li><li>父进程通过调用 <code>PTRACE_CONT</code> 让子进程恢复执行;</li></ul><p>完整的代码如下所示:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOW(call) (&#123; int _ret = (int)(call); printf(<span class="meta-string">"%s -&gt; %d\n"</span>, #call, _ret); <span class="meta-keyword">if</span> (_ret &lt; 0) &#123; perror(NULL); &#125;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> changeme[] = <span class="string">"This is  a test"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> cdata[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int64_t</span> data;</span><br><span class="line">    &#125; u = &#123; <span class="string">"Hijacked"</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (pid) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* child */</span></span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Children Message: %s\n"</span>, changeme);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            perror(<span class="string">"fork"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* parent */</span></span><br><span class="line">            SHOW(ptrace(PTRACE_ATTACH, pid, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            SHOW(ptrace(PTRACE_POKEDATA, pid, changeme, u.data));</span><br><span class="line">            SHOW(ptrace(PTRACE_CONT, pid, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Parent Message: %s\n"</span>, changeme);</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的输出是:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Children Message: Hijacked a test</span><br><span class="line">ptrace(PTRACE_ATTACH, pid, 0, 0) -&gt; 0</span><br><span class="line">ptrace(PTRACE_POKEDATA, pid, changeme, u.data) -&gt; 0</span><br><span class="line">ptrace(PTRACE_CONT, pid, 0, 0) -&gt; 0</span><br><span class="line">Parent Message: This is  a test</span><br></pre></td></tr></table></figure><p>可以看出子进程中的字符串已经被修改了, 而父进程中的字符串依旧保持不变.</p><p>在调用 <code>ptrace(PTRACE_POKEDATA, pid, changeme, u.data)</code> 时, 最后一个参数实际上是按照 <code>int64_t</code> 来处理的.</p><h2 id="模拟-GDB-设置断点"><a href="#模拟-GDB-设置断点" class="headerlink" title="模拟 GDB 设置断点"></a>模拟 GDB 设置断点</h2><p>这部分原理其实很简单, 但代码实现会稍微有些复杂. 等有人有需求时再写吧… To Be Done… :)</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://blog.csdn.net/edonlii/article/details/8717029" rel="external nofollow noopener noreferrer" target="_blank">ptrace运行原理及使用详解</a></li><li><a href="http://www.cnblogs.com/tangr206/articles/3094358.html" rel="external nofollow noopener noreferrer" target="_blank">Ptrace 详解</a></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/03/13/shared-memory/">进程间通信： 共享内存</a></li><li><a href="https://hiberabyss.github.io/2018/02/28/neovim-gdb-integration/">基于 neovim 终端集成 gdb</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GDB 是调试程序的利器, 它可以在代码中设置断点, 在程序运行过程中修改变量值等. 你是不是也很好奇 GDB 是如何实现这些功能的? 本文会解答你的疑问, 并通过一些简单的代码来模拟其中的实现细节.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://hiberabyss.github.io/categories/linux/"/>
    
    
      <category term="Linux" scheme="https://hiberabyss.github.io/tags/linux/"/>
    
      <category term="Gdb" scheme="https://hiberabyss.github.io/tags/gdb/"/>
    
      <category term="ptrace" scheme="https://hiberabyss.github.io/tags/ptrace/"/>
    
  </entry>
  
  <entry>
    <title>区块链框架 Tendermint 入门教程</title>
    <link href="https://hiberabyss.github.io/2018/04/02/tendermint-introduction-1/"/>
    <id>https://hiberabyss.github.io/2018/04/02/tendermint-introduction-1/</id>
    <published>2018-04-02T17:17:52.000Z</published>
    <updated>2021-02-10T07:01:06.364Z</updated>
    
    <content type="html"><![CDATA[<p>Tendermint 是一个模块化的区块链应用框架, 能够实现拜占庭容错 (BFT), 它主要包括两部分:</p><ul><li>Tendermint Core:<ul><li>实现了 p2p 网络; 在节点之间共享区块和交易;</li><li>实现了拜占庭容错的共识算法, 确定了不更改改的交易顺序;</li></ul></li><li>ABCI Interface, 具体的逻辑处理层, 可以基于不同的语言 (Golang, JS) 来实现; 在这一层实现交易的验证处理以及查询等操作.</li></ul><p>这两部分会分别对应两个不同的进程, Core 和 ABCI 建立了三个连接:</p><ul><li>一个用于验证交易的连接, 交易验证通过后会被广播到 mempoll 里;</li><li>一个用于区块的 proposal;</li><li>最后一个连接用于查询应用的状态;</li></ul><a id="more"></a><p>下图是两者的 Workflow:</p><p><img src="abci.png" alt></p><h1 id="基于-Tendermint-的-Key-Value-存储示例"><a href="#基于-Tendermint-的-Key-Value-存储示例" class="headerlink" title="基于 Tendermint 的 Key-Value 存储示例"></a>基于 Tendermint 的 Key-Value 存储示例</h1><p>Tendermint 内置了一个 KV 存储的应用示例, 我们可以跑下这个示例.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>需要先安装好 <code>tendermint</code> 和 <code>abci-cli</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get -u github.com/tendermint/tendermint/cmd/tendermint</span><br><span class="line">go get -u github.com/tendermint/abci</span><br><span class="line">cd $GOPATH/src/github.com/tendermint/abci</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>验证是否安装成功:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  blog git:(hexo) ✗ which tendermint</span><br><span class="line">/Users/hbliu/go/bin/tendermint</span><br><span class="line">➜  blog git:(hexo) ✗ which abci-cli</span><br><span class="line">/Users/hbliu/go/bin/abci-cli</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>初始化节点配置:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tendermint init</span><br></pre></td></tr></table></figure><p>启动 KV 存储应用:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abci-cli kvstore</span><br></pre></td></tr></table></figure><p>启动 Tendermint 节点:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tendermint node --consensus.create_empty_blocks=false</span><br></pre></td></tr></table></figure><p>其中后面的参数是禁止 Tendermint 节点定期产生空的 block.</p><h2 id="创建交易"><a href="#创建交易" class="headerlink" title="创建交易"></a>创建交易</h2><p>在 Tendermint 中创建 key 为 <code>name</code>, value 为 <code>hbliu</code> 的存储:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  blog git:(hexo) ✗ curl -s &apos;localhost:46657/broadcast_tx_commit?tx=&quot;name=hbliu&quot;&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;id&quot;: &quot;&quot;,</span><br><span class="line">  &quot;result&quot;: &#123;</span><br><span class="line">    &quot;check_tx&quot;: &#123;</span><br><span class="line">      &quot;fee&quot;: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;deliver_tx&quot;: &#123;</span><br><span class="line">      &quot;tags&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot;: &quot;YXBwLmNyZWF0b3I=&quot;,</span><br><span class="line">          &quot;value&quot;: &quot;amFl&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot;: &quot;YXBwLmtleQ==&quot;,</span><br><span class="line">          &quot;value&quot;: &quot;bmFtZQ==&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;fee&quot;: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;hash&quot;: &quot;BA0C60A3F391B35DEAE8A7E6E0491E9B2E0BA497&quot;,</span><br><span class="line">    &quot;height&quot;: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的 Response 中的 key 和 value 使用了 base64 进行了编码, 我们可以通过命令 <code>base64</code> 对其进行解码:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  blog git:(hexo) ✗ echo &quot;YXBwLmtleQ==&quot; | base64 -D</span><br><span class="line">app.key</span><br><span class="line">➜  blog git:(hexo) ✗ echo &quot;bmFtZQ==&quot; | base64 -D</span><br><span class="line">name</span><br></pre></td></tr></table></figure><p>查询下我们之前的信息有没有成功写入:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  blog git:(hexo) ✗ curl -s &apos;localhost:46657/abci_query?data=&quot;name&quot;&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;id&quot;: &quot;&quot;,</span><br><span class="line">  &quot;result&quot;: &#123;</span><br><span class="line">    &quot;response&quot;: &#123;</span><br><span class="line">      &quot;log&quot;: &quot;exists&quot;,</span><br><span class="line">      &quot;index&quot;: &quot;-1&quot;,</span><br><span class="line">      &quot;key&quot;: &quot;bmFtZQ==&quot;,</span><br><span class="line">      &quot;value&quot;: &quot;aGJsaXU=&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">➜  blog git:(hexo) ✗ echo &quot;bmFtZQ==&quot; | base64 -D</span><br><span class="line">name</span><br><span class="line">➜  blog git:(hexo) ✗ echo &quot;aGJsaXU=&quot; | base64 -D</span><br><span class="line">hbliu</span><br></pre></td></tr></table></figure><p>在浏览器中打开 <code>http://localhost:46657</code> 可以显示当前所有支持的 API.</p><h1 id="示例代码介绍"><a href="#示例代码介绍" class="headerlink" title="示例代码介绍"></a>示例代码介绍</h1><p>上述示例的代码存储在 <a href="https://github.com/tendermint/abci/blob/master/example/kvstore/kvstore.go" rel="external nofollow noopener noreferrer" target="_blank">Github</a> 上. 下面我们对这部分代码做一个简单的介绍.</p><p>在我们调用 <code>broadcast_tx_commit</code> 的时候, 会先调用 <code>CheckTx</code>, 验证通过后会把 TX 加入到 mempool 里. 在 kvstore 示例中没有对 transaction 做检查, 直接通过:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *KVStoreApplication)</span> <span class="title">CheckTx</span><span class="params">(tx []<span class="keyword">byte</span>)</span> <span class="title">types</span>.<span class="title">ResponseCheckTx</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> types.ResponseCheckTx&#123;Code: code.CodeTypeOK&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放到 mempool 里的 TX 会被定期广播到所有节点. 当 Tendermint 选出了 Proposal 节点后, 它便会从 mempool 里选出一系列的 TXs , 将它们组成一个 Block, 广播给所有的节点. 节点在收到 Block 后, 会对 Block 里的所有 TX 执行 <code>DeliverTX</code> 操作, 同时对 Block 执行 <code>Commit</code> 操作.</p><p>我们调用 <code>broadcast_tx_commit</code> 返回的结果其实就是 <code>DeliverTX</code> 返回的结果:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *KVStoreApplication)</span> <span class="title">DeliverTx</span><span class="params">(tx []<span class="keyword">byte</span>)</span> <span class="title">types</span>.<span class="title">ResponseDeliverTx</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> key, value []<span class="keyword">byte</span></span><br><span class="line">parts := bytes.Split(tx, []<span class="keyword">byte</span>(<span class="string">"="</span>))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(parts) == <span class="number">2</span> &#123;</span><br><span class="line">key, value = parts[<span class="number">0</span>], parts[<span class="number">1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">key, value = tx, tx</span><br><span class="line">&#125;</span><br><span class="line">app.state.db.Set(prefixKey(key), value)</span><br><span class="line">app.state.Size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">tags := []cmn.KVPair&#123;</span><br><span class="line">&#123;[]<span class="keyword">byte</span>(<span class="string">"app.creator"</span>), []<span class="keyword">byte</span>(<span class="string">"jae"</span>)&#125;,</span><br><span class="line">&#123;[]<span class="keyword">byte</span>(<span class="string">"app.key"</span>), key&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> types.ResponseDeliverTx&#123;Code: code.CodeTypeOK, Tags: tags&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出它会从输入参数中解析出 key 和 value, 最后保存在应用的 State 中.</p><p>当所有的 TX 被处理完之后需要调用 <code>Commit</code> 来更新整个区块的状态, 包括高度加 1 等:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *KVStoreApplication)</span> <span class="title">Commit</span><span class="params">()</span> <span class="title">types</span>.<span class="title">ResponseCommit</span></span> &#123;</span><br><span class="line"><span class="comment">// Using a memdb - just return the big endian size of the db</span></span><br><span class="line">appHash := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">binary.PutVarint(appHash, app.state.Size)</span><br><span class="line">app.state.AppHash = appHash</span><br><span class="line">app.state.Height += <span class="number">1</span></span><br><span class="line">saveState(app.state)</span><br><span class="line"><span class="keyword">return</span> types.ResponseCommit&#123;Data: appHash&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="http://tendermint.readthedocs.io/projects/tools/en/develop/introduction.html" rel="external nofollow noopener noreferrer" target="_blank">Tendermint Introduction</a></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/04/11/deploy-multiple-tendermint-nodes/">如何部署多节点 Tendermint 集群</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tendermint 是一个模块化的区块链应用框架, 能够实现拜占庭容错 (BFT), 它主要包括两部分:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Tendermint Core:&lt;ul&gt;&lt;li&gt;实现了 p2p 网络; 在节点之间共享区块和交易;&lt;/li&gt;&lt;li&gt;实现了拜占庭容错的共识算法, 确定了不更改改的交易顺序;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;ABCI Interface, 具体的逻辑处理层, 可以基于不同的语言 (Golang, JS) 来实现; 在这一层实现交易的验证处理以及查询等操作.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这两部分会分别对应两个不同的进程, Core 和 ABCI 建立了三个连接:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一个用于验证交易的连接, 交易验证通过后会被广播到 mempoll 里;&lt;/li&gt;&lt;li&gt;一个用于区块的 proposal;&lt;/li&gt;&lt;li&gt;最后一个连接用于查询应用的状态;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="blockchain" scheme="https://hiberabyss.github.io/categories/blockchain/"/>
    
    
      <category term="Tendermint" scheme="https://hiberabyss.github.io/tags/tendermint/"/>
    
  </entry>
  
  <entry>
    <title>「Git」底层存储原理详解</title>
    <link href="https://hiberabyss.github.io/2018/03/28/git-internal/"/>
    <id>https://hiberabyss.github.io/2018/03/28/git-internal/</id>
    <published>2018-03-28T10:46:04.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>本文尝试通过一个示例去详细介绍 git 的底层存储的实现原理.</p><a id="more"></a><h1 id="存储原理介绍"><a href="#存储原理介绍" class="headerlink" title="存储原理介绍"></a>存储原理介绍</h1><p>Git 的底层存储从本质上讲是基于本地文件系统实现的 Key-Value 数据库. 这里的 Value 是 git 里的三种不同的对象的内容, 而 Key 则是对象内容的 hash 值.</p><p>Git 把 Key 存储为目录加文件名 (hash 值的前两位为目录名, 剩余部分作为文件名), Value 则被存储为文件内容, 默认使用了 zlib 进行压缩. 把 Key 的一部分存储为目录是为了加快文件的定位, 在查找文件时先找到对应的目录, 再遍历目录中的文件进行查找.</p><h2 id="三种不同对象类型"><a href="#三种不同对象类型" class="headerlink" title="三种不同对象类型"></a>三种不同对象类型</h2><p>Git 中有 commit, tree, blob 三种不同的对象. 其中:</p><ul><li>commit 对象存储 git 中的提交信息;</li><li>tree 对象存储 git 仓库中的文件元数据信息, 包括文件名及目录结构信息等;</li><li>blob 则对应的是 git 仓库中的文件内容;</li></ul><p>三种不同的对象可以借用 go 语言的 struct 来描述他们的结构, 这里我们其实可以把 Key 看作是一种指针:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// commit object</span></span><br><span class="line"><span class="keyword">struct</span> Commit &#123;</span><br><span class="line">   Parent []*Commit</span><br><span class="line">   RootTree *Tree</span><br><span class="line">   Author People</span><br><span class="line">   Committer People</span><br><span class="line">   Message <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> People &#123;</span><br><span class="line">   Name <span class="keyword">string</span></span><br><span class="line">   Email <span class="keyword">string</span></span><br><span class="line">   Timestamp time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tree object</span></span><br><span class="line"><span class="keyword">struct</span> Tree &#123;</span><br><span class="line">   Files []FileMeta</span><br><span class="line">   SubDirs []*Tree</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> FileMeta &#123;</span><br><span class="line">   Name <span class="keyword">string</span></span><br><span class="line">   FileData *Blob</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// blob object</span></span><br><span class="line"><span class="keyword">struct</span> Blob &#123;</span><br><span class="line">   data []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是对 git 底层存储结构的介绍, 还是很简单的, 下面我们以一个例子来详细介绍具体的工作原理.</p><h1 id="示例解析"><a href="#示例解析" class="headerlink" title="示例解析"></a>示例解析</h1><p>创建目录 GitInternal 并执行 <code>git init</code>, 添加文件 a.txt :</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  GitInternal git:(master) ✗ <span class="built_in">echo</span> <span class="string">'file a'</span> &gt; a.txt</span><br></pre></td></tr></table></figure><p>执行 <code>git add a.txt</code>, 这时我们就可以在 <code>.git/objects</code> 中看到下面的目录结构:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  objects git:(master) tree</span><br><span class="line">.</span><br><span class="line">├── 4e</span><br><span class="line">│   └── f30bbfe26431a69c3820d3a683df54d688f2ec</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br></pre></td></tr></table></figure><p>通过 git 的底层命令查看这个新产生的文件:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  objects git:(master) git cat-file -p 4ef30bbfe26431a69c3820d3a683df54d688f2ec</span><br><span class="line">file a</span><br></pre></td></tr></table></figure><p>通过 <code>git commit</code> 新建一个 commit 之后, 我们再查看下 commit 对象的内容:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  GitInternal git:(master) ✗ git commit -m <span class="string">'first commit'</span></span><br><span class="line">[master (root-commit) 0e79428] first commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 a.txt</span><br><span class="line">➜  GitInternal git:(master) git cat-file -p 0e79428</span><br><span class="line">tree 63bbf0e0280e60aec833588c654ced607189db7e</span><br><span class="line">author Hongbo Liu &lt;hbliu@freewheel.tv&gt; 1522355183 -0400</span><br><span class="line">committer Hongbo Liu &lt;hbliu@freewheel.tv&gt; 1522355183 -0400</span><br><span class="line"></span><br><span class="line">first commit</span><br></pre></td></tr></table></figure><p>因为是第一个 commit, 所以没有 parent commit. 这时我们可以查看下 tree 对象的内容:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  GitInternal git:(master) git cat-file -p 63bbf0e0280e60aec833588c654ced607189db7e</span><br><span class="line">100644 blob 4ef30bbfe26431a69c3820d3a683df54d688f2ec    a.txt</span><br></pre></td></tr></table></figure><p>这时我们再查看 <code>.git/objects</code> 目录下的内容, 会发现和上面提到的三个对象是一一对应的:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  objects git:(master) tree</span><br><span class="line">.</span><br><span class="line">├── 0e</span><br><span class="line">│   └── 794285e05b7ca9f51afb77ace3aed310dc12dc</span><br><span class="line">├── 4e</span><br><span class="line">│   └── f30bbfe26431a69c3820d3a683df54d688f2ec</span><br><span class="line">├── 63</span><br><span class="line">│   └── bbf0e0280e60aec833588c654ced607189db7e</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br></pre></td></tr></table></figure><h2 id="pack-文件"><a href="#pack-文件" class="headerlink" title="pack 文件"></a>pack 文件</h2><p>在原始的 git 存储模型中, 我们可以把 commit 看作是仓库在某个时间点的一个快照. 对于每一次修改, 我们都保存的是文件的完整内容, 而不是 diff. 例如当我们修改文件 <code>a.txt</code> 再重新提交之后:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  GitInternal git:(master) <span class="built_in">echo</span> <span class="string">'append'</span> &gt;&gt; a.txt</span><br><span class="line">➜  GitInternal git:(master) ✗ git commit -am <span class="string">'append a.txt'</span></span><br><span class="line">[master 2b5a159] append a.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>我们可以看到修改后的文件是被完整地保存为一个 blob 文件的:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  GitInternal git:(master) git cat-file -p 2b5a159</span><br><span class="line">tree 454e5d08e9d43d159488f9d22664cabb31c25dd1</span><br><span class="line">parent 0e794285e05b7ca9f51afb77ace3aed310dc12dc</span><br><span class="line">author Hongbo Liu &lt;hbliu@freewheel.tv&gt; 1522356108 -0400</span><br><span class="line">committer Hongbo Liu &lt;hbliu@freewheel.tv&gt; 1522356108 -0400</span><br><span class="line"></span><br><span class="line">append a.txt</span><br><span class="line">➜  GitInternal git:(master) git cat-file -p 454e5d08e9d43d159488f9d22664cabb31c25dd1</span><br><span class="line">100644 blob 5d17781b0c79efe46af70749fe6d6bc14bc11854    a.txt</span><br><span class="line">➜  GitInternal git:(master) git cat-file -p 5d17781b0c79efe46af70749fe6d6bc14bc11854</span><br><span class="line">file a</span><br><span class="line">append</span><br></pre></td></tr></table></figure><p>同时原来的对象文件也都存在:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  objects git:(master) tree</span><br><span class="line">.</span><br><span class="line">├── 0e</span><br><span class="line">│   └── 794285e05b7ca9f51afb77ace3aed310dc12dc</span><br><span class="line">├── 2b</span><br><span class="line">│   └── 5a1590b3fb9727000e0265dd8d14d07fad8578</span><br><span class="line">├── 45</span><br><span class="line">│   └── 4e5d08e9d43d159488f9d22664cabb31c25dd1</span><br><span class="line">├── 4e</span><br><span class="line">│   └── f30bbfe26431a69c3820d3a683df54d688f2ec</span><br><span class="line">├── 5d</span><br><span class="line">│   └── 17781b0c79efe46af70749fe6d6bc14bc11854</span><br><span class="line">├── 63</span><br><span class="line">│   └── bbf0e0280e60aec833588c654ced607189db7e</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br><span class="line"></span><br><span class="line">8 directories, 6 files</span><br></pre></td></tr></table></figure><p>如果每修改一次文件都要保存完整的一份, 存储空间利用率会变得很低, git 仓库的大小也会很快增大到不可忍受的地步. 对此, git 的解决方案是定期或者在特定条件下 (例如 push 的时候) 对对象文件进行打包处理.</p><p>打包的时候, git 会查找命名及大小相近的文件, 然后保存最新的文件的完整内容, 历史文件则按照 diff 的方式进行保存.</p><p>我们可以通过 <code>git gc</code> 来手动触发打包过程以观察它的工作机制:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  objects git:(master) git gc</span><br><span class="line">Counting objects: 6, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (6/6), <span class="keyword">done</span>.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">➜  objects git:(master) tree</span><br><span class="line">.</span><br><span class="line">├── info</span><br><span class="line">│   └── packs</span><br><span class="line">└── pack</span><br><span class="line">    ├── pack-37b85c52cfde7fad12039f5befbc7c23973a43e2.idx</span><br><span class="line">    └── pack-37b85c52cfde7fad12039f5befbc7c23973a43e2.pack</span><br></pre></td></tr></table></figure><p>可以看到执行完 <code>git gc</code> 之后, 原来的 blob 文件都不存在了, 但在 pack 目录里生成了两个新的文件. 其中 <code>.pack</code> 后缀文件存储的是打包前对象文件的实际内容, 而 <code>.idx</code> 后缀文件存储的是 各对象文件在 <code>.pack</code> 文件中的 index 值.</p><p>我们可以通过下面的命令来查看 pack 文件中包含的对象文件内容:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  pack git:(master) git verify-pack pack-37b85c52cfde7fad12039f5befbc7c23973a43e2.idx -v</span><br><span class="line">2b5a1590b3fb9727000e0265dd8d14d07fad8578 commit 223 156 12</span><br><span class="line">0e794285e05b7ca9f51afb77ace3aed310dc12dc commit 175 124 168</span><br><span class="line">5d17781b0c79efe46af70749fe6d6bc14bc11854 blob   14 23 292</span><br><span class="line">454e5d08e9d43d159488f9d22664cabb31c25dd1 tree   33 43 315</span><br><span class="line">63bbf0e0280e60aec833588c654ced607189db7e tree   33 44 358</span><br><span class="line">4ef30bbfe26431a69c3820d3a683df54d688f2ec blob   7 16 402</span><br><span class="line">non delta: 6 objects</span><br><span class="line">pack-37b85c52cfde7fad12039f5befbc7c23973a43e2.pack: ok</span><br></pre></td></tr></table></figure><p>其中 <code>git verify-pack -v</code> 命令的输出格式为:</p><ul><li><p>存储原始文件的对象:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHA-1 type size size-in-packfile offset-in-packfile</span><br></pre></td></tr></table></figure></li><li><p>存储增量的对象:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHA-1 type size size-in-packfile offset-in-packfile depth base-SHA-1</span><br></pre></td></tr></table></figure></li></ul><h2 id="包含子目录的示例"><a href="#包含子目录的示例" class="headerlink" title="包含子目录的示例"></a>包含子目录的示例</h2><p>我们在 git 库中添加子目录 <code>b</code>, 并新加一个文件 <code>b.txt</code> :</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  GitInternal git:(master) mkdir b</span><br><span class="line">➜  GitInternal git:(master) <span class="built_in">echo</span> <span class="string">'file b'</span> &gt; b/b.txt</span><br><span class="line">➜  GitInternal git:(master) git add ./b</span><br><span class="line">➜  GitInternal git:(master) ✗ git commit -m <span class="string">'add file b.txt'</span></span><br><span class="line">[master b6651f8] add file b.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 b/b.txt</span><br></pre></td></tr></table></figure><p>我们查看最新的 tree 对象:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  GitInternal git:(master) git cat-file -p b6651f8</span><br><span class="line">tree 261f921efbc41b76638aa70a63b6eca554eddf72</span><br><span class="line">parent 2b5a1590b3fb9727000e0265dd8d14d07fad8578</span><br><span class="line">author Hongbo Liu &lt;hbliu@freewheel.tv&gt; 1522359722 -0400</span><br><span class="line">committer Hongbo Liu &lt;hbliu@freewheel.tv&gt; 1522359722 -0400</span><br><span class="line"></span><br><span class="line">add file b.txt</span><br><span class="line">➜  GitInternal git:(master) git cat-file -p 261f921efbc41b76638aa70a63b6eca554eddf72</span><br><span class="line">100644 blob 5d17781b0c79efe46af70749fe6d6bc14bc11854    a.txt</span><br><span class="line">040000 tree f2996a3c25d2f25ba05bfc4575674774e364e453    b</span><br></pre></td></tr></table></figure><p>可以发现多了一个子 tree 对象, 再查看它的内容:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  GitInternal git:(master) git cat-file -p f2996a3c25d2f25ba05bfc4575674774e364e453</span><br><span class="line">100644 blob 4f2e6529203aa6d44b5af6e3292c837ceda003f9    b.txt</span><br></pre></td></tr></table></figure><p>在 <code>.git/objects</code> 也包含这些对象对应的文件:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── 26</span><br><span class="line">│   └── 1f921efbc41b76638aa70a63b6eca554eddf72</span><br><span class="line">├── 4f</span><br><span class="line">│   └── 2e6529203aa6d44b5af6e3292c837ceda003f9</span><br><span class="line">├── b6</span><br><span class="line">│   └── 651f8c1101960af8192d020c0a23f124cfceca</span><br><span class="line">├── f2</span><br><span class="line">│   └── 996a3c25d2f25ba05bfc4575674774e364e453</span><br><span class="line">├── info</span><br><span class="line">│   └── packs</span><br><span class="line">└── pack</span><br><span class="line">    ├── pack-37b85c52cfde7fad12039f5befbc7c23973a43e2.idx</span><br><span class="line">    └── pack-37b85c52cfde7fad12039f5befbc7c23973a43e2.pack</span><br><span class="line"></span><br><span class="line">6 directories, 7 files</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E5%BA%95%E5%B1%82%E5%91%BD%E4%BB%A4%E5%92%8C%E9%AB%98%E5%B1%82%E5%91%BD%E4%BB%A4" rel="external nofollow noopener noreferrer" target="_blank">GitPro</a></li><li><a href="https://www.bittiger.io/blog/post/ExHBZfCRtGwhoYk5f" rel="external nofollow noopener noreferrer" target="_blank">git内部原理</a></li><li><a href="https://git-scm.com/docs/git-verify-pack" rel="external nofollow noopener noreferrer" target="_blank">git-verify-pack</a></li><li><a href="https://git-scm.com/book/en/v2/Git-Internals-Packfiles" rel="external nofollow noopener noreferrer" target="_blank">Git Internals</a></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/03/03/git-ignore-specific-file/">Git：在 merge 的时候忽略特定的文件</a></li><li><a href="https://hiberabyss.github.io/2017/03/21/git-amend-commits/">Git Tips：修改 commits</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文尝试通过一个示例去详细介绍 git 的底层存储的实现原理.&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://hiberabyss.github.io/categories/git/"/>
    
    
      <category term="Git" scheme="https://hiberabyss.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>「Golang」Slice 详解</title>
    <link href="https://hiberabyss.github.io/2018/03/23/golang-slice-analyze/"/>
    <id>https://hiberabyss.github.io/2018/03/23/golang-slice-analyze/</id>
    <published>2018-03-23T16:21:36.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>slice 是 go 里面最常用到的数据结构了, 但稍有不慎, 就会踩到一些坑. 本文会对 slice 的原理及使用通过代码的方式做一个总结和梳理.</p><a id="more"></a><h1 id="golang-的数组"><a href="#golang-的数组" class="headerlink" title="golang 的数组"></a>golang 的数组</h1><p>slice 本质上是基于数组实现的, 为了更好地理解 slice, 我们先介绍下 golang 里的数组.</p><p>golang 中的数组和 C 语言中的数组特别类似, 都是定长的同类型数据的集合. 我们可以通过 <code>[2]int {12, 8}</code> 来定义一个数组, 也可以通过另外一种形式 <code>[...]int {12, 8}</code> 来让编译器自己算出数组的实际长度.</p><p>数组的长度是不能被改变的, 我们可以通过 <code>len(array)</code> 来获取数组的长度.</p><p>数组其实可以看作一种特殊类型的 struct, 例如对于 <code>[2]int</code> 可以用类似下面的 struct 表示:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> array &#123;</span><br><span class="line">  <span class="keyword">int</span></span><br><span class="line">  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这个结构体, 我们可以通过 index 去访问它的成员值, 如 <code>array[0]</code> 可以访问到第一个元素.</p><p>不同于 C 语言中的数组, golang 中的数组不是指向第一个元素的指针. 当对一个数组进行赋值或者作为参数传递时, 数组会被完全复制一份, 如果把数组理解成一种特殊类型的 struct 的话, 这个行为就很好理解了.</p><h1 id="slice-的本质"><a href="#slice-的本质" class="headerlink" title="slice 的本质"></a>slice 的本质</h1><p>slice 可以看作是由三个元素组成的结构体:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> slice &#123;</span><br><span class="line">  ptr</span><br><span class="line">  <span class="built_in">len</span></span><br><span class="line">  <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>ptr</code> 是指向底层数组的指针, len 表示当前 slice 中元素的数量, cap 表示当前底层数组大小.</p><p>我们用 make 来创建 slice 的时候, 最多可以指定三个参数:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]Type, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><p>其中第三个参数是可选的, 用于指定底层数组的大小, 如果未指定, 则默认是和第二个参数是一致的.</p><p>用 make 创建的指定大小的数组会用类型的 0 值进行初始化, 例如对于下面的代码:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Result:</span></span><br><span class="line"><span class="comment">// [0 0 2 3]</span></span><br></pre></td></tr></table></figure><p>它的输出结果是 <code>[0 0 2 3]</code>, 这是因为用 make 创建 slice 的时候, 里面已经存在了 2 个 0 值元素.</p><p>这里需要指出的一点是对 slice 的赋值操作是 O(1) 的, 它和底层数组的大小没有关系, 因为我们只需要把 (ptr, len, cap) 这三个值拷贝到新的 slice 即可.</p><h2 id="子-slice"><a href="#子-slice" class="headerlink" title="子 slice"></a>子 slice</h2><p>我们可以通过 <code>slice[begin:end:cap_idx]</code> 来获取一个子 slice, 子 slice 的大小是 <code>end - begin</code>, 其中 end 和 cap_idx 最大可以设置为 <code>cap(slice)</code>. 子 slice 相当于是:</p><ul><li>ptr = slice.ptr + begin</li><li>len = end - begin</li><li>cap = cap_idx - begin</li></ul><h2 id="slice-容量的自动扩展"><a href="#slice-容量的自动扩展" class="headerlink" title="slice 容量的自动扩展"></a>slice 容量的自动扩展</h2><p>当我们往 slice 中 append 数据时, 如果 slice 还有容量时, 直接 <code>slice[len] = newValue</code> 即可:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">_ = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">s1 := s[<span class="number">0</span>:<span class="number">2</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">fmt.Println(s1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Result:</span></span><br><span class="line"><span class="comment">// [1 2]</span></span><br></pre></td></tr></table></figure><p>但如果 append 的数据超过当前 slice 的容量时, 便会重新申请一个数组存放要添加的数据. 例如我们往上面例子中的 slice 再添加一个新的数据时, 便会超过之前的容量而去重新申请一个数组. 这样之前数组里的内容便会还是默认值, 输出结果为: <code>[0 0]</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">_ = <span class="built_in">append</span>(s, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">s1 := s[<span class="number">0</span>:<span class="number">2</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">fmt.Println(s1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Result:</span></span><br><span class="line"><span class="comment">// [0 0]</span></span><br></pre></td></tr></table></figure><p>当对之前的 slice 容量进行扩展时, 每次都是两倍于之前的容量, 我们可以通过下面的代码来进行验证:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceIncreaseExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">cCap := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">128</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span>(s) != cCap &#123;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">cCap = <span class="built_in">cap</span>(s)</span><br><span class="line">&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Result:</span></span><br><span class="line"><span class="comment">// 3 3</span></span><br><span class="line"><span class="comment">// 4 6</span></span><br><span class="line"><span class="comment">// 7 12</span></span><br><span class="line"><span class="comment">// 13 24</span></span><br><span class="line"><span class="comment">// 25 48</span></span><br><span class="line"><span class="comment">// 49 96</span></span><br><span class="line"><span class="comment">// 97 192</span></span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://blog.go-zh.org/go-slices-usage-and-internals" rel="external nofollow noopener noreferrer" target="_blank">Go 切片：用法和本质</a></li><li><a href="https://studygolang.com/articles/6557" rel="external nofollow noopener noreferrer" target="_blank">Go语言slice的那些坑</a></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/05/04/request-limit-and-qps-statistics/">用 go 实现简易版的请求限流和流量统计</a></li><li><a href="https://hiberabyss.github.io/2018/03/14/unix-socket-programming/">使用 Go 进行 Socket 编程</a></li><li><a href="https://hiberabyss.github.io/2018/03/12/implement-ping-command-via-golang/">使用 golang 实现 ping 命令</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;slice 是 go 里面最常用到的数据结构了, 但稍有不慎, 就会踩到一些坑. 本文会对 slice 的原理及使用通过代码的方式做一个总结和梳理.&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://hiberabyss.github.io/categories/go/"/>
    
    
      <category term="Go" scheme="https://hiberabyss.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>VIM 插件管理工具 vim-plug 简明教程</title>
    <link href="https://hiberabyss.github.io/2018/03/21/vim-plug-introduction/"/>
    <id>https://hiberabyss.github.io/2018/03/21/vim-plug-introduction/</id>
    <published>2018-03-21T21:58:39.000Z</published>
    <updated>2021-02-10T07:01:06.372Z</updated>
    
    <content type="html"><![CDATA[<p>作为 VIM 的重度患者, 一款好用的插件管理工具显得尤为重要, 毕竟给 VIM 增加新功能, 或者是新增编程语言的支持都需要安装插件. 我个人目前安装了 133 款 VIM 插件.</p><p>我使用的 VIM 插件管理工具也从早起的 Vundle 到 NeoBundle, 再到现在使用的 <a href="https://github.com/junegunn/vim-plug" rel="external nofollow noopener noreferrer" target="_blank">vim-plug</a>.</p><p>选择 vim-plug , 是因为它:</p><ul><li>简洁且快速, 没有外部依赖, 整个插件只有一个文件;</li><li>该有的功能都有:<ul><li>按需加载插件(On-demand loading); 这样可以加快 VIM 启动时间</li><li>Post-update hooks; 可以在插件安装或者更新时执行一些操作, 如 make 等</li></ul></li><li>还提供了更高阶的功能, 使得安装或更新插件都更快速:<ul><li>并行化地安装或者更新插件;</li><li>按照 shallow 的方式 clone 插件库, 下载更迅速</li></ul></li></ul><p>本文是 vim-plug 的一个简明教程, 会介绍它的安装使用, 以及我个人用到的一些 tips.</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>官网是把 vim-plug 安装在 vim 的默认目录 <code>~/.vim</code> 中, 但我个人更喜欢把它放在一个特定的位置, 这样不管是 vim 还是 neovim 都可以正常的加载它.</p><p>下面是 linux/macOS/unix 中直接在 vimrc 中安装 vim-plug 的代码:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> $BUNDLE = <span class="built_in">expand</span>(<span class="string">"$HOME/.dotfiles/data/vimdata/bundle"</span>)</span><br><span class="line"><span class="keyword">let</span> $PLUG_DIR = <span class="built_in">expand</span>(<span class="string">"$BUNDLE/vim-plug"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">empty</span>(<span class="built_in">glob</span>(<span class="built_in">expand</span>(<span class="string">"$PLUG_DIR/plug.vim"</span>)))</span><br><span class="line">  <span class="keyword">silent</span> !curl -fLo $PLUG_DIR/plug.<span class="keyword">vim</span> --create-dirs</span><br><span class="line">    \ http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/junegunn/<span class="keyword">vim</span>-plug/master/plug.<span class="keyword">vim</span></span><br><span class="line">  <span class="keyword">autocmd</span> VimEnter * PlugInstall --<span class="keyword">sync</span> | <span class="keyword">source</span> ~/.vimrc</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">source</span> $PLUG_DIR/plug.<span class="keyword">vim</span></span><br></pre></td></tr></table></figure><p>这段代码的意思是如果 <code>vim-plug.vim</code> 文件不存在, 就自动从 github 上下载最新版本到指定目录并加载.</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>和大部分 vim 插件管理工具一样, vim-plug 需要一个 begin 和 end 函数, 同时在 begin 和 end 中间可以使用 <code>Plug plugin_url</code> 来加载插件, 例如:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> plug#begin(<span class="built_in">expand</span>($BUNDLE))</span><br><span class="line"></span><br><span class="line">Plug <span class="string">'https://github.com/hiberabyss/ProjectConfig'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> plug#end() <span class="comment">" Should run at last</span></span><br></pre></td></tr></table></figure><p>把上面这部分代码放在上一步代码后面, 重新加载 vimrc <code>source ~/.vimrc</code>, 然后我们就可以使用 <code>:PlugInstall ProjectConfig</code> 来安装 ProjectConfig 插件了. 安装完成后, 我们可以通过执行 <code>:ProjectConfig</code> 来检查插件是否成功安装.</p><p>和 <code>:PlugInstall</code> 类似, 我们可以使用 <code>PlugUpdate</code> 来更新插件.</p><h2 id="通过按键来安装或更新插件"><a href="#通过按键来安装或更新插件" class="headerlink" title="通过按键来安装或更新插件"></a>通过按键来安装或更新插件</h2><p>通过命令安装或者更新插件显得很繁琐, 我们期望通过快捷键可以实现下面的效果:</p><ul><li>当光标所在行是以 <code>Plug</code> 开始时, 我们可以直接按快捷键来安装或更新这个 <code>Plug</code> 命令加载的插件;</li><li>当光标所在行不是以 <code>Plug</code> 开始时, 按相同的按键, 我们会安装所有当前未安装的插件, 或者更新所有插件;</li></ul><p>可以通过下面的代码实现我们想要的效果:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">GetPlugNameFronCurrentLine</span><span class="params">(cmd)</span></span></span><br><span class="line">    <span class="keyword">let</span> plugin_name = <span class="built_in">getline</span>(<span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> plugin_name !~ <span class="string">"^Plug"</span></span><br><span class="line">        <span class="keyword">execute</span>(<span class="variable">a:cmd</span> . <span class="string">'!'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> plugin_name = <span class="keyword">split</span>(<span class="keyword">split</span>(plugin_name, <span class="string">"'"</span>)[<span class="number">1</span>], <span class="string">'/'</span>)[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> plugin_name = <span class="keyword">substitute</span>(plugin_name, <span class="string">'\.git$'</span>, <span class="string">''</span>, <span class="string">'g'</span>)</span><br><span class="line"><span class="keyword">execute</span>(<span class="variable">a:cmd</span> .<span class="string">' '</span>. plugin_name)</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">nmap</span> ,pi :<span class="keyword">w</span><span class="symbol">&lt;cr&gt;</span>:<span class="keyword">call</span> GetPlugNameFronCurrentLine(<span class="string">'PlugInstall'</span>)<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> ,<span class="keyword">pu</span> :<span class="keyword">call</span> GetPlugNameFronCurrentLine(<span class="string">'PlugUpdate'</span>)<span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure><p>当我们按 <code>,pi</code> 时便可安装光标所在行的插件, 或者是按 <code>,pu</code> 来更新光标所在行的插件.</p><h1 id="按需加载插件"><a href="#按需加载插件" class="headerlink" title="按需加载插件"></a>按需加载插件</h1><p>为了提高 vim 的启动速度, 我们期望某些插件只有在特定的情况下才被加载. 例如我们希望 <code>vim-go</code> 插件只有在编辑 go 类型的文件时才会被打开, 便可以通过如下方法实现:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/fatih/vim-go.git'</span>, &#123;<span class="string">'for'</span>: <span class="string">'go'</span>&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>for</code> 后面的文件类型也可以使用列表, 如 <code>{&#39;for&#39;: [&#39;go&#39;, &#39;golang&#39;]}</code> .</p><p>同时, 也可以在调用命令的时候加载插件, 如:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/Yggdroot/indentLine'</span>, &#123;<span class="string">'on'</span> : <span class="string">'IndentLinesToggle'</span>&#125;</span><br></pre></td></tr></table></figure><p>这段代码的意思是只有 <code>IndentLinesToggle</code> 被调用时, 对应的插件才会被加载. <code>on</code> 后面也可以使用列表.</p><h2 id="手动加载插件"><a href="#手动加载插件" class="headerlink" title="手动加载插件"></a>手动加载插件</h2><p>有时我们需要手动加载一些在 vim 启动时未被加载的插件, 例如我们可能希望在没打开 go 类型文件的情况下查看 vim-go 的帮助文档, 这时我们可以通过如下的自定义命令来加载 vim-go :</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">plug_loaded</span><span class="params">(spec)</span></span></span><br><span class="line">  <span class="keyword">let</span> rtp = <span class="keyword">join</span>(<span class="built_in">filter</span>([<span class="variable">a:spec</span>.dir, <span class="built_in">get</span>(<span class="variable">a:spec</span>, <span class="string">'rtp'</span>, <span class="string">''</span>)], <span class="string">'len(v:val)'</span>), <span class="string">'/'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">stridx</span>(&amp;rtp, rtp) &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">isdirectory</span>(rtp)</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">plug_names</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sort</span>(<span class="built_in">filter</span>(<span class="built_in">keys</span>(<span class="built_in">filter</span>(<span class="keyword">copy</span>(<span class="variable">g:plugs</span>), &#123; <span class="keyword">k</span>, v -&gt; !<span class="variable">s:plug_loaded</span>(v) &#125;)), <span class="string">'stridx(v:val, a:1) != -1'</span>))</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">command! -nargs=+ -bar -<span class="built_in">complete</span>=customlist,<span class="variable">s:plug_names</span> PlugLoad <span class="keyword">call</span> plug#load([<span class="symbol">&lt;f-args&gt;</span>])</span><br></pre></td></tr></table></figure><p>在 vimrc 中加入上述代码后, 我们便可通过 <code>:PlugLoad vim-go</code> 来加载 vim-go 这个插件. <code>PlugLoad</code> 命令可以自动补全当前未加载的插件.</p><h1 id="Post-update-Hooks"><a href="#Post-update-Hooks" class="headerlink" title="Post-update Hooks"></a>Post-update Hooks</h1><p>我们可以通过 <code>do</code> 标签来指定在安装或者更新完插件后所需要做的操作:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/autozimu/LanguageClient-neovim'</span>, &#123; <span class="string">'do'</span>: <span class="string">':UpdateRemotePlugins'</span> &#125;</span><br></pre></td></tr></table></figure><h1 id="Tip-基于-Ultisnip-快速补全-plug-命令"><a href="#Tip-基于-Ultisnip-快速补全-plug-命令" class="headerlink" title="Tip: 基于 Ultisnip 快速补全 plug 命令"></a>Tip: 基于 Ultisnip 快速补全 plug 命令</h1><p>往往我们在安装插件的时候会先把插件的地址复制到系统剪贴板中, 假定当前系统剪贴板的内容为 <code>https://github.com/hiberabyss/ProjectConfig</code> 借助 Ultisnip 的自动补全功能, 我们可以实现如下的效果:</p><p><img src="vim-plug.gif" alt></p><p>在 <code>vim.snippets</code> 中添加如下代码即可实现上面的效果:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">snippet plug <span class="string">"add new plugin"</span> <span class="keyword">b</span></span><br><span class="line">Plug <span class="string">'`!v @*`'</span>$<span class="number">1</span></span><br><span class="line">endsnippet</span><br></pre></td></tr></table></figure><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2020/05/06/vim-open-saz-file/">使用 Vim 查看 Fiddler 生成的 saz 格式 session 包</a></li><li><a href="https://hiberabyss.github.io/2018/05/03/add-async-support-for-vim-plugin/">给 Vim 插件添加上异步调用的功能</a></li><li><a href="https://hiberabyss.github.io/2018/04/24/vim-plug-rest-console/">实现类 Postman 功能的 VIM 插件</a></li><li><a href="https://hiberabyss.github.io/2018/04/13/vim-file-jumper/">Vim 文件快速跳转插件</a></li><li><a href="https://hiberabyss.github.io/2018/02/28/vim-project-configuration/">「VIM」基于项目的 VIM 配置</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为 VIM 的重度患者, 一款好用的插件管理工具显得尤为重要, 毕竟给 VIM 增加新功能, 或者是新增编程语言的支持都需要安装插件. 我个人目前安装了 133 款 VIM 插件.&lt;/p&gt;&lt;p&gt;我使用的 VIM 插件管理工具也从早起的 Vundle 到 NeoBundle, 再到现在使用的 &lt;a href=&quot;https://github.com/junegunn/vim-plug&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;vim-plug&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;选择 vim-plug , 是因为它:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;简洁且快速, 没有外部依赖, 整个插件只有一个文件;&lt;/li&gt;&lt;li&gt;该有的功能都有:&lt;ul&gt;&lt;li&gt;按需加载插件(On-demand loading); 这样可以加快 VIM 启动时间&lt;/li&gt;&lt;li&gt;Post-update hooks; 可以在插件安装或者更新时执行一些操作, 如 make 等&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;还提供了更高阶的功能, 使得安装或更新插件都更快速:&lt;ul&gt;&lt;li&gt;并行化地安装或者更新插件;&lt;/li&gt;&lt;li&gt;按照 shallow 的方式 clone 插件库, 下载更迅速&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;本文是 vim-plug 的一个简明教程, 会介绍它的安装使用, 以及我个人用到的一些 tips.&lt;/p&gt;
    
    </summary>
    
      <category term="Vim" scheme="https://hiberabyss.github.io/categories/vim/"/>
    
    
      <category term="Vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>网络并发编程模型</title>
    <link href="https://hiberabyss.github.io/2018/03/20/concurrency-models/"/>
    <id>https://hiberabyss.github.io/2018/03/20/concurrency-models/</id>
    <published>2018-03-20T16:39:11.000Z</published>
    <updated>2021-02-10T07:01:06.352Z</updated>
    
    <content type="html"><![CDATA[<p>网络并发编程模型一般包括三种:</p><ul><li>多进程;</li><li>多线程;</li><li>IO 多路复用</li></ul><p>本文会着重介绍 IO 多路复用这种编程模型, 包括对 select、poll、 epoll 的介绍.</p><a id="more"></a><h1 id="多进程和多线程并发编程模型"><a href="#多进程和多线程并发编程模型" class="headerlink" title="多进程和多线程并发编程模型"></a>多进程和多线程并发编程模型</h1><p>多进程和多线程并发编程模型都是通过新建进程或者线程去处理新的网络连接请求. 因为创建新进程的开销比要比线程高很多, 一般会使用多线程来实现并发.</p><p>如果把 golang 的协程看作是用户态线程的话, 我们可以用下面的代码来说明 多进程/多线程 编程模型:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connHandler</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">cnt, _ := c.Read(buf)</span><br><span class="line">c.Write(buf[<span class="number">0</span>:cnt])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">server, _ := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1208"</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Server started ..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, _ := server.Accept()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> connHandler(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是多进程并发编程模型的话, 就会用 fork 创建子进程去处理新的连接.</p><p>因为在系统中创建进程或者线程的数量是受限的, 也导致基于多进程多线程模型的并发数收到了限制.</p><h1 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h1><p>在 Linux/Unix 系统中, 对网络进行了抽象, 一个网络连接可以用一个描述符来表示.</p><p>而 IO 多路复用就是通过某种机制, 使得一个进程或线程可以监视多个描述符, 当某个描述符就绪时, 就能通知程序进行相应的读写操作, 也就是接收或者发送网络数据.</p><p>当我们进行一次 IO 访问时, 例如 read , 一般会发生下面两个过程:</p><ol><li>等待数据准备; 数据从网卡等设备拷贝到操作系统内核缓冲区;</li><li>将数据从内核缓冲区拷贝到进程地址空间内存;</li></ol><p>IO 多路复用包括三种: select、poll、epoll, 它们的实现原理都是类似的:</p><ul><li>先设置一些列的描述符;</li><li>select 等函数会不断地轮询所负责的所有描述符, 当某个描述符准备好时就直接返回, 通知用户程序, 否则就阻塞;</li></ul><p>具体如下图所示:</p><p><img src="multiplexing_model.png" alt></p><h2 id="select-缺点"><a href="#select-缺点" class="headerlink" title="select 缺点"></a>select 缺点</h2><p><code>select</code> 函数定义:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很</li><li>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li><li>支持的描述符数量受宏变量 <code>FD_SETSIZE</code> 限制, 默认比较小, 32 系统下是 <code>1024</code>, 64 位系统下是 <code>2048</code></li></ul><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>poll 本质上和 select 没有区别, 只是描述 fd 集合的方式不同, poll 使用的是 <code>pollfd</code> 而 select 使用的是 <code>fd_set</code> 方式. <code>pollfd</code> 底层是基于链表实现的.</p><p>poll 没有最大并发连接数的限制.</p><h2 id="epoll-优点"><a href="#epoll-优点" class="headerlink" title="epoll 优点"></a>epoll 优点</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>没有最大并发连接的限制，能打开的fd上限远大于1024（1G的内存上能监听约10万个端口）</li><li>采用回调的方式, 效率提升. 只有活跃可用的fd才会调用callback函数, 也就是说 epoll 只管 “活跃” 的连接, 而跟连接总数无关.</li><li>利用 mmap 文件映射内存加速与内核空间的消息传递, 避免了每次调用 select 都要进行内核态数据和用户数据的拷贝.</li></ul><p><code>epoll</code> 适用于存在大量 idle -connection 或者 dead-connection 的场景.</p><h2 id="epoll-工作模式"><a href="#epoll-工作模式" class="headerlink" title="epoll 工作模式"></a>epoll 工作模式</h2><p>epoll对文件描述符的操作有两种模式：LT（level trigger，水平触发）和ET（edge trigger，边缘触发）。二者的区别如下：</p><ul><li>水平触发：默认工作模式，即当 epoll_wait 检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件。</li><li>边缘触发：当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。（直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时通知一次）</li></ul><p>边缘触发（ET模式）在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞socket，以避免由于一个文件描述符的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><p><a href="http://blog.csdn.net/lisonglisonglisong/article/details/51328062" rel="external nofollow noopener noreferrer" target="_blank">这里</a> 有更详细的三者间的对比以及原理介绍.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://segmentfault.com/a/1190000003063859" rel="external nofollow noopener noreferrer" target="_blank">Linux IO模式及 select、poll、epoll详解</a></li><li><a href="http://blog.csdn.net/lisonglisonglisong/article/details/51328062" rel="external nofollow noopener noreferrer" target="_blank">IO多路复用：select、poll、epoll示例</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络并发编程模型一般包括三种:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;多进程;&lt;/li&gt;&lt;li&gt;多线程;&lt;/li&gt;&lt;li&gt;IO 多路复用&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;本文会着重介绍 IO 多路复用这种编程模型, 包括对 select、poll、 epoll 的介绍.&lt;/p&gt;
    
    </summary>
    
      <category term="Interview" scheme="https://hiberabyss.github.io/categories/interview/"/>
    
    
      <category term="Concurrent" scheme="https://hiberabyss.github.io/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>给 Hexo 博客集成 gitalk 评论系统</title>
    <link href="https://hiberabyss.github.io/2018/03/19/hexo-gitalk-integration/"/>
    <id>https://hiberabyss.github.io/2018/03/19/hexo-gitalk-integration/</id>
    <published>2018-03-19T14:56:12.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>之前博客用的是 <a href="https://valine.js.org/#/" rel="external nofollow noopener noreferrer" target="_blank">Valine</a>, 选择它的原因是可以匿名评论. Valine 的缺点是没有办法对新的评论发邮件提醒, 虽然官方文档说是可以的, 但一直没能按文档配置成功.</p><p>Gitalk 是一款基于 github issue 的评论系统, 它的缺点是没办法匿名评论, 但鉴于我的博客是技术博客, 大部分读者应该都是有 github 账号的, 这个缺点还是可以忍受的.</p><a id="more"></a><h1 id="如何集成-Gitalk"><a href="#如何集成-Gitalk" class="headerlink" title="如何集成 Gitalk"></a>如何集成 Gitalk</h1><p><a href="https://github.com/gitalk/gitalk" rel="external nofollow noopener noreferrer" target="_blank">Gitalk</a> 官网有详细的安装介绍, <a href="https://github.com/tufu9441/maupassant-hexo/blob/master/layout/_partial/comments.pug" rel="external nofollow noopener noreferrer" target="_blank">这儿</a> 是 maupassant 主题的一个集成示例.</p><p><a href="https://github.com/hiberabyss/maupassant-hexo/blob/7b9dbaf84c489e92bfed0a3275b5b7264285cfe5/_config.yml#L11" rel="external nofollow noopener noreferrer" target="_blank">这儿</a> 是我的 maupassant 主题中 Gitalk 的配置示例.</p><h1 id="使用-md5-解决-label-过长的问题"><a href="#使用-md5-解决-label-过长的问题" class="headerlink" title="使用 md5 解决 label 过长的问题"></a>使用 md5 解决 label 过长的问题</h1><p>Gitalk 中每篇博客都是和一个 issue 对应的, 博客的评论内容就是存储在对应的 issue 中:</p><ul><li>每篇博客都会有一个 id, 这个 id 是以 issue label 的形式存储的</li><li>id 默认是博客的链接地址</li><li>Github 对 label 的长度有限制, 最多只能是 50 个字符</li></ul><p>当博客的标题比较长时, 很容易就会超过 50 个字符的限制, 这时就会出现 “Error: Validation Failed.” 这样的错误.</p><p>为了解决这个问题, 我们可以使用博客链接地址的 md5 值作为博客的 id. 这需要我们修改 gitalk 的集成脚本:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">script(type=&apos;text/javascript&apos; src=&apos;//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js&apos;)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">id: md5(window.location.pathname),</span><br></pre></td></tr></table></figure><p><a href="https://github.com/hiberabyss/maupassant-hexo/blob/master/layout/_partial/comments.pug#L74" rel="external nofollow noopener noreferrer" target="_blank">这儿</a> 是完整的示例代码.</p><p>这里我们使用 <code>window.location.pathname</code> 作为计算 md5 的输入, 它不包括链接中的 host 部分, 这样当我们的博客存在不同的镜像时, 可以让不同主机上的相同博客共享同一套评论.</p><h1 id="初始化所有博客的评论系统"><a href="#初始化所有博客的评论系统" class="headerlink" title="初始化所有博客的评论系统"></a>初始化所有博客的评论系统</h1><p><a href="https://draveness.me/git-comments-initialize" rel="external nofollow noopener noreferrer" target="_blank">这篇博客</a>详细介绍了如何对之前的博客初始化评论系统, 这里我们只介绍如何通过 sitemap 的方法来进行初始化.</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>在开始之前需要我们准备好一下环境:</p><ul><li>生成了博客的 sitemap.xml 文件</li><li>在 <a href="https://github.com/settings/tokens" rel="external nofollow noopener noreferrer" target="_blank">Personal Access Tokens</a> 界面中创建一个新的 token, 需要选中所有 repo 的权限</li><li>安装依赖的 gem 包: <code>sudo gem install faraday activesupport sitemap-parser</code></li></ul><p>上面的环境准备好了之后, 把对应的信息填到下面的 ruby 脚本并执行即可:</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">username = <span class="string">"hiberabyss"</span> <span class="comment"># GitHub 用户名</span></span><br><span class="line">token = <span class="string">"your-token"</span>  <span class="comment"># GitHub Token</span></span><br><span class="line">repo_name = <span class="string">"BlogComments"</span> <span class="comment"># 存放 issues</span></span><br><span class="line">sitemap_url = <span class="string">"https://hiberabyss.github.io/sitemap.xml"</span> <span class="comment"># sitemap</span></span><br><span class="line">kind = <span class="string">"Gitalk"</span> <span class="comment"># "Gitalk" or "gitment"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="string">'open-uri'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'faraday'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'active_support'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'active_support/core_ext'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'sitemap-parser'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'uri'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'digest/md5'</span></span><br><span class="line"></span><br><span class="line">sitemap = SitemapParser.new sitemap_url</span><br><span class="line">urls = sitemap.to_a</span><br><span class="line"></span><br><span class="line">conn = Faraday.new(<span class="symbol">:url</span> =&gt; <span class="string">"https://api.github.com/repos/<span class="subst">#&#123;username&#125;</span>/<span class="subst">#&#123;repo_name&#125;</span>/issues"</span>) <span class="keyword">do</span> <span class="params">|conn|</span></span><br><span class="line">  conn.basic_auth(username, token)</span><br><span class="line">  conn.adapter  Faraday.default_adapter</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">urls.each_with_index <span class="keyword">do</span> <span class="params">|url, index|</span></span><br><span class="line">  uri = URI::parse(url)</span><br><span class="line">  url_md5 = Digest::MD5.hexdigest(uri.path)</span><br><span class="line"></span><br><span class="line">  title = open(url).read.scan(<span class="regexp">/&lt;title&gt;(.*?)&lt;\/title&gt;/</span>).first.first.force_encoding(<span class="string">'UTF-8'</span>)</span><br><span class="line">  response = conn.post <span class="keyword">do</span> <span class="params">|req|</span></span><br><span class="line">    req.body = &#123; <span class="symbol">body:</span> url, <span class="symbol">labels:</span> [kind, url_md5], <span class="symbol">title:</span> title &#125;.to_json</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  puts response.body</span><br><span class="line">  sleep <span class="number">15</span> <span class="keyword">if</span> index % <span class="number">20</span> == <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这个脚本中我们也是用博客链接的 md5 值作为 id 的.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://draveness.me/git-comments-initialize" rel="external nofollow noopener noreferrer" target="_blank">自动初始化 Gitalk 和 Gitment 评论</a></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/05/06/hexo-copyright-recommendations/">给 maupassant 主题添加文章版权信息和推荐阅读功能</a></li><li><a href="https://hiberabyss.github.io/2017/03/13/hexo-tutorial/">Hexo 入门教程</a></li><li><a href="https://hiberabyss.github.io/2017/03/13/hexo-source-code-backup/">Hexo 源文件备份</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前博客用的是 &lt;a href=&quot;https://valine.js.org/#/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Valine&lt;/a&gt;, 选择它的原因是可以匿名评论. Valine 的缺点是没有办法对新的评论发邮件提醒, 虽然官方文档说是可以的, 但一直没能按文档配置成功.&lt;/p&gt;&lt;p&gt;Gitalk 是一款基于 github issue 的评论系统, 它的缺点是没办法匿名评论, 但鉴于我的博客是技术博客, 大部分读者应该都是有 github 账号的, 这个缺点还是可以忍受的.&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://hiberabyss.github.io/categories/hexo/"/>
    
    
      <category term="Hexo" scheme="https://hiberabyss.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>使用 Go 进行 Socket 编程</title>
    <link href="https://hiberabyss.github.io/2018/03/14/unix-socket-programming/"/>
    <id>https://hiberabyss.github.io/2018/03/14/unix-socket-programming/</id>
    <published>2018-03-14T15:09:02.000Z</published>
    <updated>2021-02-10T07:01:06.364Z</updated>
    
    <content type="html"><![CDATA[<p>Socket 是对 TCP/UDP 封装后提供的一层接口, 我们可以利用 Socket 编写服务端和客户端, 然后让客户端和服务端建立 TCP 或 UDP 的连接.</p><a id="more"></a><h1 id="Unix-Socket-编程的函数接口"><a href="#Unix-Socket-编程的函数接口" class="headerlink" title="Unix Socket 编程的函数接口"></a>Unix Socket 编程的函数接口</h1><p>在 Unix/Linux 中的 Socket 编程主要通过调用 <code>listen</code>, <code>accept</code>, <code>write</code> <code>read</code> 等函数来实现的. 具体如下图所示:</p><p><img src="unix_socket.png" alt></p><h1 id="Golang-中的-Socket-编程模型"><a href="#Golang-中的-Socket-编程模型" class="headerlink" title="Golang 中的 Socket 编程模型"></a>Golang 中的 Socket 编程模型</h1><p>和 Linux Socket 编程相比, go 的 Socket 编程就简单很多. 服务端直接通过 Listen + Accept 模式即可实现:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connHandler</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        cnt, err := c.Read(buf)</span><br><span class="line">        c.Write(buf)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    server, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1208"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := server.Accept()</span><br><span class="line">        <span class="keyword">go</span> connHandler(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而客户端直接调用 Dial 即可:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connHandler</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        c.Write(...)</span><br><span class="line">        c.Read(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:1208"</span>)</span><br><span class="line">    connHandler(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们会通过一个示例来介绍如果通过 go 进行 Socket 编程, 具体的代码存放在 <a href="https://github.com/hiberabyss/JustDoIt/tree/master/socket" rel="external nofollow noopener noreferrer" target="_blank">Github</a> 上.</p><h1 id="实现一个可以接受不同命令的服务端"><a href="#实现一个可以接受不同命令的服务端" class="headerlink" title="实现一个可以接受不同命令的服务端"></a>实现一个可以接受不同命令的服务端</h1><p>我们实现一个服务端, 它可以接受下面这些命令:</p><ul><li><code>ping</code> 探活的命令, 服务端会返回 “pong”</li><li><code>echo</code> 服务端会返回收到的字符串</li><li><code>quit</code> 服务端收到这个命令后就会关闭连接</li></ul><p>具体的服务端代码如下所示:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connHandler</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4096</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        cnt, err := c.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> || cnt == <span class="number">0</span> &#123;</span><br><span class="line">            c.Close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inStr := strings.TrimSpace(<span class="keyword">string</span>(buf[<span class="number">0</span>:cnt]))</span><br><span class="line"></span><br><span class="line">        inputs := strings.Split(inStr, <span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> inputs[<span class="number">0</span>] &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"ping"</span>:</span><br><span class="line">            c.Write([]<span class="keyword">byte</span>(<span class="string">"pong\n"</span>))</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"echo"</span>:</span><br><span class="line">            echoStr := strings.Join(inputs[<span class="number">1</span>:], <span class="string">" "</span>) + <span class="string">"\n"</span></span><br><span class="line">            c.Write([]<span class="keyword">byte</span>(echoStr))</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"quit"</span>:</span><br><span class="line">            c.Close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"Unsupported command: %s\n"</span>, inputs[<span class="number">0</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"Connection from %v closed. \n"</span>, c.RemoteAddr())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    server, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1208"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Fail to start server, %s\n"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Server Started ..."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := server.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"Fail to connect, %s\n"</span>, err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> connHandler(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译上面的服务端代码并启动后, 我们用 telnet 测试下服务端是否正常工作, 结果如下图所示:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1521018376491.png" width="570"></p><p>我们分别在 telnet 中依次输入了下面三个命令:</p><ul><li><code>ping</code></li><li><code>echo hello, hbliu</code></li><li><code>quit</code></li></ul><h1 id="客户端的实现"><a href="#客户端的实现" class="headerlink" title="客户端的实现"></a>客户端的实现</h1><p>我们可以自己实现一个客户端来和我们的服务端进行通信, 实现类似 telnet 的功能, 代码如下:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connHandler</span><span class="params">(c net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">    reader := bufio.NewReader(os.Stdin)</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        input, _ := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">        input = strings.TrimSpace(input)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> input == <span class="string">"quit"</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c.Write([]<span class="keyword">byte</span>(input))</span><br><span class="line"></span><br><span class="line">        cnt, err := c.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"Fail to read data, %s\n"</span>, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fmt.Print(<span class="keyword">string</span>(buf[<span class="number">0</span>:cnt]))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:1208"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Fail to connect, %s\n"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    connHandler(conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以编译上面的代码, 启动后便可执行服务端支持的命令, 如下图所示:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1521018622634.png" width="570"></p><h1 id="TCP-状态转换图"><a href="#TCP-状态转换图" class="headerlink" title="TCP 状态转换图"></a>TCP 状态转换图</h1><p>其中虚线标识被动方状态变化, 红色粗线标识主动方的状态变化:</p><p><img src="tcp_status1.jpg" width="600"></p><p>从服务端客户端角度来观察的状态变化:</p><p><img src="tcp_open_close.jpg" width="600"></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="http://blog.csdn.net/tennysonsky/article/details/45621341" rel="external nofollow noopener noreferrer" target="_blank">TCP网络编程中connect()、listen()和accept()三者之间的关系</a></li><li><a href="https://coolshell.cn/articles/11564.html" rel="external nofollow noopener noreferrer" target="_blank">TCP 的那些事儿（上）</a></li><li><a href="https://github.com/akrennmair/telnet-chat/blob/master/01_echo/echo.go" rel="external nofollow noopener noreferrer" target="_blank">Echo Service</a></li><li><a href="https://tonybai.com/2015/11/17/tcp-programming-in-golang/" rel="external nofollow noopener noreferrer" target="_blank">Go语言TCP Socket编程</a></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/05/04/request-limit-and-qps-statistics/">用 go 实现简易版的请求限流和流量统计</a></li><li><a href="https://hiberabyss.github.io/2018/03/23/golang-slice-analyze/">「Golang」Slice 详解</a></li><li><a href="https://hiberabyss.github.io/2018/03/12/implement-ping-command-via-golang/">使用 golang 实现 ping 命令</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Socket 是对 TCP/UDP 封装后提供的一层接口, 我们可以利用 Socket 编写服务端和客户端, 然后让客户端和服务端建立 TCP 或 UDP 的连接.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://hiberabyss.github.io/categories/linux/"/>
    
    
      <category term="Go" scheme="https://hiberabyss.github.io/tags/go/"/>
    
      <category term="Socket" scheme="https://hiberabyss.github.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信： 共享内存</title>
    <link href="https://hiberabyss.github.io/2018/03/13/shared-memory/"/>
    <id>https://hiberabyss.github.io/2018/03/13/shared-memory/</id>
    <published>2018-03-13T00:21:02.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 中的进程通信主要包括以下几种方式:</p><ul><li>管道(pipe); 流管道 (s_pipe) 和有名管道 (FIFO)</li><li>信号（signal）</li><li>消息队列</li><li>共享内存</li><li>信号量</li><li>套接字（socket)</li></ul><p>本文主要介绍共享内存的使用方式, 其中也会用到信号.</p><a id="more"></a><h1 id="使用-shm-机制"><a href="#使用-shm-机制" class="headerlink" title="使用 shm 机制"></a>使用 shm 机制</h1><p>shm 基于 key 来标识一块共享内存区域, 使用 <code>shmget</code> 来创建或获取一段已经存在的共享内存. 当多个进程通过同一个 key 调用 <code>shmget</code> 时, 它们会把同一块内存区域映射到自己的地址空间中.</p><h2 id="读写者模型"><a href="#读写者模型" class="headerlink" title="读写者模型"></a>读写者模型</h2><p>假定存在一个读者进程和一个写着进程, 它们共用一段共享内存, 按照如下的模式工作:</p><ul><li>写者进程往共享内存中写数据; 写完数据后通知读者进程并进入阻塞状态, 等待读者进程发送信号, 然后接着等待用户的输入;</li><li>读者进程等待写者进程的信号, 收到后会打印共享内存中的字符串到 stdout, 发送信号给写者进程, 然后进入阻塞状态;</li></ul><p>当写者进程检查到用户的输入是 <code>quit</code> 时, 便会先给读者进程发送信号, 然后开始进入退出模式, 开始清理共享内存. 当读者进程检测到共享内存中的字符串为 <code>quit</code> 时便会直接退出.</p><h3 id="如何获取对方的-PID"><a href="#如何获取对方的-PID" class="headerlink" title="如何获取对方的 PID"></a>如何获取对方的 PID</h3><p>为了能够给对方发送信号, 读者写着需要知道对方的 PID , 这个信息也是通过共享内存获取的:</p><ul><li>当任何一个进程先启动时, 便会创建共享内存, 同时把自己的 PID 写到共享内存中, 然后进入阻塞状态.</li><li>当后启动的进程检测到共享内存已经存在时, 便从共享内存里读取到对方的 PID 并保存在自己的内存变量里; 同时在共享内存中保存自己的 PID, 给对方进程发送信号;</li><li>当先启动的进程接收到信号后, 便从共享内存中读取对方的 PID 并保存到自己的内存变量里</li></ul><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><ul><li>启动 writer</li><li>启动 reader</li><li>在 writer 处输入 <code>hello</code>; reader 处会输出 <code>hello</code></li><li>再 writer 处输入 <code>quit</code>; writer 和 reader 都会退出</li></ul><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1520873559834.png" width="570"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>相关的代码在 <a href="https://github.com/hiberabyss/JustDoIt/tree/master/ShareMemory" rel="external nofollow noopener noreferrer" target="_blank">Github</a> 上, 下载下来后可直接用 <code>make</code> 生成 writer 和 reader.</p><h1 id="使用-mmap-来实现内存共享"><a href="#使用-mmap-来实现内存共享" class="headerlink" title="使用 mmap 来实现内存共享"></a>使用 mmap 来实现内存共享</h1><p>不同于 shm , mmap 并不是专门为共享内存设计的. 它的主要作用是把文件内容映射到内存地址空间中, 可以像访问内存一样访问文件, 从而避免调用 <code>read</code> <code>write</code> 等高开销的系统调用, 提高文件的访问效率.</p><p>在 mmap 的参数中, 我们可以添加一个 <code>MAP_SHARED</code> 标志, 这样当多个进程 mmap 同一个文件的相同部分内容的时候, 它们使用的是同一块内存区域.</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们创建两个读写进程, 读进程每隔 2s 输出共享内存里的内容; 写进程会修改共享内存内容, 最终读进程会打印出修改后的内容. 代码保存在 <a href="https://github.com/hiberabyss/JustDoIt/tree/master/ShareMemory/mmap" rel="external nofollow noopener noreferrer" target="_blank">Github</a> 上.</p><p>通过匿名文件映射, 我们也能实现父子进程间的内存共享. <a href="https://github.com/hiberabyss/JustDoIt/blob/master/ShareMemory/mmap/anonymous.c" rel="external nofollow noopener noreferrer" target="_blank">这儿</a> 是详细代码实现.</p><h2 id="mmap-的一些-tips"><a href="#mmap-的一些-tips" class="headerlink" title="mmap 的一些 tips"></a>mmap 的一些 tips</h2><p>我们可以通过给 mmap 加上 <code>MAP_PRIVATE</code> 标志来防止程序修改文件的内容.</p><p>在通过 mmap 把文件映射进内存后, 我们能操作的整个内存范围是系统中能容纳这些文件内容的最少的页. 例如我们映射了 2 页文件内容到内存, 则我们最多只能操作 2 页内存; 如果我们映射了 1.5 页文件内容到内存, 我们也是最多能操作 2 页内存.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="http://blog.csdn.net/gatieme/article/details/51005811" rel="external nofollow noopener noreferrer" target="_blank">进程间通信之-共享内存Shared Memory–linux内核剖析</a></li><li><a href="http://blog.csdn.net/maverick1990/article/details/48050975" rel="external nofollow noopener noreferrer" target="_blank">Linux进程间内存共享机制mmap详解</a></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/04/04/gdb-internal/">GDB 实现原理介绍</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux 中的进程通信主要包括以下几种方式:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;管道(pipe); 流管道 (s_pipe) 和有名管道 (FIFO)&lt;/li&gt;&lt;li&gt;信号（signal）&lt;/li&gt;&lt;li&gt;消息队列&lt;/li&gt;&lt;li&gt;共享内存&lt;/li&gt;&lt;li&gt;信号量&lt;/li&gt;&lt;li&gt;套接字（socket)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;本文主要介绍共享内存的使用方式, 其中也会用到信号.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://hiberabyss.github.io/categories/linux/"/>
    
    
      <category term="Linux" scheme="https://hiberabyss.github.io/tags/linux/"/>
    
      <category term="IPC" scheme="https://hiberabyss.github.io/tags/ipc/"/>
    
      <category term="Interview" scheme="https://hiberabyss.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>使用 golang 实现 ping 命令</title>
    <link href="https://hiberabyss.github.io/2018/03/12/implement-ping-command-via-golang/"/>
    <id>https://hiberabyss.github.io/2018/03/12/implement-ping-command-via-golang/</id>
    <published>2018-03-12T16:27:35.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>ping 是一个经常被用来检查主机间连通性的工具, 它基于 ICMP 协议实现, 基本原理很简单: 本机给远程机器发送 ICMP 报文, 远程主机接收到 ICMP 报文后便会回复一个类似的 ICMP 报文; 当本机接收到回复后变认为远程主机是可连接的, 否则便认为这个主机是不可达的.</p><p>为了了解 golang 的网络编程, 我用 go 实现了一个 ping 命令, 本文会介绍如何实现 ping 命令.</p><a id="more"></a><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p><a href="https://github.com/hiberabyss/JustDoIt/tree/master/ping" rel="external nofollow noopener noreferrer" target="_blank">这里有完整的示例代码</a>, 可以直接执行实现下面的效果 (<strong>注意需要 sudo 权限</strong>):</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ping git:(master) sudo go run goping.go baidu.com</span><br><span class="line">Ping 111.13.101.208 (baidu.com):</span><br><span class="line"></span><br><span class="line">28 bytes from 111.13.101.208: seq=1 time=9ms</span><br><span class="line">28 bytes from 111.13.101.208: seq=2 time=9ms</span><br><span class="line">28 bytes from 111.13.101.208: seq=3 time=10ms</span><br><span class="line">28 bytes from 111.13.101.208: seq=4 time=10ms</span><br><span class="line">28 bytes from 111.13.101.208: seq=5 time=9ms</span><br></pre></td></tr></table></figure><h1 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h1><h2 id="ICMP-报文"><a href="#ICMP-报文" class="headerlink" title="ICMP 报文"></a>ICMP 报文</h2><p>首先我们需要定义出 ICMP 报文头的结构:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ICMP <span class="keyword">struct</span> &#123;</span><br><span class="line">Type        <span class="keyword">uint8</span></span><br><span class="line">Code        <span class="keyword">uint8</span></span><br><span class="line">CheckSum    <span class="keyword">uint16</span></span><br><span class="line">Identifier  <span class="keyword">uint16</span></span><br><span class="line">SequenceNum <span class="keyword">uint16</span></span><br></pre></td></tr></table></figure><p>其中 <code>Type</code> 表明的是 ICMP 的类型, <code>Code</code> 则用来进一步划分 ICMP 的类型, ping 使用的是 echo 类型的 ICMP, 这两个值需要分别设置为 8 和 0.</p><p><code>CheckSum</code> 是报文头的校验值, 以防止在网络传输过程中的数据错误. 会先把这个字段设置为 0 来计算校验值, 计算完成后再把校验值赋值到这个字段.</p><p>ID 是用来标识一个 ICMP, 可以设置为 0; 而 <code>SequenceNum</code> 则是序列号, 可以在发送 ICMP 报文的时候依次累加.</p><p><a href="http://blog.csdn.net/simplelovecs/article/details/51146960" rel="external nofollow noopener noreferrer" target="_blank">这篇文章</a>对 ICMP 的结构有更详细的介绍.</p><p>基于上面的描述, 我们可以实现下面这个基于序列号生成 ICMP 报文头的函数:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getICMP</span><span class="params">(seq <span class="keyword">uint16</span>)</span> <span class="title">ICMP</span></span> &#123;</span><br><span class="line">icmp := ICMP&#123;</span><br><span class="line">Type:        <span class="number">8</span>,</span><br><span class="line">Code:        <span class="number">0</span>,</span><br><span class="line">CheckSum:    <span class="number">0</span>,</span><br><span class="line">Identifier:  <span class="number">0</span>,</span><br><span class="line">SequenceNum: seq,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">binary.Write(&amp;buffer, binary.BigEndian, icmp)</span><br><span class="line">icmp.CheckSum = CheckSum(buffer.Bytes())</span><br><span class="line">buffer.Reset()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> icmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>CheckSum()</code> 是用来计算校验值的函数. 在网络中传输的数据需要是大端字节序的.</p><h2 id="发送及接收-ICMP-报文"><a href="#发送及接收-ICMP-报文" class="headerlink" title="发送及接收 ICMP 报文"></a>发送及接收 ICMP 报文</h2><p>首先, 我们使用 <code>net.DialIP(&quot;ip4:icmp&quot;, nil, destAddr)</code> 来创建一个 ICMP 报文.</p><p>接着我们使用下面的代码填充 ICMP 报文并发送:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">binary.Write(&amp;buffer, binary.BigEndian, icmp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := conn.Write(buffer.Bytes()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送完之后, 我们使用下面的命令接收请求:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">recv := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">receiveCnt, err := conn.Read(recv)</span><br></pre></td></tr></table></figure><p>同时我们还需要统计发送到接收之间所耗费的时间.</p><p>完整的代码如下所示:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendICMPRequest</span><span class="params">(icmp ICMP, destAddr *net.IPAddr)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">conn, err := net.DialIP(<span class="string">"ip4:icmp"</span>, <span class="literal">nil</span>, destAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Fail to connect to remote host: %s\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">binary.Write(&amp;buffer, binary.BigEndian, icmp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := conn.Write(buffer.Bytes()); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tStart := time.Now()</span><br><span class="line"></span><br><span class="line">conn.SetReadDeadline((time.Now().Add(time.Second * <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">recv := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">receiveCnt, err := conn.Read(recv)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tEnd := time.Now()</span><br><span class="line">duration := tEnd.Sub(tStart).Nanoseconds() / <span class="number">1e6</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%d bytes from %s: seq=%d time=%dms\n"</span>, receiveCnt, destAddr.String(), icmp.SequenceNum, duration)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ping-命令的完整代码"><a href="#ping-命令的完整代码" class="headerlink" title="ping 命令的完整代码"></a>ping 命令的完整代码</h1><p><a href="https://github.com/hiberabyss/JustDoIt/blob/master/ping/goping.go" rel="external nofollow noopener noreferrer" target="_blank">Github 上的文件路径</a></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bytes"</span></span><br><span class="line"><span class="string">"encoding/binary"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ICMP <span class="keyword">struct</span> &#123;</span><br><span class="line">Type        <span class="keyword">uint8</span></span><br><span class="line">Code        <span class="keyword">uint8</span></span><br><span class="line">CheckSum    <span class="keyword">uint16</span></span><br><span class="line">Identifier  <span class="keyword">uint16</span></span><br><span class="line">SequenceNum <span class="keyword">uint16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usage</span><span class="params">()</span></span> &#123;</span><br><span class="line">msg := <span class="string">`</span></span><br><span class="line"><span class="string">Need to run as root!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">goping host</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Example: ./goping www.baidu.com`</span></span><br><span class="line"></span><br><span class="line">fmt.Println(msg)</span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getICMP</span><span class="params">(seq <span class="keyword">uint16</span>)</span> <span class="title">ICMP</span></span> &#123;</span><br><span class="line">icmp := ICMP&#123;</span><br><span class="line">Type:        <span class="number">8</span>,</span><br><span class="line">Code:        <span class="number">0</span>,</span><br><span class="line">CheckSum:    <span class="number">0</span>,</span><br><span class="line">Identifier:  <span class="number">0</span>,</span><br><span class="line">SequenceNum: seq,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">binary.Write(&amp;buffer, binary.BigEndian, icmp)</span><br><span class="line">icmp.CheckSum = CheckSum(buffer.Bytes())</span><br><span class="line">buffer.Reset()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> icmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendICMPRequest</span><span class="params">(icmp ICMP, destAddr *net.IPAddr)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">conn, err := net.DialIP(<span class="string">"ip4:icmp"</span>, <span class="literal">nil</span>, destAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Fail to connect to remote host: %s\n"</span>, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">binary.Write(&amp;buffer, binary.BigEndian, icmp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := conn.Write(buffer.Bytes()); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tStart := time.Now()</span><br><span class="line"></span><br><span class="line">conn.SetReadDeadline((time.Now().Add(time.Second * <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">recv := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">receiveCnt, err := conn.Read(recv)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tEnd := time.Now()</span><br><span class="line">duration := tEnd.Sub(tStart).Nanoseconds() / <span class="number">1e6</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%d bytes from %s: seq=%d time=%dms\n"</span>, receiveCnt, destAddr.String(), icmp.SequenceNum, duration)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckSum</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">uint16</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">sum    <span class="keyword">uint32</span></span><br><span class="line">length <span class="keyword">int</span> = <span class="built_in">len</span>(data)</span><br><span class="line">index  <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> length &gt; <span class="number">1</span> &#123;</span><br><span class="line">sum += <span class="keyword">uint32</span>(data[index])&lt;&lt;<span class="number">8</span> + <span class="keyword">uint32</span>(data[index+<span class="number">1</span>])</span><br><span class="line">index += <span class="number">2</span></span><br><span class="line">length -= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> length &gt; <span class="number">0</span> &#123;</span><br><span class="line">sum += <span class="keyword">uint32</span>(data[index])</span><br><span class="line">&#125;</span><br><span class="line">sum += (sum &gt;&gt; <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">uint16</span>(^sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &lt; <span class="number">2</span> &#123;</span><br><span class="line">usage()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">host := os.Args[<span class="number">1</span>]</span><br><span class="line">raddr, err := net.ResolveIPAddr(<span class="string">"ip"</span>, host)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Fail to resolve %s, %s\n"</span>, host, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Ping %s (%s):\n\n"</span>, raddr.String(), host)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">6</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> err = sendICMPRequest(getICMP(<span class="keyword">uint16</span>(i)), raddr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Error: %s\n"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="http://blog.csdn.net/simplelovecs/article/details/51146960" rel="external nofollow noopener noreferrer" target="_blank">Golang实现ping</a></li><li><a href="http://blog.csdn.net/wangkai_123456/article/details/67632901&lt;Paste" rel="external nofollow noopener noreferrer" target="_blank">使用Golang实现简单Ping过程</a></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/05/04/request-limit-and-qps-statistics/">用 go 实现简易版的请求限流和流量统计</a></li><li><a href="https://hiberabyss.github.io/2018/03/23/golang-slice-analyze/">「Golang」Slice 详解</a></li><li><a href="https://hiberabyss.github.io/2018/03/14/unix-socket-programming/">使用 Go 进行 Socket 编程</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ping 是一个经常被用来检查主机间连通性的工具, 它基于 ICMP 协议实现, 基本原理很简单: 本机给远程机器发送 ICMP 报文, 远程主机接收到 ICMP 报文后便会回复一个类似的 ICMP 报文; 当本机接收到回复后变认为远程主机是可连接的, 否则便认为这个主机是不可达的.&lt;/p&gt;&lt;p&gt;为了了解 golang 的网络编程, 我用 go 实现了一个 ping 命令, 本文会介绍如何实现 ping 命令.&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://hiberabyss.github.io/categories/go/"/>
    
    
      <category term="Go" scheme="https://hiberabyss.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>「tor」基于 Tor Browser 翻墙</title>
    <link href="https://hiberabyss.github.io/2018/03/12/tor-vpn/"/>
    <id>https://hiberabyss.github.io/2018/03/12/tor-vpn/</id>
    <published>2018-03-12T11:43:55.000Z</published>
    <updated>2021-02-10T07:01:06.364Z</updated>
    
    <content type="html"><![CDATA[<p>由于众所周知的原因, 国外的一些网站无法被访问到. 但有时偶尔需要访问下这些网站, 我们便可以通过 Tor Browser 来翻墙.</p><a id="more"></a><h1 id="Tor-Browser-的优缺点"><a href="#Tor-Browser-的优缺点" class="headerlink" title="Tor Browser 的优缺点"></a>Tor Browser 的优缺点</h1><p>优点:</p><ul><li>开箱即用, 不需要复杂的配置;</li><li>稳定且没有流量限制; 不像 Lantern, 有时会很不稳定, 而且每个月还有 500MB 的流量限制;</li></ul><p>缺点:</p><ul><li>速度太慢, 基本也就能刷刷网页了;</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>通过 <a href="https://www.torproject.org/projects/torbrowser.html.en" rel="external nofollow noopener noreferrer" target="_blank">Tor Browser官网</a> 下载安装即可 (如无法下载, 可在页面下方评论, 我会提供下载链接).</p><p>安装完成打开后, 我们直接选择 <code>meek-amazon</code> 或 <code>meek-azure</code> 即可, 如下图所示:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1520827025220.png" width="548"></p><p>然后点确定, 最后就会进入下面的页面:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1520827101652.png" width="637"></p><p>这个浏览器默认就可以翻墙了, 默认可以访问 Google, FaceBook 等网站.</p><h1 id="让-Chrome-也能用上-Tor-Browser-的代理"><a href="#让-Chrome-也能用上-Tor-Browser-的代理" class="headerlink" title="让 Chrome 也能用上 Tor Browser 的代理"></a>让 Chrome 也能用上 Tor Browser 的代理</h1><p>Tor Browser 会在 9150 端口上开启一个 tor 的代理, 当我们打开 Tor Browser 之后, 配置 Chrome 使用这个代理就可以翻墙了. 下图是基于 SwitchyOmega 配置的代理:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1520829500960.png" width="855"></p><h1 id="通过-Tor-Browser-切换-IP"><a href="#通过-Tor-Browser-切换-IP" class="headerlink" title="通过 Tor Browser 切换 IP"></a>通过 Tor Browser 切换 IP</h1><p>有些网站会基于 IP 做一些限制, 我们可以很方便的通过 Tor Browser 来切换对外的 IP. 每次当我们点击 “为此站点使用新 Tor 线路” 的时候就会切换成一个新的 IP 地址:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1520829784387.png" width="428"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于众所周知的原因, 国外的一些网站无法被访问到. 但有时偶尔需要访问下这些网站, 我们便可以通过 Tor Browser 来翻墙.&lt;/p&gt;
    
    </summary>
    
      <category term="Tool" scheme="https://hiberabyss.github.io/categories/tool/"/>
    
    
      <category term="Tor" scheme="https://hiberabyss.github.io/tags/tor/"/>
    
      <category term="vpn" scheme="https://hiberabyss.github.io/tags/vpn/"/>
    
  </entry>
  
  <entry>
    <title>并行编程里的一些基本概念</title>
    <link href="https://hiberabyss.github.io/2018/03/07/parallel-programing-concepts/"/>
    <id>https://hiberabyss.github.io/2018/03/07/parallel-programing-concepts/</id>
    <published>2018-03-07T14:43:36.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>本文会简单介绍并行编程里经常会遇到的一些基本概念, 及这些不同概念之间的区别; 包括并发和并行; 进程, 线程及协程.</p><a id="more"></a><h1 id="并发-Concurrent-和并行-Parallel"><a href="#并发-Concurrent-和并行-Parallel" class="headerlink" title="并发 (Concurrent) 和并行 (Parallel)"></a>并发 (Concurrent) 和并行 (Parallel)</h1><p>并发和并行的主要区别是实际执行代码的物理部件 (也就是 CPU) 的数量是不一样的.</p><p>并发是指在一个 CPU 上分时执行多个任务. 这样做的好处是:</p><ul><li>能同时执行多个任务; 以前电脑只有一个 CPU 的时候, 就是通过并发来实现同时打开多个程序; 当 CPU 的运算速度足够快时, 用户就感觉好像是这些程序在同时运行;</li><li>当某些任务因为 IO 或网络访问被阻塞时, 可以执行别的计算密集型任务; 这样可以提高程序的执行效率, 提高 CPU 的利用率;</li></ul><p>和并发相对应, 并行就是指多个任务同时跑在不同的 CPU 上; 并行是真正的多任务执行, 在正确地设计及编程下, 能成倍地提高程序的执行效率.</p><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>进程和线程都是由操作系统来负责调度的, 操作系统正是通过他们来对任务进行抽象, 并调度到 CPU 上执行的.</p><p>线程的出现是因为进程存在以下缺点:</p><ul><li>不同进程的切换开销很高;</li><li>不同进程间的数据共享很困难;</li></ul><p>相比于进程:</p><ul><li>线程切换开销更小; 只需要更改 CPU 寄存器及线程堆栈这些上下文信息, 不需要更改页表等信息;</li><li>同一进程下的不同线程的内存是共享的, 方便了数据的共享; 因为没有切换内存页表信息, 所有的线程看到的内存都是一样的;</li></ul><p>不同于进程之间的资源是隔离的, 一个进程的崩溃不会影响另外一个进程; 线程共享了很多资源, 同一个进程下的某个线程崩溃, 可能会导致这个进程内的其它线程的崩溃.</p><h2 id="用户级线程和内核级线程"><a href="#用户级线程和内核级线程" class="headerlink" title="用户级线程和内核级线程"></a>用户级线程和内核级线程</h2><p>基于是在用户程序中还是在内核中实现对线程的支持, 可以把线程分为用户级线程和内核级线程, 这两种线程的主要区别是:</p><ul><li>内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。</li><li>用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。</li><li>用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。</li><li>在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。</li><li>用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。</li></ul><p><a href="http://blog.csdn.net/gatieme/article/details/51892437" rel="external nofollow noopener noreferrer" target="_blank">这篇文章</a>中会有更详细的介绍.</p><h2 id="Linux-中的轻量级进程-Light-Weight"><a href="#Linux-中的轻量级进程-Light-Weight" class="headerlink" title="Linux 中的轻量级进程 (Light Weight)"></a>Linux 中的轻量级进程 (Light Weight)</h2><p>linux 内核不存在整真正意义上的线程. linux将所有的执行实体都称之为任务 (task), 每一个任务都类似于一个单线程的进程, 具有内存空间、执行实体、文件资源等. 但 Linux 下不同任务之间可以选择公用内存空间, 因而在实际意义上, 共享同一个内存空间的多个任务构成了一个进程, 而这些任务就成为这个任务里面的轻量级进程.</p><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程其实就是轻量级的用户级线程, 一般直接由编程语言的 runtime 来实现协程的创建、调度等, 内核无法感知协程的存在.</p><p>goroutine 通过 G-P-M 模型提高了协程的并行性, 防止单个协程阻塞时影响整个进程的运行.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://wangdashuaihenshuai.github.io/2015/10/17/%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E5%9B%9E%E8%B0%83/" rel="external nofollow noopener noreferrer" target="_blank">编程中的进程、线程、协程、同步、异步、回调</a></li><li><a href="https://studygolang.com/articles/4964" rel="external nofollow noopener noreferrer" target="_blank">进程、线程、轻量级进程、协程</a></li><li><a href="http://blog.csdn.net/gatieme/article/details/51892437" rel="external nofollow noopener noreferrer" target="_blank">线程的3种实现方式–内核级线程, 用户级线程和混合型线程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文会简单介绍并行编程里经常会遇到的一些基本概念, 及这些不同概念之间的区别; 包括并发和并行; 进程, 线程及协程.&lt;/p&gt;
    
    </summary>
    
      <category term="Programing" scheme="https://hiberabyss.github.io/categories/programing/"/>
    
    
      <category term="parallel" scheme="https://hiberabyss.github.io/tags/parallel/"/>
    
      <category term="coroutine" scheme="https://hiberabyss.github.io/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>编程语言中的闭包</title>
    <link href="https://hiberabyss.github.io/2018/03/06/programming-closure/"/>
    <id>https://hiberabyss.github.io/2018/03/06/programming-closure/</id>
    <published>2018-03-06T16:11:13.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>闭包是现代的高级编程语言的一个重要概念, 本文会以 Golang 为例来介绍什么是闭包.</p><a id="more"></a><h1 id="什么是闭包-Closure"><a href="#什么是闭包-Closure" class="headerlink" title="什么是闭包 (Closure)"></a>什么是闭包 (Closure)</h1><p>在介绍闭包的定义之前, 我们先来看下闭包的示例代码:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greeting</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">data := <span class="string">"Hello "</span> + name</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> data &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sayHi := greeting(<span class="string">"hbliu"</span>)</span><br><span class="line">fmt.Println(sayHi())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// Hello hbliu</span></span><br></pre></td></tr></table></figure><p>这段代码就实现了闭包的效果: 虽然 <code>greating</code> 函数已经返回了, 但我们还可以访问到其内部的 <code>data</code> 局部变量. 下面是 <a href="https://coolshell.cn/articles/6731.html" rel="external nofollow noopener noreferrer" target="_blank">CoolShell</a> 对闭包的定义:</p><ul><li>闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。</li><li>闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配</li><li>当在一个函数内定义另外一个函数就会产生闭包</li></ul><p>在<a href="https://segmentfault.com/a/1190000000652891" rel="external nofollow noopener noreferrer" target="_blank">文章</a>中给了另外一个定义: 闭包是指有权访问另一个函数作用域中的变量的函数</p><p>访问函数内局部变量一般都是通过返回使用了函数局部变量的内部函数来实现的. 由此可见, 为了支持闭包, 编程语言需要提供一下两个特性:</p><ul><li>函数是 First Class Value, 即函数可以作为另一个函数的返回值或参数;</li><li>函数可以嵌套定义, 即可以在一个函数内部定义另外一个函数</li></ul><p>闭包和对象都是既有函数也有数据, 可以用一句话来表明他们的区别: <strong>对象是附有行为的数据，而闭包是附有数据的行为</strong></p><h1 id="闭包的优缺点"><a href="#闭包的优缺点" class="headerlink" title="闭包的优缺点"></a>闭包的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>闭包可以减少全局变量的个数;</li><li>保存闭包外面的变量状态; 下面是一个示例:</li></ol><p>下面的代买要用 goroutine 来打印一个 slice. 使用闭包前:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            fmt.Println(n)</span><br><span class="line">        &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// resutl:</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>可以发现结果都是 3 , 这是因为 goroutine 用的都是同一个变量 <code>n</code>.</p><p>我们可以使用闭包来避免这个问题:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package main provides ...</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> arr &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">backup := n</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(backup)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://coolshell.cn/articles/6731.html" rel="external nofollow noopener noreferrer" target="_blank">理解JAVASCRIPT的闭包</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-closure/#note_1" rel="external nofollow noopener noreferrer" target="_blank">闭包的概念、形式与应用</a></li><li><a href="https://pengweifu.github.io/2014/11/22/Js-Closure.html" rel="external nofollow noopener noreferrer" target="_blank">函数闭包的优势和特点</a></li><li><a href="https://segmentfault.com/a/1190000000652891" rel="external nofollow noopener noreferrer" target="_blank">详解js闭包</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闭包是现代的高级编程语言的一个重要概念, 本文会以 Golang 为例来介绍什么是闭包.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://hiberabyss.github.io/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>Git：在 merge 的时候忽略特定的文件</title>
    <link href="https://hiberabyss.github.io/2018/03/03/git-ignore-specific-file/"/>
    <id>https://hiberabyss.github.io/2018/03/03/git-ignore-specific-file/</id>
    <published>2018-03-03T22:06:53.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>有时当我们 merge 别的分支到当前分支时, 希望当前分支的某个文件能保持不变. 例如在更新 Hexo 主题时保证 <code>_config.yml</code> 文件不变, 以减少合并冲突的产生. 本文会介绍如何通过 gitattributes 来实现这个目标.</p><a id="more"></a><h1 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h1><p>首先需要添加一个 merge driver:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global merge.ours.driver <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后在项目的根目录下添加一个文件 <code>.gitattributes</code> , 在文件里添加需要被忽略的文件:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_config.yml merge=ours</span><br></pre></td></tr></table></figure><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><script src="https://asciinema.org/a/6KLaDnj58eB7CQ6BDWPqY9udv.js" id="asciicast-6KLaDnj58eB7CQ6BDWPqY9udv" async></script><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>在 <code>.gitattributes</code> 里可以设置文件的 merge driver, 我们先是添加了一个名叫 <code>ours</code> 的 merge driver, 这个 driver 被设定为 <code>true</code> , 也就是使用这个 merge driver 的文件在 merge 的时候什么都不会做, 也就会保持不变.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://medium.com/@porteneuve/how-to-make-git-preserve-specific-files-while-merging-18c92343826b" rel="external nofollow noopener noreferrer" target="_blank">How to make Git preserve specific files while merging</a></li><li><a href="https://git-scm.com/docs/gitattributes#gitattributes-text" rel="external nofollow noopener noreferrer" target="_blank">gitattributes</a></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/03/28/git-internal/">「Git」底层存储原理详解</a></li><li><a href="https://hiberabyss.github.io/2017/03/21/git-amend-commits/">Git Tips：修改 commits</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时当我们 merge 别的分支到当前分支时, 希望当前分支的某个文件能保持不变. 例如在更新 Hexo 主题时保证 &lt;code&gt;_config.yml&lt;/code&gt; 文件不变, 以减少合并冲突的产生. 本文会介绍如何通过 gitattributes 来实现这个目标.&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://hiberabyss.github.io/categories/git/"/>
    
    
      <category term="Git" scheme="https://hiberabyss.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>区块链常见共识算法</title>
    <link href="https://hiberabyss.github.io/2018/03/01/blockchain-consensus/"/>
    <id>https://hiberabyss.github.io/2018/03/01/blockchain-consensus/</id>
    <published>2018-03-01T16:58:34.000Z</published>
    <updated>2021-02-10T07:01:06.352Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍现有区块链技术里常见的共识算法: PoW, PoS, DPoS 等.</p><a id="more"></a><p>区块链本质上讲是一个去中心化的分布式账本, 会同时存在多个节点往这个账本里写数据. 由于整个系统所有节点都是平等的, 不存在中心节点, 就会存在下面的问题:</p><ul><li>当多个节点同时往区块链中添加数据时, 应该选择那部分数据写入到最终的区块链中</li></ul><p>PoW 等共识算法就是解决这个问题的方案.</p><h1 id="PoW-Proof-of-Work"><a href="#PoW-Proof-of-Work" class="headerlink" title="PoW (Proof of Work)"></a>PoW (Proof of Work)</h1><p>PoW 对节点提交的区块 B 的格式有如下的要求:</p><p>$$ H(B) \le target $$</p><p>其中 H 是某种 hash 算法, target 是一个固定的数. 也就是说整个区块的 hash 值要小于某个给定的数 target. 只有当区块满足这个条件时才是一个合法的区块, 这个区块才能够被别的节点接受. 而当某个节点找到了这样的合法的区块, 也就是挖到了矿, 会获得一定的数字货币奖励. 这也就解决了无中心多节点的结果决策问题: 整个网络采用最早找到合法区块的节点的数据.</p><p>哈希函数产生的 hash 值是随机的, 而且对原始数据一个很小的改动就能使得 hash 值和之前完全不一样. 为了能得到一个合法的区块, 我们可以往区块里添加一个冗余的整数 nonce, 通过不断地尝试不同的 nonce 来找到合法的区块 (例如可以从 1 开始不断地累加尝试).</p><p>target 的值每隔一段时间就会自动调整, 以保证产生区块的时间是基本固定的, 如比特币会保证每十分钟产生一个新的区块. 当 target 的值越小时, 产生区块的难度就越大. 假定 hash 值的最大值是 $ HASH_{max} $ , 则每一次尝试能找到合法区块的概率为 $ \frac{target}{HASH_{max}} $ . 从这个公式可以看出 target 越小, 每次尝试能找到合法区块的概率也越小.</p><p>在比特币中每过 2016 个块 (两周) 便会调整一下 target 的值, 通过下面的公式进行调整:</p><p>$$ target_{new} = \frac{t_{2016}}{2weeks} * target $$</p><p>其中 $t_2016$ 表示生成前面 2016 个块所花费的时间. 当花费的时间越短, 最终的 target 值也就越小. 生成块的难度值也可以通过下面的公式得出:</p><p>$$ difficulty = \frac{target_1}{current_{target}} $$</p><p>其中 $target_1$ 表示的是区块链中第一个块 (创世块) 的 target 值, 也是最大的 target 值. 它的值是 <code>0x00000000ffff0000000000000000000000000000000000000000000000000000</code></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>安全, 完全的去中心化, 主流的数字币都采用了这种方案; 如 BTC，LTC</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>效率低, 平均每秒只能处理 5 到 7 个交易;</li><li>会耗费大量电力;</li></ul><h1 id="PoS-Proof-of-Stake"><a href="#PoS-Proof-of-Stake" class="headerlink" title="PoS (Proof of Stake)"></a>PoS (Proof of Stake)</h1><p>在 PoW 中找到一个合法的区块需要进行大量的计算, 会花费大量的电力和时间. 为了加快生成区块的速度, PoS 中还会综合考虑节点所持有的数字币的份额. PoS 存在很多不同的实现方法, 其中一种混合模式会利用账户余额来调整挖矿难度:</p><p>$$ H(B, t) \le balance * target $$</p><p>其中 balance 表示账户余额, t 是一个时间戳, 一般对 t 会有一个时间范围的限制, 例如一个小时, 也就是一个节点最多只能尝试 7200 次.</p><p>还有另外一种 PoS 算法, 摘抄自<a href="http://blog.csdn.net/lsttoy/article/details/61624287" rel="external nofollow noopener noreferrer" target="_blank">这篇文章</a> :</p><blockquote><p>POS：也称股权证明，类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。 简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。</p></blockquote><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><ul><li>提高了处理效率; 基于 PoS 的 Ethereum 每秒大概能处理 30 笔交易左右.</li></ul><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ul><li>没有 PoW 安全, 容易遭受各种攻击; <a href="https://daimajia.com/2017/09/14/pow-and-pos" rel="external nofollow noopener noreferrer" target="_blank">这篇博客</a> 有详细介绍</li></ul><h1 id="DPoS-Delegated-Proof-of-Stake"><a href="#DPoS-Delegated-Proof-of-Stake" class="headerlink" title="DPoS (Delegated Proof of Stake)"></a>DPoS (Delegated Proof of Stake)</h1><p>DPoS 会通过不同的策略在不同的时间通过投票产生一小群节点, 由这些节点来负责新区块的创建、验证和相互监督. DPoS 和 PoS 的主要区别在于前者会选出若干代理人, 由代理人来完成记账.</p><h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><ul><li>提高了处理效率; 如基于 DPoS 的 EOS 能达到每秒几十万的交易数量</li><li>能够对网络进行一定的干预, 减少分叉的出现</li></ul><h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><ul><li>牺牲了部分去中心化</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://daimajia.com/2017/09/14/pow-and-pos" rel="external nofollow noopener noreferrer" target="_blank">PoW，PoS，DPoS 综述</a></li><li><a href="https://draveness.me/consensus" rel="external nofollow noopener noreferrer" target="_blank">分布式一致性与共识算法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍现有区块链技术里常见的共识算法: PoW, PoS, DPoS 等.&lt;/p&gt;
    
    </summary>
    
      <category term="blockchain" scheme="https://hiberabyss.github.io/categories/blockchain/"/>
    
    
      <category term="blockchain" scheme="https://hiberabyss.github.io/tags/blockchain/"/>
    
  </entry>
  
  <entry>
    <title>基于 neovim 终端集成 gdb</title>
    <link href="https://hiberabyss.github.io/2018/02/28/neovim-gdb-integration/"/>
    <id>https://hiberabyss.github.io/2018/02/28/neovim-gdb-integration/</id>
    <published>2018-02-28T11:17:35.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>相比于 IDE, 当使用 VIM 作为编辑器时, 调试会显得很麻烦. 借助于 neovim 的终端, 我们可以在 VIM 中实现类似 IDE 的编辑调试功能: 在 VIM 编辑窗口中按特定的快捷键即可执行特定的调试命令, 同时在 VIM 窗口中也能显示当前的 断电及程序执行的位置.</p><a id="more"></a><h1 id="Requirement"><a href="#Requirement" class="headerlink" title="Requirement"></a>Requirement</h1><ul><li>Neovim</li><li>gdb (C, C++);</li><li>delve (golang); 可通过 <code>go get -u github.com/derekparker/delve/cmd/dlv</code> 安装</li></ul><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a><a href="https://asciinema.org/a/dT2652AAwegDo0o0gWKsGOo1W" rel="external nofollow noopener noreferrer" target="_blank">演示</a></h1><p>安装 VIM 插件 <a href="https://github.com/hiberabyss/NeovimGdb" rel="external nofollow noopener noreferrer" target="_blank">NeovimGDB</a></p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">"https://github.com/hiberabyss/NeovimGdb"</span></span><br></pre></td></tr></table></figure><p>然后便可实现如下的效果:</p><script src="https://asciinema.org/a/dT2652AAwegDo0o0gWKsGOo1W.js" id="asciicast-dT2652AAwegDo0o0gWKsGOo1W" async></script><p>其中的主要操作步骤包括:</p><ol><li>执行 GdbLocal 命令进入 GDB 模式;</li><li>按快捷键 <code>;b</code> 设置断点 (再次按这个快捷键可以取消断点)</li><li>按 <code>;r</code> 开始执行程序;</li><li>按 <code>;n</code> 执行到下一行;</li><li>按 <code>;p</code> 打印光标下的变量;</li><li>按 <code>;gk</code> 退出 GDB 模式</li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li>对于 C, C++ 类型文件, 可以通过 <code>GdbLocal</code> 启动调试窗口 (或通过默认按键映射 <code>,rd</code>);</li><li>对于 go 类型文件, 可以通过 <code>GoDebug</code> 启动调试窗口;</li><li>可以调用命令 <code>GdbDebugStop</code> 来停止调试 (默认按键映射为 <code>;gk</code>);</li></ul><p>我们可以直接在调试窗口中输入调试命令, 也可以通过下列按键映射从代码窗口往调试窗口发送命令:</p><ul><li><code>;r</code> 发送 r</li><li><code>;c</code> 发送 c</li><li><code>;b</code> 发送 b</li><li><code>;n</code> 发送 n</li><li><code>;p</code> 发送 p word_under_cursor</li><li><code>;u</code> 发送 u</li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/04/04/gdb-internal/">GDB 实现原理介绍</a></li><li><a href="https://hiberabyss.github.io/2017/11/16/vim-word-completion/">【Neovim】基于自定义 keyword 的自动补全</a></li><li><a href="https://hiberabyss.github.io/2017/11/15/neovim-neoterm/">【VIM】neovim 下的 neoterm 插件的一些改进</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相比于 IDE, 当使用 VIM 作为编辑器时, 调试会显得很麻烦. 借助于 neovim 的终端, 我们可以在 VIM 中实现类似 IDE 的编辑调试功能: 在 VIM 编辑窗口中按特定的快捷键即可执行特定的调试命令, 同时在 VIM 窗口中也能显示当前的 断电及程序执行的位置.&lt;/p&gt;
    
    </summary>
    
      <category term="Vim" scheme="https://hiberabyss.github.io/categories/vim/"/>
    
    
      <category term="Gdb" scheme="https://hiberabyss.github.io/tags/gdb/"/>
    
      <category term="Neovim" scheme="https://hiberabyss.github.io/tags/neovim/"/>
    
  </entry>
  
  <entry>
    <title>「VIM」基于项目的 VIM 配置</title>
    <link href="https://hiberabyss.github.io/2018/02/28/vim-project-configuration/"/>
    <id>https://hiberabyss.github.io/2018/02/28/vim-project-configuration/</id>
    <published>2018-02-28T11:04:17.000Z</published>
    <updated>2021-02-10T07:01:06.372Z</updated>
    
    <content type="html"><![CDATA[<p>有时在特定的项目中我们需要有特定的 VIM 配置, 这些配置和全局配置是不一致的 或者这个配置是只在这个项目中才能生效的, 我们可以借助插件 <a href="https://github.com/hiberabyss/ProjectConfig" rel="external nofollow noopener noreferrer" target="_blank">PorjectConfig</a> 来实现 Per Project 的 VIM 配置.</p><a id="more"></a><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><script src="https://asciinema.org/a/xBJ9avbKQDoPiypawPLYUdg5s.js" id="asciicast-xBJ9avbKQDoPiypawPLYUdg5s" async></script><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>利用 vim-plug 安装:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/hiberabyss/ProjectConfig'</span></span><br></pre></td></tr></table></figure><p>我们便可直接调用 VIM 命令 <code>ProjectConfig</code> 来添加当前项目的配置:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1519787607268.png" width="570"></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>ProjectConfig 插件会基于 <code>.git</code> <code>.hg</code> 等特殊文件夹来识别当前项目的根目录, 再在这些文件夹内 保存 VIM 配置文件 <code>project_config</code> , 当 VIM 启动时如果检查到这个文件的存在, 便会自动加载它.</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2020/05/06/vim-open-saz-file/">使用 Vim 查看 Fiddler 生成的 saz 格式 session 包</a></li><li><a href="https://hiberabyss.github.io/2018/05/03/add-async-support-for-vim-plugin/">给 Vim 插件添加上异步调用的功能</a></li><li><a href="https://hiberabyss.github.io/2018/04/24/vim-plug-rest-console/">实现类 Postman 功能的 VIM 插件</a></li><li><a href="https://hiberabyss.github.io/2018/04/13/vim-file-jumper/">Vim 文件快速跳转插件</a></li><li><a href="https://hiberabyss.github.io/2018/03/21/vim-plug-introduction/">VIM 插件管理工具 vim-plug 简明教程</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时在特定的项目中我们需要有特定的 VIM 配置, 这些配置和全局配置是不一致的 或者这个配置是只在这个项目中才能生效的, 我们可以借助插件 &lt;a href=&quot;https://github.com/hiberabyss/ProjectConfig&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;PorjectConfig&lt;/a&gt; 来实现 Per Project 的 VIM 配置.&lt;/p&gt;
    
    </summary>
    
      <category term="Vim" scheme="https://hiberabyss.github.io/categories/vim/"/>
    
    
      <category term="Vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>「Docker」网络调试的一个小技巧</title>
    <link href="https://hiberabyss.github.io/2018/02/07/docker-network-debug/"/>
    <id>https://hiberabyss.github.io/2018/02/07/docker-network-debug/</id>
    <published>2018-02-07T11:28:28.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>有时当容器地网络出现问题时需要我们利用一些命令进行调试, 但容器内部却没有安装这些调试工具; 这时我们可以新建一个容器, 让它和之前的容器共享同一个 Network Namespace , 这样我们便可以在新容器中调试之前容器地网络问题了.</p><a id="more"></a><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>当我们启动 nginx 容器, 想检查容器中的 80 端口是否开启时会发现没有对应地命令:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ docker run --name nginx -d nginx</span><br><span class="line">dce80ba20d033e32195afb92ee4c794aa248066c52fb5c78c6bb452927ed57cb</span><br><span class="line">[ec2-user@ip-10-24-254-11 ~]$ docker exec -it nginx bash</span><br><span class="line">root@dce80ba20d03:/# nc -zv localhost 80</span><br><span class="line">bash: nc: command not found</span><br><span class="line">root@dce80ba20d03:/# wget -q -O- localhost:80</span><br><span class="line">bash: wget: command not found</span><br><span class="line">root@dce80ba20d03:/#</span><br></pre></td></tr></table></figure><p>这时我们可以基于容器 nginx 的 Network Namespace 启动一个新的容器:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ docker run --name debug -it -d --net container:nginx busybox</span><br><span class="line">af3abd9b1cb13b106e452cc97387b042f841ae16e5ad3ba1eaeccab98d0f6f96</span><br></pre></td></tr></table></figure><p>这时便可在新建的 debug 容器中调试之前容器的网络了:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ docker exec -it debug sh</span><br><span class="line">/ # nc -zv localhost 80</span><br><span class="line">localhost (127.0.0.1:80) open</span><br></pre></td></tr></table></figure><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/02/02/docker-bridge-network-practice/">自己动手实现 Docker bridge network</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时当容器地网络出现问题时需要我们利用一些命令进行调试, 但容器内部却没有安装这些调试工具; 这时我们可以新建一个容器, 让它和之前的容器共享同一个 Network Namespace , 这样我们便可以在新容器中调试之前容器地网络问题了.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://hiberabyss.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>自己动手实现 Docker bridge network</title>
    <link href="https://hiberabyss.github.io/2018/02/02/docker-bridge-network-practice/"/>
    <id>https://hiberabyss.github.io/2018/02/02/docker-bridge-network-practice/</id>
    <published>2018-02-02T16:45:19.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>最近详细了解了 Docker 的网桥网络的工作原理, 便想一步一步地实现 Docker 地网桥网络.</p><a id="more"></a><h1 id="Docker-网桥网络工作原理"><a href="#Docker-网桥网络工作原理" class="headerlink" title="Docker 网桥网络工作原理"></a>Docker 网桥网络工作原理</h1><p>Docker 的网络实现主要会用到以下功能:</p><ul><li>Network Namespace: 用于隔离容器和宿主机之间地网络;</li><li>Veth 设备对: 用于连接宿主机和容器, 每个容器都会有一对 Veth 设备, 一个在容器内, 一个在宿主机内;</li><li>网桥: 通过网桥可以很方便地管理宿主机上的多个 veth 设备, 同时实现不同容器之间地互联;</li><li>Iptables/NetFilter: SNAT 以实现容器内对外网的访问; 实现容器地端口映射等;</li><li>路由</li></ul><p>详细原理如下图所示 (转自这篇<a href="https://draveness.me/docker" rel="external nofollow noopener noreferrer" target="_blank">博客</a>):</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1517801503362.png" width="473"></p><h1 id="创建-Network-Namespace"><a href="#创建-Network-Namespace" class="headerlink" title="创建 Network Namespace"></a>创建 Network Namespace</h1><p>通过命令 <code>sudo ip netns add ns1</code> 即可创建名为 ns1 的 network namespace, 我们可以通过下面地命令查看当前系统中已有的 network namespace:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo ls -1 /var/run/netns</span><br><span class="line">ns1</span><br></pre></td></tr></table></figure><p>Note: 我们可以通过命令 <code>sudo ip netns del ns1</code> 来删除之前创建地 network namespace.</p><h1 id="创建-veth-设备对"><a href="#创建-veth-设备对" class="headerlink" title="创建 veth 设备对"></a>创建 veth 设备对</h1><p>通过下面的命令创建:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo ip link add veth0 <span class="built_in">type</span> veth peer name veth1</span><br><span class="line"></span><br><span class="line">[ec2-user@ip-10-24-254-11 ~]$ ip addr show | grep veth</span><br><span class="line">311: veth1@veth0: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">312: veth0@veth1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br></pre></td></tr></table></figure><p>我们把 veth1 移动到 ns1 namespace 里: <code>sudo ip link set veth1 netns ns1</code>. 现在我们在宿主机中就看不到 veth1 了:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ ip addr show | grep veth</span><br><span class="line">312: veth0@if311: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br></pre></td></tr></table></figure><p>当我们切换到 ns1 就可以查看到 veth1 了:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo ip netns exec ns1 bash</span><br><span class="line"></span><br><span class="line">[root@ip-10-24-254-11 ec2-user]# ip addr show</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">311: veth1@if312: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether 3e:a0:ce:a7:8f:4c brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure><p>Note: 可以通过 <code>sudo ip del link veth0</code> 来删除这个设备对.</p><h1 id="创建网桥并实现-veth1-和宿主机的互联"><a href="#创建网桥并实现-veth1-和宿主机的互联" class="headerlink" title="创建网桥并实现 veth1 和宿主机的互联"></a>创建网桥并实现 veth1 和宿主机的互联</h1><p>我们在系统默认 namespace 创建网桥 <code>br-demo</code>, 并将 veth0 加入到网桥中:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo brctl addbr br-demo</span><br><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo brctl addif br-demo veth0</span><br><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo brctl show | grep <span class="string">'br-demo'</span></span><br><span class="line">br-demo         8000.0aa51a826228       no              veth0</span><br></pre></td></tr></table></figure><p>我们给网桥添加 ip 地址: <code>sudo ifconfig br-demo 172.8.0.1</code>. 同时启动 veth0 <code>sudo ip link set dev veth0 up</code>. 再登录进 ns1 namespace 给 veth1 设置 ip 地址:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@ip-10-24-254-11 ec2-user]# ifconfig veth1 172.8.0.8</span><br><span class="line">[root@ip-10-24-254-11 ec2-user]# ifconfig veth1 172.8.0.8</span><br></pre></td></tr></table></figure><p>这时我们便可以 ping 通 br-demo 的地址了:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@ip-10-24-254-11 ec2-user]# ping -c 1 172.8.0.1</span><br><span class="line">PING 172.8.0.1 (172.8.0.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.8.0.1: icmp_seq=1 ttl=255 time=0.044 ms</span><br></pre></td></tr></table></figure><h1 id="给-veth1-添加外网访问"><a href="#给-veth1-添加外网访问" class="headerlink" title="给 veth1 添加外网访问"></a>给 veth1 添加外网访问</h1><p>在宿主机上编辑 iptables , 添加以下规则:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo iptables -t filter -A FORWARD -i br-demo ! -o br-demo -j ACCEPT</span><br><span class="line">sudo iptables -t filter -A FORWARD -i br-demo -o br-demo -j ACCEPT</span><br><span class="line">sudo iptables -t filter -A FORWARD -o br-demo -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">sudo iptables -t nat -A POSTROUTING -s 172.8.0.0/16 ! -o br-demo -j MASQUERADE</span><br></pre></td></tr></table></figure><p>在 ns1 namespace 里测试是否可以连通外网:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@ip-10-24-254-11 ec2-user]# ping baidu.com -c1</span><br><span class="line">PING baidu.com (111.13.101.208) 56(84) bytes of data.</span><br><span class="line">64 bytes from 111.13.101.208: icmp_seq=1 ttl=39 time=258 ms</span><br></pre></td></tr></table></figure><h1 id="映射-ns1-内部端口到宿主机"><a href="#映射-ns1-内部端口到宿主机" class="headerlink" title="映射 ns1 内部端口到宿主机"></a>映射 ns1 内部端口到宿主机</h1><p>我们现在 ns1 内部通过 python 启动一个简单地 http server:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@ip-10-24-254-11 ec2-user]# python -m SimpleHTTPServer</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 ...</span><br></pre></td></tr></table></figure><p>在宿主机上我们可以通过 veth1 的 ip 地址访问这个服务:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ curl -I 172.8.0.8:8000</span><br><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Server: SimpleHTTP/0.6 Python/2.7.12</span><br><span class="line">Date: Mon, 05 Feb 2018 05:54:10 GMT</span><br><span class="line">Content-type: text/html; charset=UTF-8</span><br><span class="line">Content-Length: 1718</span><br></pre></td></tr></table></figure><h2 id="从别的机器直接访问宿主机映射后的端口"><a href="#从别的机器直接访问宿主机映射后的端口" class="headerlink" title="从别的机器直接访问宿主机映射后的端口"></a>从别的机器直接访问宿主机映射后的端口</h2><p>把下面地规则加入到 iptalbe 里, 我们便可以通过宿主机的 8088 端口访问到这个 service 了:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo iptables -t nat -A PREROUTING -p tcp -m tcp --dport 8088 -j DNAT --to-destination 172.8.0.8:8000</span><br><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo iptables -t filter -A FORWARD -p tcp -m tcp --dport 8000 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="comment"># need to be in another machine</span></span><br><span class="line">centos@ip-10-24-255-93:~ · 09:50 AM Mon Feb 05 ·</span><br><span class="line">!56 $ curl -I 10.24.254.11:8088</span><br><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Server: SimpleHTTP/0.6 Python/2.7.12</span><br><span class="line">Date: Mon, 05 Feb 2018 09:51:40 GMT</span><br><span class="line">Content-type: text/html; charset=UTF-8</span><br><span class="line">Content-Length: 1718</span><br></pre></td></tr></table></figure><p>注意这里必须要在别地机器上访问宿主机的 8088 端口!</p><h2 id="直接在宿主机上访问映射后的端口"><a href="#直接在宿主机上访问映射后的端口" class="headerlink" title="直接在宿主机上访问映射后的端口"></a>直接在宿主机上访问映射后的端口</h2><p>添加如下两条 iptables 规则后即可直接在本机地址上访问:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo iptables -t nat -A OUTPUT -p tcp -m tcp --dport 8088 -j DNAT --to-destination 172.8.0.8:8000</span><br><span class="line">[ec2-user@ip-10-24-254-11 ~]$ sudo iptables -t nat -A POSTROUTING -p tcp -m tcp --dport 8000 -j MASQUERADE</span><br><span class="line"></span><br><span class="line">[ec2-user@ip-10-24-254-11 ~]$ curl -I 127.0.0.1:8088</span><br><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Server: SimpleHTTP/0.6 Python/2.7.12</span><br><span class="line">Date: Tue, 06 Feb 2018 02:33:42 GMT</span><br><span class="line">Content-type: text/html; charset=UTF-8</span><br><span class="line">Content-Length: 1718</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://draveness.me/docker" rel="external nofollow noopener noreferrer" target="_blank">Docker 核心技术与实现原理</a></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/02/07/docker-network-debug/">「Docker」网络调试的一个小技巧</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近详细了解了 Docker 的网桥网络的工作原理, 便想一步一步地实现 Docker 地网桥网络.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://hiberabyss.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>利用 kops 在 AWS 上创建 K8S 集群</title>
    <link href="https://hiberabyss.github.io/2018/02/02/create-k8s-cluster-on-aws-via-kops/"/>
    <id>https://hiberabyss.github.io/2018/02/02/create-k8s-cluster-on-aws-via-kops/</id>
    <published>2018-02-02T14:25:55.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>本文会介绍 kops 安装及使用, 如何创建 K8S 集群, 以及可能遇到的问题和解决方案.</p><a id="more"></a><h1 id="kops-的安装"><a href="#kops-的安装" class="headerlink" title="kops 的安装"></a>kops 的安装</h1><p><a href="https://github.com/kubernetes/kops" rel="external nofollow noopener noreferrer" target="_blank">kops</a> 是一个帮助在 AWS, Google Cloud 等云平台上创建 K8S 集群的工具. 可以通过如下命令安装:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -LO https://github.com/kubernetes/kops/releases/download/$(curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d <span class="string">'"'</span> -f 4)/kops-linux-amd64</span><br><span class="line">chmod +x kops-linux-amd64</span><br><span class="line">sudo mv kops-linux-amd64 /usr/<span class="built_in">local</span>/bin/kops</span><br></pre></td></tr></table></figure><h1 id="使用-kops-创建-K8S-集群"><a href="#使用-kops-创建-K8S-集群" class="headerlink" title="使用 kops 创建 K8S 集群"></a>使用 kops 创建 K8S 集群</h1><h2 id="创建-cluster"><a href="#创建-cluster" class="headerlink" title="创建 cluster"></a>创建 cluster</h2><p>执行下面的命令:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> NETWORKING=<span class="string">"flannel"</span></span><br><span class="line"><span class="built_in">export</span> CLUSTER_NAME=your-cluster-name.k8s.local</span><br><span class="line"><span class="built_in">export</span> VPC_ID=vpc-you-vpc-id</span><br><span class="line"></span><br><span class="line"><span class="comment"># need to create corresponding s3 bucket at first </span></span><br><span class="line"><span class="built_in">export</span> KOPS_STATE_STORE=s3://your-s3 bucket</span><br><span class="line"><span class="built_in">export</span> ZONES=<span class="string">"us-east-1c"</span></span><br><span class="line"></span><br><span class="line">kops create cluster --zones=<span class="variable">$ZONES</span> --name=<span class="variable">$CLUSTER_NAME</span> \</span><br><span class="line">                    --vpc=<span class="variable">$&#123;VPC_ID&#125;</span> --networking <span class="variable">$&#123;NETWORKING&#125;</span> \</span><br><span class="line">                    --node-count 1 --node-size t2.medium  --master-count 1 \</span><br><span class="line">                    --api-loadbalancer-type=internal --dns private \</span><br><span class="line">                    --master-size t2.medium --topology private --image ami-your-image-id</span><br></pre></td></tr></table></figure><h2 id="修改-subnets"><a href="#修改-subnets" class="headerlink" title="修改 subnets"></a>修改 subnets</h2><p>当通过上面的命令创建完 cluster 之后, 我们可能希望 kops 自己去创建 subnet , 而是使用我们 提前配置好的 subnet, 我们可以通过 <code>kops edit cluster your-cluster-name.k8s.local</code> 来编辑 subnets 字段:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">subnets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">subnet-your-id</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">us-east-1c</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">Private</span></span><br><span class="line">  <span class="attr">zone:</span> <span class="string">us-east-1c</span></span><br></pre></td></tr></table></figure><h2 id="启动我们创建的-cluster"><a href="#启动我们创建的-cluster" class="headerlink" title="启动我们创建的 cluster"></a>启动我们创建的 cluster</h2><p>我们需要通过 <code>kops update cluster your-cluster-name.k8s.local --yes</code> 来启动刚刚创建的 cluster.</p><p>这个步骤需要下面的 AWS 权限:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AmazonEC2FullAccess</span><br><span class="line">IAMFullAccess</span><br><span class="line">AmazonS3FullAccess</span><br><span class="line">AmazonVPCFullAccess</span><br></pre></td></tr></table></figure><p>我们可以通过有这些权限的账号来执行上面的命令, 或者在拥有这些权限的 EC2 (通过 IAM Role) 上执行.</p><h1 id="如何解决问题"><a href="#如何解决问题" class="headerlink" title="如何解决问题"></a>如何解决问题</h1><p>当执行完上面的步骤之后应该就可以成功地在 AWS 上创建一个 K8S 集群. 可以通过以下步骤去检查问题出现在哪里:</p><h2 id="检查-EC2-instances-有没有被成功创建"><a href="#检查-EC2-instances-有没有被成功创建" class="headerlink" title="检查 EC2 instances 有没有被成功创建"></a>检查 EC2 instances 有没有被成功创建</h2><p>如果没有对应的 EC2 被创建, 我们需要去 Auto Scaling Groups 里检查对应 Activity History :</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1517554624176.png" width="518"></p><p>可能的原因有:</p><ol><li>AMI image 需要被 Accepted;</li><li>没有可用的 Volume ;</li></ol><h2 id="EC2-成功创建但没法被-K8S-集群识别"><a href="#EC2-成功创建但没法被-K8S-集群识别" class="headerlink" title="EC2 成功创建但没法被 K8S 集群识别"></a>EC2 成功创建但没法被 K8S 集群识别</h2><p>这种情况一般是启动的 EC2 上的 <code>kubelet</code> 或 <code>kube-apiserver</code> 未被成功启动.</p><h3 id="master-节点未被成功识别"><a href="#master-节点未被成功识别" class="headerlink" title="master 节点未被成功识别"></a>master 节点未被成功识别</h3><p>如果 master 无法被正常识别, 我们可以取检查 Load Balancer (LB) 是不是有 instance 且状态是不是 <code>InService</code>:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1517554976973.png" width="878"></p><p>这个 LB 是通过检查 443 端口(一般是 kube-apiserver) 来判定服务是不是 InService , 如果这儿有问题, 一般是因为 <code>kube-apiserver</code> 未正常启动</p><h3 id="node-节点未被识别"><a href="#node-节点未被识别" class="headerlink" title="node 节点未被识别"></a>node 节点未被识别</h3><p>这种情况一般是 docker service 或者 kubelet 未被成功启动, 需要登录到对应的机器去检查原因. 可能的情况是 node 节点无法访问外网, 导致无法安装 kubelet 的包.</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/01/18/kubectl-tips/">一些实用的 kubectl 工具</a></li><li><a href="https://hiberabyss.github.io/2018/01/18/internet-access-with-nat-gateway/">【AWS】利用 NAT Gateway 给 EC2 增加外网访问</a></li><li><a href="https://hiberabyss.github.io/2018/01/14/setup-aws-cli/">配置 AWS CLI 工具</a></li><li><a href="https://hiberabyss.github.io/2017/11/23/aws-mfa-from-pc/">直接在电脑端获取 AWS 的 MFA code</a></li><li><a href="https://hiberabyss.github.io/2017/11/22/k8s-persistent-volume/">利用 AWS 的 EBS 为 kubernetes 集群添加持久化存储</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文会介绍 kops 安装及使用, 如何创建 K8S 集群, 以及可能遇到的问题和解决方案.&lt;/p&gt;
    
    </summary>
    
    
      <category term="AWS" scheme="https://hiberabyss.github.io/tags/aws/"/>
    
      <category term="kops" scheme="https://hiberabyss.github.io/tags/kops/"/>
    
      <category term="K8S" scheme="https://hiberabyss.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>直接在 vim 里编辑 iptables 规则</title>
    <link href="https://hiberabyss.github.io/2018/02/02/vim-iptables/"/>
    <id>https://hiberabyss.github.io/2018/02/02/vim-iptables/</id>
    <published>2018-02-02T13:53:52.000Z</published>
    <updated>2021-02-10T07:01:06.372Z</updated>
    
    <content type="html"><![CDATA[<p>这几天为了了解 K8S 的工作原理, 需要频繁地更改 iptables , 直接通过 <code>iptables -t nat -A ...</code> 去添加规则, 或者通过 <code>iptables -t nat -D ...</code> 去删除规则显得很繁琐. 其实我们可以利用 vim 的 autocmd 命令来直接编辑 iptables 并保存.</p><a id="more"></a><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>我们主要是通过 <code>sudo iptables-save</code> 来导出当前的 iptable 规则, 基于现有的规则做了一些修改之后, 可以通过 <code>sudo iptables-restore</code> 来导入我们修改之后的规则. 同时, 基于 vim 的 autocmd, 我们可以在用 <code>:e</code> 重载 buffer 时基于 <code>iptables-save</code> 来读取当前的 iptables 规则, 在用 <code>:w</code> 保存 buffer 时基于 <code>iptables-restore</code> 来将我们的修改保存到 iptable .</p><h1 id="读取当前-iptalbe-规则"><a href="#读取当前-iptalbe-规则" class="headerlink" title="读取当前 iptalbe 规则"></a>读取当前 iptalbe 规则</h1><p>首先, 我们将当前 iptable 规则导出到文件, 并用 vim 打开:</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo iptables-save &gt; iptables.txt</span><br><span class="line">vim iptables.txt</span><br></pre></td></tr></table></figure><p>再执行下面的 vim autocmd 命令:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">autocmd! bufread <span class="symbol">&lt;buffer&gt;</span> %d | <span class="number">0</span>r !sudo iptables-save</span><br></pre></td></tr></table></figure><p>这样, 当我们执行 <code>:e</code> 时就回自动获取当前系统中的 iptable 规则.</p><p>命令中的 <code>&lt;buffer&gt;</code> 表明这条 autocmd 只在当前 buffer 中生效.</p><h1 id="保存修改后的-iptable-规则"><a href="#保存修改后的-iptable-规则" class="headerlink" title="保存修改后的 iptable 规则"></a>保存修改后的 iptable 规则</h1><p>执行下面的 vim 命令:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">autocmd! bufwritepost <span class="symbol">&lt;buffer&gt;</span> %<span class="keyword">w</span> !sudo iptables-restore</span><br></pre></td></tr></table></figure><p>现在当我们在 vim 中执行 <code>:w</code> 来保存内容时, 当前 buffer 里的规则也会自动保存到 iptalbe 里.</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2020/05/06/vim-open-saz-file/">使用 Vim 查看 Fiddler 生成的 saz 格式 session 包</a></li><li><a href="https://hiberabyss.github.io/2018/05/03/add-async-support-for-vim-plugin/">给 Vim 插件添加上异步调用的功能</a></li><li><a href="https://hiberabyss.github.io/2018/04/24/vim-plug-rest-console/">实现类 Postman 功能的 VIM 插件</a></li><li><a href="https://hiberabyss.github.io/2018/04/13/vim-file-jumper/">Vim 文件快速跳转插件</a></li><li><a href="https://hiberabyss.github.io/2018/03/21/vim-plug-introduction/">VIM 插件管理工具 vim-plug 简明教程</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天为了了解 K8S 的工作原理, 需要频繁地更改 iptables , 直接通过 &lt;code&gt;iptables -t nat -A ...&lt;/code&gt; 去添加规则, 或者通过 &lt;code&gt;iptables -t nat -D ...&lt;/code&gt; 去删除规则显得很繁琐. 其实我们可以利用 vim 的 autocmd 命令来直接编辑 iptables 并保存.&lt;/p&gt;
    
    </summary>
    
      <category term="Vim" scheme="https://hiberabyss.github.io/categories/vim/"/>
    
    
      <category term="Vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
      <category term="iptables" scheme="https://hiberabyss.github.io/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>一些实用的 kubectl 工具</title>
    <link href="https://hiberabyss.github.io/2018/01/18/kubectl-tips/"/>
    <id>https://hiberabyss.github.io/2018/01/18/kubectl-tips/</id>
    <published>2018-01-18T15:01:46.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>使用 K8S 的话就需要经常用到 kubectl ，有一些实用的小工具能提高我们使用 kubectl 的效率。 我把这些小工具打包放在了 <a href="https://github.com/hiberabyss/k8s-tools" rel="external nofollow noopener noreferrer" target="_blank">github</a> 上。</p><p>执行下面的命令即可安装 (安装完后可能需要执行 <code>source ~/.bashrc</code> 或 <code>source ~/.zshrc</code>) :</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(wget -O- https://raw.githubusercontent.com/hiberabyss/k8s-tools/master/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><p>接下来会详细介绍安装完成后会包括哪些功能.</p><a id="more"></a><p>当安装文件检查到当前系统没有 <code>kubectl</code> 时, 会自动帮你安装它. 此外, 它还提供了以下几个工具：<code>kexe</code>, <code>kget</code>, <code>kns</code>, <code>kctx</code>。</p><h1 id="kexe"><a href="#kexe" class="headerlink" title="kexe"></a>kexe</h1><p>这个工具可以帮忙快速地进入 pod ：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ec2-user@ip-10-11-111-111 ~]$ kexe demo-5d8d688c78-qcs7p sh</span><br><span class="line">/ <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># using partial match</span></span><br><span class="line">➜  .dotfiles git:(master) kexe dns-806549836-krtrf sh -n kube-system</span><br><span class="line">Defaulting container name to kubedns.</span><br><span class="line">Use <span class="string">'kubectl describe pod/kube-dns-806549836-krtrf'</span> to see all of the containers <span class="keyword">in</span> this pod.</span><br><span class="line">/ <span class="comment"># %</span></span><br></pre></td></tr></table></figure><p>这个命令接收两个参数 ：</p><ul><li>第一个是 pod 名，可以部分匹配；</li><li>第二个是 shell 的类型，这个参数是可选项，默认是 bash 。</li></ul><p>更详细的使用方法可以查看 <code>kexe -h</code>.</p><h1 id="kget"><a href="#kget" class="headerlink" title="kget"></a>kget</h1><p>这个工具是对 <code>kubectl get</code> 的一个封装，但增加了模糊匹配的功能：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ec2-user@ip-10-24-254-11 ~]$ kget pod dns -a</span><br><span class="line">kube-system   dns-controller-5cbcd846f9-dg2kp                         1/1       Running   0          7d        10.24.255.153   ip-10-24-255-153.ec2.internal</span><br><span class="line">kube-system   kube-dns-7f56f9f8c7-7qjg2                               3/3       Running   0          3h        100.96.12.3     ip-10-24-255-251.ec2.internal</span><br><span class="line">kube-system   kube-dns-7f56f9f8c7-l5tvl                               3/3       Running   0          3h        100.96.11.4     ip-10-24-255-117.ec2.internal</span><br><span class="line">kube-system   kube-dns-autoscaler-f4c47db64-895rk                     1/1       Running   0          3h        100.96.12.4     ip-10-24-255-251.ec2.internal</span><br></pre></td></tr></table></figure><p>具体的使用方法可以查看 <code>kget -h</code></p><h1 id="kns"><a href="#kns" class="headerlink" title="kns"></a>kns</h1><p>这个命令可以用来方便地管理 k8s 的 namespaces ，直接执行 <code>kns</code> 可以显示当前所有的 namespaces ：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ec2-user@ip-10-24-111-153 ~]$ kns</span><br><span class="line">default</span><br><span class="line">kube-public</span><br><span class="line">kube-system</span><br></pre></td></tr></table></figure><p>执行 <code>kns namespace_name</code> 就可以直接切换到对应的 namespace 。</p><h1 id="kctx"><a href="#kctx" class="headerlink" title="kctx"></a>kctx</h1><p>kctx 的用法类似 kns ， 只不过它是用来管理 k8s context ：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ec2-user@ip-10-11-250-153 ~]$ kctx</span><br><span class="line">bchip2.k8s.local</span><br></pre></td></tr></table></figure><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/02/02/create-k8s-cluster-on-aws-via-kops/">利用 kops 在 AWS 上创建 K8S 集群</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 K8S 的话就需要经常用到 kubectl ，有一些实用的小工具能提高我们使用 kubectl 的效率。 我把这些小工具打包放在了 &lt;a href=&quot;https://github.com/hiberabyss/k8s-tools&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt; 上。&lt;/p&gt;&lt;p&gt;执行下面的命令即可安装 (安装完后可能需要执行 &lt;code&gt;source ~/.bashrc&lt;/code&gt; 或 &lt;code&gt;source ~/.zshrc&lt;/code&gt;) :&lt;/p&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sh -c &lt;span class=&quot;string&quot;&gt;&quot;&lt;span class=&quot;variable&quot;&gt;$(wget -O- https://raw.githubusercontent.com/hiberabyss/k8s-tools/master/install.sh)&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;接下来会详细介绍安装完成后会包括哪些功能.&lt;/p&gt;
    
    </summary>
    
    
      <category term="K8S" scheme="https://hiberabyss.github.io/tags/k8s/"/>
    
      <category term="kubectl" scheme="https://hiberabyss.github.io/tags/kubectl/"/>
    
  </entry>
  
  <entry>
    <title>【AWS】利用 NAT Gateway 给 EC2 增加外网访问</title>
    <link href="https://hiberabyss.github.io/2018/01/18/internet-access-with-nat-gateway/"/>
    <id>https://hiberabyss.github.io/2018/01/18/internet-access-with-nat-gateway/</id>
    <published>2018-01-18T10:17:48.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>默认在 AWS 上让一个 EC2 能访问外网需要它有一个 Public IP ， 但 Public IP 是很有限的资源，我们可以利用 NAT Gateway 来通过一个 Public IP 实现多台 EC2 的外网访问。</p><a id="more"></a><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>NAT Gateway 会绑定到某个 subnet(属于某个 VPC) 上，这个 subnet 需要是一个 Public Subnet ， 也就是这个 subnet 的 route table 上需要有类似如下的配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.0.0.0/0 igw-66666666</span><br></pre></td></tr></table></figure><p>上面的配置表示这个 subnet 的默认流量会通过 Internet Gateway <code>igw-66666666</code> 出去。</p><p>为了实现 Private subnet 里的 EC2 通过 NAT Gateway 访问外网，我们需要有如下的配置：</p><ol><li>一个 Public Subnet：net1；Route Table 上配置了对应的Internet Gateway；</li><li>一个 Private Subnet：net2；net2 需要和 net1 在同一个 VPC 下，如果他们俩没法直接互联，可能是 subnet 上的 ACL 的设置问题；</li><li>一个 NAT Gateway：需要创建在 net1 内。</li></ol><h1 id="创建-NAT-Gateway"><a href="#创建-NAT-Gateway" class="headerlink" title="创建 NAT Gateway"></a>创建 NAT Gateway</h1><p>选择 VPC Dashboard，点击 Create NAT Gateway，再在新的界面里选择一个 Public Subnet 即可：</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1516245513504.png" width="536"></p><h1 id="配置-Private-Subnet-的-Route-Table"><a href="#配置-Private-Subnet-的-Route-Table" class="headerlink" title="配置 Private Subnet 的 Route Table"></a>配置 Private Subnet 的 Route Table</h1><p>选中对应的 Private Subnet 界面，在下面的界面中点中 Route Table ，把默认网关改成我们创建的 NAT Gateway 即可。注意这里的 Route Table 不能和 Public Subnet 的 Route Table 一样。</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1516247418560.png" width="607"></p><h1 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h1><p>如果配置中间出现问题可以参看 <a href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-nat-gateway.html#nat-gateway-troubleshooting" rel="external nofollow noopener noreferrer" target="_blank">AWS 官方文档</a> 进行调试。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/02/02/create-k8s-cluster-on-aws-via-kops/">利用 kops 在 AWS 上创建 K8S 集群</a></li><li><a href="https://hiberabyss.github.io/2018/01/14/setup-aws-cli/">配置 AWS CLI 工具</a></li><li><a href="https://hiberabyss.github.io/2017/11/23/aws-mfa-from-pc/">直接在电脑端获取 AWS 的 MFA code</a></li><li><a href="https://hiberabyss.github.io/2017/11/22/k8s-persistent-volume/">利用 AWS 的 EBS 为 kubernetes 集群添加持久化存储</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;默认在 AWS 上让一个 EC2 能访问外网需要它有一个 Public IP ， 但 Public IP 是很有限的资源，我们可以利用 NAT Gateway 来通过一个 Public IP 实现多台 EC2 的外网访问。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AWS" scheme="https://hiberabyss.github.io/tags/aws/"/>
    
  </entry>
  
  <entry>
    <title>配置 AWS CLI 工具</title>
    <link href="https://hiberabyss.github.io/2018/01/14/setup-aws-cli/"/>
    <id>https://hiberabyss.github.io/2018/01/14/setup-aws-cli/</id>
    <published>2018-01-14T23:43:04.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>通过 aws cli 工具我们可以通过脚本来自动化执行很多操作，同时也能很方便地和 S3 进行交互。 本文会介绍如何安装及配置 aws-cli 工具。</p><a id="more"></a><h1 id="安装-aws-cli"><a href="#安装-aws-cli" class="headerlink" title="安装 aws-cli"></a>安装 aws-cli</h1><p>安装 aws-cli 首先需要安装 python 的 pip 包管理工具，我们可以通过下面的命令安装它：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl <span class="string">"https://bootstrap.pypa.io/get-pip.py"</span> -o <span class="string">"get-pip.py"</span></span><br><span class="line">sudo python get-pip.py</span><br></pre></td></tr></table></figure><p>成功安装 pip 之后，我们可以很方便地通过 <code>sudo pip install awscli</code> 来安装 aws-cli 工具。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>安装完 aws-cli 之后需要进行配置，主要包括下面三项的配置：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  ~ aws configure</span><br><span class="line">AWS Access Key ID [****************ZPKQ]:</span><br><span class="line">AWS Secret Access Key [****************vN7P]:</span><br><span class="line">Default region name [None]: us-east-1</span><br></pre></td></tr></table></figure><p>其中 <code>Access Key ID</code> 和 <code>Secret Access Key</code> 可以从 AWS Console 上的 <code>My Security Credentials</code> 页面中获取：</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1515945723095.png" width="722"></p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>当配置新的机器时，可以直接把之前成功配置的机器上的 <code>~/.aws</code> 复制到新机器即可。</p><h1 id="配合-aws-mfa-命令使用"><a href="#配合-aws-mfa-命令使用" class="headerlink" title="配合 aws-mfa 命令使用"></a>配合 aws-mfa 命令使用</h1><p>很多时候为了安全起见，aws 账户会开启 MFA 的认证，这时即使按照上面配置好 aws-cli ， 在执行的时候依然会有访问权限相关的错误：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  ~ aws s3 ls</span><br><span class="line"></span><br><span class="line">An error occurred (AccessDenied) when calling the ListBuckets operation: Access Denied</span><br></pre></td></tr></table></figure><p>这时我们就需要另外一个工具：aws-mfa</p><h2 id="安装-aws-mfa"><a href="#安装-aws-mfa" class="headerlink" title="安装 aws-mfa"></a>安装 aws-mfa</h2><p>安装 aws-mfa 需要 <code>gem</code> 命令，如果不存在这个命令，可以通过 <code>sudo yum install -y gem</code> 来安装。</p><p>确保 gem 成功安装后，我们便可通过 <code>gem install aws-mfa</code> 来安装 aws-mfa 。</p><h2 id="使用-aws-mfa"><a href="#使用-aws-mfa" class="headerlink" title="使用 aws-mfa"></a>使用 aws-mfa</h2><p>它有两种使用方式：</p><ol><li>直接在 shell 里执行 <code>eval $(aws-mfa)</code>，输入对应的 MFA code:</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">eval</span> $(aws-mfa)</span><br><span class="line">Enter the 6-digit code from your MFA device:</span><br><span class="line">051059</span><br></pre></td></tr></table></figure><p>执行完这个命令后，我们便可在这个 shell 里正常执行 aws 命令了。</p><ol start="2"><li>我们还可以直接在 aws 命令前加上 aws-mfa 。我个人更喜欢这种方式，可以在 shell rc 文件里配置 <code>alias aws=&#39;aws-mfa aws&#39;</code> 这样的 alias</li></ol><h2 id="使用-python-包-awsmfa"><a href="#使用-python-包-awsmfa" class="headerlink" title="使用 python 包 awsmfa"></a>使用 python 包 awsmfa</h2><p>我们还可以使用另一个用 python 写的 aws mfa 的包，使用 <code>pip install awsmfa</code> 安装。 然后执行 <code>awsmfa -i default</code> 即可。 <a href="https://pypi.python.org/pypi/awsmfa" rel="external nofollow noopener noreferrer" target="_blank">这里</a> 是详细的使用文档。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/02/02/create-k8s-cluster-on-aws-via-kops/">利用 kops 在 AWS 上创建 K8S 集群</a></li><li><a href="https://hiberabyss.github.io/2018/01/18/internet-access-with-nat-gateway/">【AWS】利用 NAT Gateway 给 EC2 增加外网访问</a></li><li><a href="https://hiberabyss.github.io/2017/11/23/aws-mfa-from-pc/">直接在电脑端获取 AWS 的 MFA code</a></li><li><a href="https://hiberabyss.github.io/2017/11/22/k8s-persistent-volume/">利用 AWS 的 EBS 为 kubernetes 集群添加持久化存储</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过 aws cli 工具我们可以通过脚本来自动化执行很多操作，同时也能很方便地和 S3 进行交互。 本文会介绍如何安装及配置 aws-cli 工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AWS" scheme="https://hiberabyss.github.io/tags/aws/"/>
    
      <category term="MFA" scheme="https://hiberabyss.github.io/tags/mfa/"/>
    
  </entry>
  
  <entry>
    <title>在 Kubernetes 的多个 Nodes 上执行命令</title>
    <link href="https://hiberabyss.github.io/2017/12/01/k8s-run-commands-on-multiple-nodes/"/>
    <id>https://hiberabyss.github.io/2017/12/01/k8s-run-commands-on-multiple-nodes/</id>
    <published>2017-12-01T11:31:04.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>有时我们会需要在多个 K8S 的 Nodes 节点上执行一些命令，可以借助工具 <a href="https://github.com/coreos/fabric-kubernetes-nodes" rel="external nofollow noopener noreferrer" target="_blank">fabric-kubernetes-nodes</a> 来实现这个目的。</p><a id="more"></a><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>fabric-kubernetes-nodes 主要是利用 fabric 工具以及 K8S 的标签系统来实现的。 我们可以通过给想要进行操作的所有节点加上 label，然后通过这个 label 来对他们进行操作：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">label</span> <span class="string">node</span> <span class="string">node1</span> <span class="string">node2</span> <span class="string">my-special-label=true</span></span><br><span class="line"><span class="string">fab</span> <span class="string">-u</span> <span class="string">core</span> <span class="string">-R</span> <span class="string">my-special-label=true</span> <span class="string">--</span> <span class="string">date</span></span><br></pre></td></tr></table></figure><p>对于通过 kops 建立的 K8S 集群，我们可以通过下面的命令来对所有的 Node 节点来进行操作：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> FAB_KUBE_NODE_ADDRESS_TYPE=InternalIP</span><br><span class="line"></span><br><span class="line">fab -P --fabfile <span class="variable">$HOME</span>/github/fabric-kubernetes-nodes/fabfile.py \</span><br><span class="line">    -R <span class="string">"kubernetes.io/role=node"</span> -- <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>把上面的内容保存为 <code>pnodes</code> 并加上可执行权限，便可很方便地在所有节点上执行命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">➜  blog git:(hexo) ✗ pnodes date</span><br><span class="line">[10.28.12.43] Executing task <span class="string">'&lt;remainder&gt;'</span></span><br><span class="line">[10.28.2.248] Executing task <span class="string">'&lt;remainder&gt;'</span></span><br><span class="line">[10.28.8.119] Executing task <span class="string">'&lt;remainder&gt;'</span></span><br><span class="line">[10.28.8.119] run: date</span><br><span class="line">[10.28.2.248] run: date</span><br><span class="line">[10.28.12.43] run: date</span><br><span class="line">[10.28.12.43] out: Fri Dec 22 02:53:01 UTC 2017</span><br><span class="line">[10.28.12.43] out:</span><br><span class="line"></span><br><span class="line">[10.28.8.119] out: Fri Dec 22 02:53:01 UTC 2017</span><br><span class="line">[10.28.8.119] out:</span><br><span class="line"></span><br><span class="line">[10.28.2.248] out: Fri Dec 22 02:53:01 UTC 2017</span><br><span class="line">[10.28.2.248] out:</span><br></pre></td></tr></table></figure><h2 id="给-Instance-Group-IG-加上-nodeLable"><a href="#给-Instance-Group-IG-加上-nodeLable" class="headerlink" title="给 Instance Group(IG) 加上 nodeLable"></a>给 Instance Group(IG) 加上 nodeLable</h2><p>当通过 kops 创建 k8s 集群时，我们可以通过如下的方式给 IG 加上 label ， 就可以通过这个 label 对整个 IG 进行操作：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeLabels:</span></span><br><span class="line">    <span class="attr">ads:</span> <span class="string">perf</span></span><br></pre></td></tr></table></figure><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/05/21/setup-quorum-kubernetes-cluster-step-by-step/">基于 Quorum 集群搭建讲解如何从 docker-compose 迁移到 Kubernetes</a></li><li><a href="https://hiberabyss.github.io/2017/11/22/k8s-persistent-volume/">利用 AWS 的 EBS 为 kubernetes 集群添加持久化存储</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时我们会需要在多个 K8S 的 Nodes 节点上执行一些命令，可以借助工具 &lt;a href=&quot;https://github.com/coreos/fabric-kubernetes-nodes&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;fabric-kubernetes-nodes&lt;/a&gt; 来实现这个目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://hiberabyss.github.io/tags/kubernetes/"/>
    
      <category term="Fabric" scheme="https://hiberabyss.github.io/tags/fabric/"/>
    
  </entry>
  
  <entry>
    <title>「VIM」 从远程机器复制文件内容到本机剪贴板</title>
    <link href="https://hiberabyss.github.io/2017/11/30/vim-remote-copy/"/>
    <id>https://hiberabyss.github.io/2017/11/30/vim-remote-copy/</id>
    <published>2017-11-30T12:35:19.000Z</published>
    <updated>2021-02-10T07:01:06.372Z</updated>
    
    <content type="html"><![CDATA[<p>通过 ssh 登录到远程机器后，想要复制远程机器的文件内容是一件很麻烦的事情。 通过拖动来复制对于多行的内容很难实现精确定位，还有可能会遇到换行符的问题。利用 <a href="https://github.com/wincent/clipper" rel="external nofollow noopener noreferrer" target="_blank">clipper</a> 命令可以很方便地复制远程机器的内容到本机剪贴板中。</p><a id="more"></a><h2 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h2><p>macOS 系统可以通过 <code>brew install clipper</code> 安装。安装完成后通过 <code>brew services start clipper</code> 启动。 通过以下命令检查 clipper 是不是正常启动：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  blog git:(hexo) ✗ ps -ef | grep clipper</span><br><span class="line">  502   463     1   0  3:07PM ??         0:00.09 /usr/local/opt/clipper/bin/clipper</span><br></pre></td></tr></table></figure><h2 id="简单演示"><a href="#简单演示" class="headerlink" title="简单演示"></a>简单演示</h2><p>当确认 clipper 启动成功后，通过下面的命令连接到远程机器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -R 8377:localhost:8377 192.168.0.32</span><br></pre></td></tr></table></figure><p>确认远程机器上安装有 <code>nc</code> （对于 CentOS 机器可以通过 <code>sudo yum install -y nmap-ncat</code> 来安装）， 执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo hello,world | nc localhost 8377</span><br></pre></td></tr></table></figure><p>现在 “hello,world” 字符转已经成功复制到本机的剪贴板了。可以切换到浏览器地址栏粘贴查看结果。</p><p>每次连接远程机器都需要加上 <code>-R 8377:localhost:8377</code> 参数显得有些冗余，我们可以通过修改 <code>~/.ssh/config</code> 文件来实现连接远程主机时默认加上这个参数，只需把下面这行添加到文件 <code>~/.ssh/config</code> 里：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RemoteForward 8377 localhost:8377</span><br></pre></td></tr></table></figure><h2 id="在远程主机的-VIM-里复制内容"><a href="#在远程主机的-VIM-里复制内容" class="headerlink" title="在远程主机的 VIM 里复制内容"></a>在远程主机的 VIM 里复制内容</h2><p>我们可以利用 <code>:[range]w[rite] [++opt] !{cmd}</code> 来实现文件内容的复制：</p><ul><li>复制当前行：在 VIM 中执行 <code>:.w !nc localhost 8377</code></li><li>复制选中的行：选中要复制的行后，执行 <code>:&#39;&lt;,&#39;&gt;w !nc localhost 8377</code> ( 进入命令行模式后 VIM 会自动帮忙填充 <code>&#39;&lt;,&#39;&gt;</code>)</li><li>复制整个文件：在 VIM 中执行 <code>:%w !nc localhost 8377</code></li><li>复制 VIM 默认 register 的内容：在 VIM 中执行 <code>:call system(&#39;nc localhost 8377&#39;, @&quot;)</code></li></ul><h3 id="通过-VIM-插件-vim-clipper"><a href="#通过-VIM-插件-vim-clipper" class="headerlink" title="通过 VIM 插件 vim-clipper"></a>通过 VIM 插件 vim-clipper</h3><p>安装了 <a href="https://github.com/wincent/vim-clipper" rel="external nofollow noopener noreferrer" target="_blank">vim-clipper</a> 插件后：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/wincent/vim-clipper'</span></span><br></pre></td></tr></table></figure><p>可以直接通过命令 <code>:Clip</code> 来复制 VIM 默认 register 的内容。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2020/05/06/vim-open-saz-file/">使用 Vim 查看 Fiddler 生成的 saz 格式 session 包</a></li><li><a href="https://hiberabyss.github.io/2018/05/03/add-async-support-for-vim-plugin/">给 Vim 插件添加上异步调用的功能</a></li><li><a href="https://hiberabyss.github.io/2018/04/24/vim-plug-rest-console/">实现类 Postman 功能的 VIM 插件</a></li><li><a href="https://hiberabyss.github.io/2018/04/13/vim-file-jumper/">Vim 文件快速跳转插件</a></li><li><a href="https://hiberabyss.github.io/2018/03/21/vim-plug-introduction/">VIM 插件管理工具 vim-plug 简明教程</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过 ssh 登录到远程机器后，想要复制远程机器的文件内容是一件很麻烦的事情。 通过拖动来复制对于多行的内容很难实现精确定位，还有可能会遇到换行符的问题。利用 &lt;a href=&quot;https://github.com/wincent/clipper&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;clipper&lt;/a&gt; 命令可以很方便地复制远程机器的内容到本机剪贴板中。&lt;/p&gt;
    
    </summary>
    
      <category term="Vim" scheme="https://hiberabyss.github.io/categories/vim/"/>
    
    
      <category term="Vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>免密码登录 anyconnect</title>
    <link href="https://hiberabyss.github.io/2017/11/27/no-password-anyconnect/"/>
    <id>https://hiberabyss.github.io/2017/11/27/no-password-anyconnect/</id>
    <published>2017-11-27T09:31:02.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>公司的 VPN 需要使用 Cisco Anyconnect 作为客户端来连接，这个客户端在每次连接的时候需都要输入 LDAP 密码来登录。可以通过 Anyconnect 提供的命令行工具来实现免密登录。</p><a id="more"></a><h2 id="通过命令行连接-VPN"><a href="#通过命令行连接-VPN" class="headerlink" title="通过命令行连接 VPN"></a>通过命令行连接 VPN</h2><p>执行命令 <code>/opt/cisco/anyconnect/bin/vpn -s</code> ：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  bin /opt/cisco/anyconnect/bin/vpn -s</span><br><span class="line">Cisco AnyConnect Secure Mobility Client (version 4.3.01095) .</span><br><span class="line"></span><br><span class="line">Copyright (c) 2004 - 2016 Cisco Systems, Inc.  All Rights Reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">  &gt;</span><span class="bash">&gt; state: Disconnected</span></span><br><span class="line"><span class="meta">  &gt;</span><span class="bash">&gt; state: Disconnected</span></span><br><span class="line"><span class="meta">  &gt;</span><span class="bash">&gt; notice: Ready to connect.</span></span><br><span class="line"><span class="meta">  &gt;</span><span class="bash">&gt; registered with <span class="built_in">local</span> VPN subsystem.</span></span><br><span class="line"><span class="meta">VPN&gt;</span></span><br></pre></td></tr></table></figure><p>执行 <code>connect your.vpn.url</code> ：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">VPN&gt;</span><span class="bash"> connect your.vpn.url</span></span><br></pre></td></tr></table></figure><p>按照提示输入你的用户名和密码即可连接 VPN 。</p><h2 id="利用脚本连接-VPN"><a href="#利用脚本连接-VPN" class="headerlink" title="利用脚本连接 VPN"></a>利用脚本连接 VPN</h2><p>通过上一步我们知道连接 VPN 需要知道三个信息：VPN 地址、用户名和密码。 密码是比较私密的信息，不适合放在脚本文件里，我们可以利用 macOS 里的 Keychain 工具来保存密码。</p><h3 id="创建一个-Keychain-password-条目"><a href="#创建一个-Keychain-password-条目" class="headerlink" title="创建一个 Keychain password 条目"></a>创建一个 Keychain password 条目</h3><p>打开 Keychain Access 工具，创建一个 <code>FW_OLTP</code> 条目：</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1511848299645.png" width="708"></p><p>当这个条目创建完成，我们便可以利用下面的命令获取密码：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">security find-generic-password -wl FW_OLTP</span><br></pre></td></tr></table></figure><h3 id="创建连接-VPN-的脚本文件"><a href="#创建连接-VPN-的脚本文件" class="headerlink" title="创建连接 VPN 的脚本文件"></a>创建连接 VPN 的脚本文件</h3><p>下面的 shell 脚本文件会从 Keychain Access 工具里获取 VPN 的密码，然后利用 <code>vpn</code> 命令行工具连接 VPN ，最后打开 Anyconnect 客户端的 UI 界面：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">KEYCHAIN_LABEL="FW_LDAP"</span><br><span class="line">USERNAME=$(whoami)</span><br><span class="line">PASSWORD=$(security find-generic-password -wl $KEYCHAIN_LABEL)</span><br><span class="line">VPN_URL="your.vpn.url"</span><br><span class="line">VPN_BIN="/opt/cisco/anyconnect/bin/vpn"</span><br><span class="line">ANYCONNECT_PATH="/Applications/Cisco/Cisco AnyConnect Secure Mobility Client.app"</span><br><span class="line"></span><br><span class="line">get_anyclient_ui_pid() &#123;</span><br><span class="line">    local pid=$(ps -ef | grep "$ANYCONNECT_PATH" | grep -v 'grep' | awk '&#123;print $2&#125;')</span><br><span class="line">    echo $pid</span><br><span class="line"></span><br><span class="line">    if [[ -z "$pid" ]]; then</span><br><span class="line">        return 1</span><br><span class="line">    else</span><br><span class="line">        return 0</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kill_anyconnect_ui() &#123;</span><br><span class="line">    $VPN_BIN disconnect</span><br><span class="line">    local pid=$(get_anyclient_ui_pid)</span><br><span class="line">    # echo "PID: $pid"</span><br><span class="line"></span><br><span class="line">    if [[ -n "$pid" ]]; then</span><br><span class="line">        kill -9 $pid</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">open_client_ui() &#123;</span><br><span class="line">    if ! get_anyclient_ui_pid &amp;&gt; /dev/zero; then</span><br><span class="line">        open "$ANYCONNECT_PATH"</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connect() &#123;</span><br><span class="line">    # sudo /opt/cisco/anyconnect/bin/vpnagentd</span><br><span class="line">    kill_anyconnect_ui</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">VPN_BIN -s &lt;&lt; EOF</span></span><br><span class="line">connect $VPN_URL</span><br><span class="line"><span class="meta">$</span><span class="bash">USERNAME</span></span><br><span class="line"><span class="meta">$</span><span class="bash">PASSWORD</span></span><br><span class="line">y</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">    open_client_ui</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    if [[ -z "$USERNAME" || -z "$PASSWORD" || -z "$VPN_URL" ]]; then</span><br><span class="line">        echo "Error: empty user info"</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    case "$1" in</span><br><span class="line">        stop|s )</span><br><span class="line">            $VPN_BIN disconnect</span><br><span class="line">            ;;</span><br><span class="line">        * )</span><br><span class="line">            connect</span><br><span class="line">    esac</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main "$*"</span><br></pre></td></tr></table></figure><p>把上面的内容保存到 <code>$HOME/bin/anyconnect</code> （这个路径后面的 Alfred Workflow 会用到）文件中。 给文件加上执行权限 <code>chmod +x $HOME/bin/anyconnect</code> ，现在直接执行 <code>$HOME/bin/anyconnect</code> 就可以连上 VPN 了。</p><h2 id="通过-Alfred-Workflow-插件来连接"><a href="#通过-Alfred-Workflow-插件来连接" class="headerlink" title="通过 Alfred Workflow 插件来连接"></a>通过 Alfred Workflow 插件来连接</h2><p>安装这个 <a href="https://github.com/hiberabyss/BlogDATA/raw/master/alfred/NoPasswdAnyconnect.alfredworkflow" rel="external nofollow noopener noreferrer" target="_blank">Alfred Workflow</a> 即可直接通过 Alfred 来直接打开或者断开 VPN 连接：</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1511848203769.png" width="555"></p><p>没有任何参数时会连接 VPN ，输入参数 <code>s|stop</code> 就会断开 VPN 连接。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2017/11/23/aws-mfa-from-pc/">直接在电脑端获取 AWS 的 MFA code</a></li><li><a href="https://hiberabyss.github.io/2017/11/14/vim-mac-chinese-input/">【Vim】macOS 系统下 Vim 编辑中文 tips</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司的 VPN 需要使用 Cisco Anyconnect 作为客户端来连接，这个客户端在每次连接的时候需都要输入 LDAP 密码来登录。可以通过 Anyconnect 提供的命令行工具来实现免密登录。&lt;/p&gt;
    
    </summary>
    
      <category term="Tool" scheme="https://hiberabyss.github.io/categories/tool/"/>
    
    
      <category term="Alfred" scheme="https://hiberabyss.github.io/tags/alfred/"/>
    
      <category term="macOS" scheme="https://hiberabyss.github.io/tags/macos/"/>
    
      <category term="Anyconnect" scheme="https://hiberabyss.github.io/tags/anyconnect/"/>
    
  </entry>
  
  <entry>
    <title>直接在电脑端获取 AWS 的 MFA code</title>
    <link href="https://hiberabyss.github.io/2017/11/23/aws-mfa-from-pc/"/>
    <id>https://hiberabyss.github.io/2017/11/23/aws-mfa-from-pc/</id>
    <published>2017-11-23T20:10:35.000Z</published>
    <updated>2021-02-10T07:01:06.352Z</updated>
    
    <content type="html"><![CDATA[<p>当 AWS 开启了 MFA 认证之后，登录时就需要输入应的 MFA code 。 默认我们可以通过手机应用 Google Authenticator 来获取到这个 code ， 登录的过程还需要使用手机是一种很低效的方式，而且有时还会遇到手机不在身边的情况。 本文会介绍两种可以在电脑端获取 MFA code 的方法。</p><a id="more"></a><h2 id="获取-MFA-设备的秘钥"><a href="#获取-MFA-设备的秘钥" class="headerlink" title="获取 MFA 设备的秘钥"></a>获取 MFA 设备的秘钥</h2><p>在实现电脑端获取 MFA code 前，我们需要先获取到 MFA device 的秘钥：</p><ol><li><p>切换到 “My Security Credentials” 面板： <img src="http://on2hdrotz.bkt.clouddn.com/blog/1511439986529.png" width="193"></p></li><li><p>搜索你自己的用户名，并点击进入： <img src="http://on2hdrotz.bkt.clouddn.com/blog/1511440121929.png" width="565"></p></li><li><p>切换到 “Security Credentials” tab 页，编辑 “Assigned MFA device”（如果之前有 assign 过 MFA 设备需要先 deactive）： <img src="http://on2hdrotz.bkt.clouddn.com/blog/1511440283396.png" width="658"></p></li><li><p>一路点 Next ，最后就可以看到 MFA device 的秘钥了： <img src="http://on2hdrotz.bkt.clouddn.com/blog/1511440632702.png" width="739"></p></li></ol><h2 id="通过命令行方式获取-MFA-code"><a href="#通过命令行方式获取-MFA-code" class="headerlink" title="通过命令行方式获取 MFA code"></a>通过命令行方式获取 MFA code</h2><p>先安装 <a href="https://github.com/pcarrier/gauth" rel="external nofollow noopener noreferrer" target="_blank">gauth</a> 命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go get github.com/pcarrier/gauth</span><br></pre></td></tr></table></figure><p>编辑文件 <code>~/.config/gauth.csv</code>，填入上一步获取的秘钥：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AWS: ABCDEFGHIJKLMNOPQRSTUVWXYZ234567ABCDEFGHIJKLMNOPQRSTUVWXYZ234567</span><br></pre></td></tr></table></figure><p>还需要设置好文件的权限： <code>chmod 600 ~/.config/gauth.csv</code> 。</p><p>执行命令 <code>gauth</code> 即可获取如下输出：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> gauth</span><br><span class="line">           prev   curr   next</span><br><span class="line">AWS        315306 135387 483601</span><br><span class="line">[=======                      ]</span><br></pre></td></tr></table></figure><p>其中最后一行表示的是剩余时间。</p><h2 id="通过-Alfred-Workflow-来获取-MFA-code"><a href="#通过-Alfred-Workflow-来获取-MFA-code" class="headerlink" title="通过 Alfred Workflow 来获取 MFA code"></a>通过 Alfred Workflow 来获取 MFA code</h2><p>如果安装了 Alfred 并激活了 Powerpack ，可以通过 Alfred Workflow <a href="https://github.com/moul/alfred-workflow-gauth/blob/develop/Google%20Authenticator.alfredworkflow?raw=true" rel="external nofollow noopener noreferrer" target="_blank">Google Authenticator</a> 来实现如下图所示的效果：</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1511442187231.png" width="558"></p><p>我个人更喜欢这种方式，直接按回车键就可以把 MFA code 复制到系统剪贴板。</p><h3 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h3><ol><li>下载 <a href="https://github.com/moul/alfred-workflow-gauth/blob/develop/Google%20Authenticator.alfredworkflow?raw=true" rel="external nofollow noopener noreferrer" target="_blank">Google Authenticator</a> 并导入到 Alfred；</li><li>编辑文件 <code>~/.gauth</code> ，填入之前获取的 MFA 设备的秘钥：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[AWS - lhbf@qq.com]</span><br><span class="line">secret = ABCDEFGHIJKLMNOPQRSTUVWXYZ234567ABCDEFGHIJKLMNOPQRSTUVWXYZ234567</span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://github.com/pcarrier/gauth" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/pcarrier/gauth</a></li><li><a href="https://github.com/moul/alfred-workflow-gauth" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/moul/alfred-workflow-gauth</a></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/02/02/create-k8s-cluster-on-aws-via-kops/">利用 kops 在 AWS 上创建 K8S 集群</a></li><li><a href="https://hiberabyss.github.io/2018/01/18/internet-access-with-nat-gateway/">【AWS】利用 NAT Gateway 给 EC2 增加外网访问</a></li><li><a href="https://hiberabyss.github.io/2018/01/14/setup-aws-cli/">配置 AWS CLI 工具</a></li><li><a href="https://hiberabyss.github.io/2017/11/27/no-password-anyconnect/">免密码登录 anyconnect</a></li><li><a href="https://hiberabyss.github.io/2017/11/22/k8s-persistent-volume/">利用 AWS 的 EBS 为 kubernetes 集群添加持久化存储</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当 AWS 开启了 MFA 认证之后，登录时就需要输入应的 MFA code 。 默认我们可以通过手机应用 Google Authenticator 来获取到这个 code ， 登录的过程还需要使用手机是一种很低效的方式，而且有时还会遇到手机不在身边的情况。 本文会介绍两种可以在电脑端获取 MFA code 的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Tool" scheme="https://hiberabyss.github.io/categories/tool/"/>
    
    
      <category term="AWS" scheme="https://hiberabyss.github.io/tags/aws/"/>
    
      <category term="Alfred" scheme="https://hiberabyss.github.io/tags/alfred/"/>
    
      <category term="macOS" scheme="https://hiberabyss.github.io/tags/macos/"/>
    
  </entry>
  
  <entry>
    <title>利用 AWS 的 EBS 为 kubernetes 集群添加持久化存储</title>
    <link href="https://hiberabyss.github.io/2017/11/22/k8s-persistent-volume/"/>
    <id>https://hiberabyss.github.io/2017/11/22/k8s-persistent-volume/</id>
    <published>2017-11-22T10:21:27.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍如何创建一个 EBS 卷，并把这个 EBS 卷挂载到 kubernetes 集群里的 POD 上。</p><a id="more"></a><h2 id="创建一个-EBS-卷"><a href="#创建一个-EBS-卷" class="headerlink" title="创建一个 EBS 卷"></a>创建一个 EBS 卷</h2><p>用 <code>aws configure</code> 配置好 aws 命令行之后（如果开启了 mfa ，需要先调用下 <code>eval $(aws-mfa)</code>），我们便可以调用下面的命令创建一个 EBS 卷：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aws ec2 create-volume --availability-zone us-east-1a --size 20 --volume-type gp2</span><br></pre></td></tr></table></figure><p>上面的命令会得到类似下面的输出：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"AvailabilityZone"</span>: <span class="string">"us-east-1a"</span>,</span><br><span class="line">    <span class="attr">"Encrypted"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"VolumeType"</span>: <span class="string">"gp2"</span>,</span><br><span class="line">    <span class="attr">"VolumeId"</span>: <span class="string">"vol-123456we7890ilk12"</span>,</span><br><span class="line">    <span class="attr">"State"</span>: <span class="string">"creating"</span>,</span><br><span class="line">    <span class="attr">"Iops"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">"SnapshotId"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"CreateTime"</span>: <span class="string">"2017-01-04T03:53:00.298Z"</span>,</span><br><span class="line">    <span class="attr">"Size"</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记录下 <code>VolumeId</code> ，会在后面的步骤中用到。</p><h2 id="创建-K8S-中的-Persistent-Volume-PV"><a href="#创建-K8S-中的-Persistent-Volume-PV" class="headerlink" title="创建 K8S 中的 Persistent Volume (PV)"></a>创建 K8S 中的 Persistent Volume (PV)</h2><p>创建文件 <code>aws-pv.yaml</code>：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">"v1"</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">"PersistentVolume"</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">"aws-pv"</span> </span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">amazonEBS</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">"10Gi"</span> </span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">awsElasticBlockStore:</span> </span><br><span class="line">    <span class="attr">fsType:</span> <span class="string">"ext4"</span> </span><br><span class="line">    <span class="attr">volumeID:</span> <span class="string">"vol-123456we7890ilk12"</span></span><br></pre></td></tr></table></figure><p>利用 kubectl 创建 Persistent Volume ：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f aws-pv.yaml</span><br></pre></td></tr></table></figure><p>可用命令 <code>kubectl get pv</code> 来查看创建的 Persistent Volume 的状态：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME       CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS      CLAIM               REASON    AGE</span><br><span class="line">aws-pv     10Gi        RWX           Retain          Available                                7s</span><br></pre></td></tr></table></figure><h2 id="创建-Persistent-Volume-Claim"><a href="#创建-Persistent-Volume-Claim" class="headerlink" title="创建 Persistent Volume Claim"></a>创建 Persistent Volume Claim</h2><p>创建 Persistent Volume Claim (PVC) 和之前创建的 PV 进行绑定，K8S 中的 POD 通过 PVC 来使用 PV 。</p><p>创建文件 <code>pvc.yaml</code> ：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">aws-pvc</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">amazonEBS</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">10Gi</span></span><br></pre></td></tr></table></figure><p>通过 <code>kubectl</code> 创建 PVC ：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f pvc.yaml</span><br></pre></td></tr></table></figure><p>查看创建的 PVC ：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pvc</span><br></pre></td></tr></table></figure><h2 id="在-POD-中使用-PVC"><a href="#在-POD-中使用-PVC" class="headerlink" title="在 POD 中使用 PVC"></a>在 POD 中使用 PVC</h2><p>先创建对应 PVC 的 volume ：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data-repa</span></span><br><span class="line">  <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">    <span class="attr">claimName:</span> <span class="string">aws-pvc</span></span><br></pre></td></tr></table></figure><p>再添加 mount ：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumeMounts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data-repa</span></span><br><span class="line">  <span class="attr">mountPath:</span> <span class="string">/ads/data/pusher</span></span><br></pre></td></tr></table></figure><h2 id="Some-Tips"><a href="#Some-Tips" class="headerlink" title="Some Tips"></a>Some Tips</h2><p>一个 EBS 最多只能挂在到一台 EC2 上，如果希望多台机器上的 POD 能共享数据， 则需要使用 EFS、NFS 或 GlusterFS。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://blog.bigbinary.com/2017/04/12/using-kubernetes-persistent-volume-for-persistent-data-storage.html" rel="external nofollow noopener noreferrer" target="_blank">Using Kubernetes Persistent volume to store persistent data</a></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/05/21/setup-quorum-kubernetes-cluster-step-by-step/">基于 Quorum 集群搭建讲解如何从 docker-compose 迁移到 Kubernetes</a></li><li><a href="https://hiberabyss.github.io/2018/02/02/create-k8s-cluster-on-aws-via-kops/">利用 kops 在 AWS 上创建 K8S 集群</a></li><li><a href="https://hiberabyss.github.io/2018/01/18/internet-access-with-nat-gateway/">【AWS】利用 NAT Gateway 给 EC2 增加外网访问</a></li><li><a href="https://hiberabyss.github.io/2018/01/14/setup-aws-cli/">配置 AWS CLI 工具</a></li><li><a href="https://hiberabyss.github.io/2017/12/01/k8s-run-commands-on-multiple-nodes/">在 Kubernetes 的多个 Nodes 上执行命令</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍如何创建一个 EBS 卷，并把这个 EBS 卷挂载到 kubernetes 集群里的 POD 上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AWS" scheme="https://hiberabyss.github.io/tags/aws/"/>
    
      <category term="Kubernetes" scheme="https://hiberabyss.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>在代码库中集成 1.0.28 版本的 libmemcached</title>
    <link href="https://hiberabyss.github.io/2017/11/20/integrate-latest-libmemcached/"/>
    <id>https://hiberabyss.github.io/2017/11/20/integrate-latest-libmemcached/</id>
    <published>2017-11-20T10:28:57.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间，我们的线上 server 发生了一个很诡异的现象：在访问 memcached 的时候， 某些情况下可能会获取到旧的数据，从而导致我们的 server 不能正常地返回 response 。 我们代码库中的 libmemcahed 是一个很低的版本：0.26，我们便想通过升级 libmecached 到最新 <a href="https://launchpad.net/libmemcached/+download" rel="external nofollow noopener noreferrer" target="_blank">1.0.28</a> 版本来尝试解决这个问题。</p><a id="more"></a><p>在集成 libmemcachd 之前，我们需要先在本地把它编译出来。因为我们不需要 sasl 的功能， 便在 config 的时候把它禁用掉了：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd libmemcached-1.0.18</span><br><span class="line">./configure --disable-sasl</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>有两种方式可以把 libmemcachd 集成进去：</p><h2 id="直接链接静态库的方式集成"><a href="#直接链接静态库的方式集成" class="headerlink" title="直接链接静态库的方式集成"></a>直接链接静态库的方式集成</h2><p>这需要先把头文件添加到系统搜索路径中，同时把之前编译好的 library (libmemcached-1.0.18/libmemcached/.libs/libmemcached.a) 静态库添加到代码库， 并加入到链接库参数中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AM_CPPFLAGS += -isystem $(top_srcdir)/3rd/libmemcached</span><br><span class="line"></span><br><span class="line">ads_LDADD += $(root_path)/3rd/3rd/libmemcached.a</span><br></pre></td></tr></table></figure><h2 id="集成-libmemcachd-代码"><a href="#集成-libmemcachd-代码" class="headerlink" title="集成 libmemcachd 代码"></a>集成 libmemcachd 代码</h2><p>集成 libmemcachd 静态库的方式更简单，能够让我们快速地进行一些测试。 更优雅的集成方式还是集成进 libmemcachd 的代码，让它每次和我们的代码一起 build 。</p><p>首先我们需要把 libmemcachd 的代码复制到我们的代买库中，在复制之前需要用 <code>make clean</code> 清理下编译生成的中间文件。 同时，如果是在非 windows 环境下编译，且把 libmemcachd 通过 <code>-isystem</code> 方式加到搜索路径时，我们需要删除掉 poll.h 文件。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp libmemcached-1.0.18/libmemcached 3rd/libmemcached</span><br><span class="line">cp libmemcached-1.0.18/libhashkit-1.0/ 3rd/libmemcached</span><br><span class="line">cp libmemcached-1.0.18/libmemcached-1.0/ 3rd/libmemcached</span><br><span class="line">cp libmemcached-1.0.18/libmemcachedprotocol-0.0/ 3rd/libmemcached</span><br><span class="line">cp libmemcached-1.0.18/libhashkit 3rd/libmemcached</span><br></pre></td></tr></table></figure><p>为了防止文件名同名，我们需要把 libhashkit 目录下的文件重命名，加上目录名：<code>zmv -W &#39;*.cc&#39; &#39;libhashkit_*.cc&#39;</code>。 在 3rd/libmemcached 中加入 Makefile.am 文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AM_CFLAGS = --std=c99 -D_POSIX_C_SOURCE</span><br><span class="line">LIBMEMCACHED_ROOT = $(top_srcdir)/3rd/libmemcached</span><br><span class="line">AM_CPPFLAGS = -I$(LIBMEMCACHED_ROOT) -I$(LIBMEMCACHED_ROOT)/libmemcached</span><br><span class="line"></span><br><span class="line">LIBMEMCACHED_SOURCES = \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/csl/context.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/csl/parser.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/csl/scanner.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/instance.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/allocators.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/allocators.hpp \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/analyze.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/array.c \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/auto.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/backtrace.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/byteorder.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/callback.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/connect.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/delete.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/do.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/dump.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/error.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/exist.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/fetch.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/flag.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/flush.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/behavior.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/flush_buffers.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/get.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/hash.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/hash.hpp \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/hosts.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/initialize_query.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/io.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/key.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/memcached.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/encoding_key.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/namespace.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/options.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/parse.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/poll.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/purge.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/quit.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/quit.hpp \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/response.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/result.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/server.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/server_list.hpp \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/server_list.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/stats.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/storage.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/strerror.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/string.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/touch.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/udp.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/verbosity.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/version.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/virtual_bucket.c \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libmemcached/sasl.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_aes.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_algorithm.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_behavior.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_crc32.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_digest.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_encrypt.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_fnv_32.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_fnv_64.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_function.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_has.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_hashkit.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_hsieh.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_jenkins.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_ketama.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_md5.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_murmur.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_murmur3.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_murmur3_api.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_nohsieh.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_one_at_a_time.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_rijndael.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_str_algorithm.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_strerror.cc \</span><br><span class="line">    $(LIBMEMCACHED_ROOT)/libhashkit/libhashkit_string.cc</span><br><span class="line"></span><br><span class="line">noinst_LIBRARIES = libmemcached.a</span><br><span class="line"></span><br><span class="line">libmemcached_a_SOURCES = $(LIBMEMCACHED_SOURCES)</span><br><span class="line"></span><br><span class="line">CFLAGS += -Wno-pointer-bool-conversion -Wno-self-assign</span><br></pre></td></tr></table></figure><p>同时把 libmemcachd 的 Makefile 加到 configure.ac 文件中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AC_CONFIG_FILES([ 3rd/libmemcached/Makefile ])</span><br></pre></td></tr></table></figure><h2 id="遇到的一些坑"><a href="#遇到的一些坑" class="headerlink" title="遇到的一些坑"></a>遇到的一些坑</h2><h3 id="禁用-sasl-的问题"><a href="#禁用-sasl-的问题" class="headerlink" title="禁用 sasl 的问题"></a>禁用 sasl 的问题</h3><p>最开始编译的时候没有加 <code>--disable-sasl</code>，导致编译的时候一直提示 sasl 相关的库找不到。 加上这个编译参数之后会在文件 <code>libmemcached-1.0.18/libmemcached-1.0/configure.h</code> 里添加下面的宏：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIBMEMCACHED_WITH_SASL_SUPPORT 0</span></span><br></pre></td></tr></table></figure><p>注意一定要复制正确的 configure.h 文件到到代码库中！</p><h3 id="poll-h-的问题"><a href="#poll-h-的问题" class="headerlink" title="poll.h 的问题"></a>poll.h 的问题</h3><p>刚开始一直会提示 ‘POLLIN’ 之类的变量找不到的问题，检查 libmemcachd 里的 poll.h 文件中是有这个变量的定义的。 再仔细看才发现这个文件定义的变量只有在 windows 下才会生效。</p><p>而且因为我们用 <code>-isystem</code> 把 libmemcachd 目录加了进去，导致编译的时候会用 limcached 里的 poll.h 替换了系统中的这个文件， 但 libmemcachd 的 poll.h 文件在 linux 下又是无效的，从而会导致 ‘POLLIN’ 找不到之类的编译错误。我们把 poll.h 这个文件从 libmemcachd 中删除就可以解决这个问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间，我们的线上 server 发生了一个很诡异的现象：在访问 memcached 的时候， 某些情况下可能会获取到旧的数据，从而导致我们的 server 不能正常地返回 response 。 我们代码库中的 libmemcahed 是一个很低的版本：0.26，我们便想通过升级 libmecached 到最新 &lt;a href=&quot;https://launchpad.net/libmemcached/+download&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;1.0.28&lt;/a&gt; 版本来尝试解决这个问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="automake" scheme="https://hiberabyss.github.io/tags/automake/"/>
    
  </entry>
  
  <entry>
    <title>【Neovim】基于自定义 keyword 的自动补全</title>
    <link href="https://hiberabyss.github.io/2017/11/16/vim-word-completion/"/>
    <id>https://hiberabyss.github.io/2017/11/16/vim-word-completion/</id>
    <published>2017-11-16T12:56:38.000Z</published>
    <updated>2021-02-10T07:01:06.372Z</updated>
    
    <content type="html"><![CDATA[<p>有时我们会期望能够根据自定义的一些 keyword 来在 VIM 里进行补全。 我们可以通过 neovim 的插件 deoplete 来实现这个目的。</p><a id="more"></a><p>例如我们在 VIM 里写 sql 的时候可能会遇到很长的列名：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">transaction__request__context__custom_asset_id</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">transaction</span>;</span><br></pre></td></tr></table></figure><p>我们可以把这些 keyword 保存在一个文件 <code>keyword.txt</code> 里：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transaction__request__context__custom_asset_idvarchar</span><br></pre></td></tr></table></figure><p>上面的第二个字段是为了能在补全窗口里显示这个字段的类型。通过添加 deoplete 的 source 来解析这个 <code>keyword.txt</code> 文件就可以在 vim 里实现自动补全：</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1510809654151.png" width="478"></p><h2 id="如何添加-deoplete-的-source"><a href="#如何添加-deoplete-的-source" class="headerlink" title="如何添加 deoplete 的 source"></a>如何添加 deoplete 的 source</h2><p>首先需要安装 <a href="https://github.com/Shougo/deoplete.nvim" rel="external nofollow noopener noreferrer" target="_blank">deoplete</a> 插件：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/Shougo/deoplete.nvim'</span></span><br></pre></td></tr></table></figure><p>把下面的内容保存到 <code>deoplete.nvim/rplugin/python3/deoplete/source/keyword.py</code>, 并把 <code>keyword.txt</code> 文件保存到相同的目录：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">from os.path import getmtime, dirname, realpath</span><br><span class="line">from collections import namedtuple</span><br><span class="line">from .base import Base</span><br><span class="line"></span><br><span class="line">DictCacheItem = namedtuple(<span class="string">'DictCacheItem'</span>, <span class="string">'mtime candidates'</span>)</span><br><span class="line"></span><br><span class="line">class Source(Base):</span><br><span class="line"></span><br><span class="line">    def __init__(self, <span class="keyword">vim</span>):</span><br><span class="line">        super().__init__(<span class="keyword">vim</span>)</span><br><span class="line"></span><br><span class="line">        self.name = <span class="string">'lqs'</span></span><br><span class="line">        self.<span class="keyword">mark</span> = <span class="string">'[LQS]'</span></span><br><span class="line">        self.filetypes = [<span class="string">'sql'</span>]</span><br><span class="line"></span><br><span class="line">        self.__cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def on_event(self, context):</span><br><span class="line">        self.__make_cache(context)</span><br><span class="line"></span><br><span class="line">    def gather_candidates(self, context):</span><br><span class="line">        self.__make_cache(context)</span><br><span class="line"></span><br><span class="line">        candidates = []</span><br><span class="line">        <span class="keyword">for</span> filename in [<span class="keyword">x</span> <span class="keyword">for</span> <span class="keyword">x</span> in self.__get_dictionaries(context)</span><br><span class="line">                         <span class="keyword">if</span> <span class="keyword">x</span> in self.__cache]:</span><br><span class="line">            candidates.<span class="keyword">append</span>(self.__cache[filename].candidates)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'sorted_candidates'</span>: candidates&#125;</span><br><span class="line"></span><br><span class="line">    def __make_cache(self, context):</span><br><span class="line">        <span class="keyword">for</span> filename in self.__get_dictionaries(context):</span><br><span class="line">            mtime = getmtime(filename)</span><br><span class="line">            <span class="keyword">if</span> filename in self.__cache <span class="built_in">and</span> self.__cache[</span><br><span class="line">                    filename].mtime == mtime:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            with <span class="keyword">open</span>(filename, <span class="string">'r'</span>, errors=<span class="string">'replace'</span>) <span class="keyword">as</span> <span class="keyword">f</span>:</span><br><span class="line">                self.__cache[filename] = DictCacheItem(</span><br><span class="line">                        mtime, [&#123;<span class="string">'word'</span>: <span class="keyword">x</span>.<span class="keyword">split</span>(<span class="string">'\t'</span>)[<span class="number">0</span>], <span class="string">'kind'</span>: <span class="keyword">x</span>.<span class="keyword">split</span>(<span class="string">'\t'</span>)[<span class="number">1</span>]&#125;</span><br><span class="line">                            <span class="keyword">for</span> <span class="keyword">x</span> in sorted([<span class="keyword">x</span>.strip() <span class="keyword">for</span> <span class="keyword">x</span> in <span class="keyword">f</span>], key=str.lower)</span><br><span class="line">                                <span class="keyword">if</span> <span class="built_in">len</span>(<span class="keyword">x</span>.<span class="keyword">split</span>(<span class="string">'\t'</span>)) &gt; <span class="number">1</span>]</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">    def __get_dictionaries(self, context):</span><br><span class="line">        <span class="keyword">return</span> [dirname(realpath(__file__)) + <span class="string">"/keyword.txt"</span>]</span><br></pre></td></tr></table></figure><h2 id="For-FreeWheel-Guys"><a href="#For-FreeWheel-Guys" class="headerlink" title="For FreeWheel Guys"></a>For FreeWheel Guys</h2><p>我已经把 logquery 的关键词补全打包成一个 vim 插件包，放在了 gitlab 上， 在 <code>.vimrc</code> 里加入下面的内容，然后执行 <code>:PlugInstall!</code> 即可安装：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/Shougo/deoplete.nvim'</span>, &#123; <span class="string">'do'</span>: <span class="string">':UpdateRemotePlugins'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">" need to be after deoplete plugin to take effect</span></span><br><span class="line">Plug <span class="string">'git@git.dev.fwmrm.net:vim/deoplete-fwlqs.git'</span></span><br></pre></td></tr></table></figure><p>该插件只有在编辑 sql 类型的文件时才会生效。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2020/05/06/vim-open-saz-file/">使用 Vim 查看 Fiddler 生成的 saz 格式 session 包</a></li><li><a href="https://hiberabyss.github.io/2018/05/03/add-async-support-for-vim-plugin/">给 Vim 插件添加上异步调用的功能</a></li><li><a href="https://hiberabyss.github.io/2018/04/24/vim-plug-rest-console/">实现类 Postman 功能的 VIM 插件</a></li><li><a href="https://hiberabyss.github.io/2018/04/13/vim-file-jumper/">Vim 文件快速跳转插件</a></li><li><a href="https://hiberabyss.github.io/2018/03/21/vim-plug-introduction/">VIM 插件管理工具 vim-plug 简明教程</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时我们会期望能够根据自定义的一些 keyword 来在 VIM 里进行补全。 我们可以通过 neovim 的插件 deoplete 来实现这个目的。&lt;/p&gt;
    
    </summary>
    
      <category term="Vim" scheme="https://hiberabyss.github.io/categories/vim/"/>
    
    
      <category term="Vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
      <category term="Neovim" scheme="https://hiberabyss.github.io/tags/neovim/"/>
    
  </entry>
  
  <entry>
    <title>【VIM】neovim 下的 neoterm 插件的一些改进</title>
    <link href="https://hiberabyss.github.io/2017/11/15/neovim-neoterm/"/>
    <id>https://hiberabyss.github.io/2017/11/15/neovim-neoterm/</id>
    <published>2017-11-15T23:52:32.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>Neovim 原生支持 terminal 功能，在编辑文件的同时可以新开一个 terminal 窗口， 在其中执行命令。例如我可以在写博客的同时开启一个 terminal 窗口，在其中执行 <code>hexo s</code>， 这样就可以实时预览博客：</p><p>NOTE: 最新版本的 Neoterm 插件已经原生支持 <code>Tnext</code> 和 <code>Tprevious</code> 命令。</p><a id="more"></a><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1510762631758.png" width="570"></p><h2 id="Neoterm"><a href="#Neoterm" class="headerlink" title="Neoterm"></a>Neoterm</h2><p><a href="https://github.com/kassio/neoterm" rel="external nofollow noopener noreferrer" target="_blank">Neoterm</a> 是 neovim 下的一款 terminal 管理插件， 通过它可以很方便地：</p><ul><li>开启新的 terminal 窗口：<code>Tnew</code></li><li>给 terminal 窗口发送命令：<code>T python</code></li></ul><h2 id="提高-neoterm-的多-terminal-窗口管理能力"><a href="#提高-neoterm-的多-terminal-窗口管理能力" class="headerlink" title="提高 neoterm 的多 terminal 窗口管理能力"></a>提高 neoterm 的多 terminal 窗口管理能力</h2><p>当通过 neoterm 开启多个 terminal 窗口之后，对这些窗口的管理就会变得很困难。 为了能够高效地管理多个 terminal 窗口，需要能在 terminal 窗口里快速地实现下面两个功能：</p><ul><li>快速跳转到上一个或下一个 terminal 窗口；</li><li>快速打开一个显示当前所有 terminal 的 list。</li></ul><h3 id="terminal-窗口之间的快速跳转"><a href="#terminal-窗口之间的快速跳转" class="headerlink" title="terminal 窗口之间的快速跳转"></a>terminal 窗口之间的快速跳转</h3><p>对于这个功能我们可以利用 vim 的 <code>bnext</code> 和 <code>bprevious</code> 来实现，通过他们来遍历到上一个或下一个 terminal 窗口：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">PreviousTerminal</span><span class="params">()</span></span></span><br><span class="line">    :<span class="keyword">bprevious</span></span><br><span class="line">    <span class="keyword">while</span> &amp;buftype != <span class="string">"terminal"</span></span><br><span class="line">        :<span class="keyword">bprevious</span></span><br><span class="line">    <span class="keyword">endw</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">NextTerminal</span><span class="params">()</span></span></span><br><span class="line">    :<span class="keyword">bnext</span></span><br><span class="line">    <span class="keyword">while</span> &amp;buftype != <span class="string">"terminal"</span></span><br><span class="line">        :<span class="keyword">bnext</span></span><br><span class="line">    <span class="keyword">endw</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">tnoremap <span class="symbol">&lt;silent&gt;</span> &lt;A-[&gt; &lt;<span class="keyword">c</span>-\&gt;<span class="symbol">&lt;c-n&gt;</span>:<span class="keyword">call</span> PreviousTerminal()<span class="symbol">&lt;cr&gt;</span></span><br><span class="line">tnoremap <span class="symbol">&lt;silent&gt;</span> &lt;A-]&gt; &lt;<span class="keyword">c</span>-\&gt;<span class="symbol">&lt;c-n&gt;</span>:<span class="keyword">call</span> NextTerminal()<span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码里增加了两个 map ：</p><ul><li>跳转到上一个 terminal 窗口：<code>&lt;A-[&gt;</code></li><li>跳转到下一个 terminal 窗口：<code>&lt;A-]&gt;</code></li></ul><p>这样在 terminal 窗口里按对应的按键就可以跳转到上一个或者下一个 terminal 窗口。</p><h3 id="快速打开当前所有-terminal-窗口的-list"><a href="#快速打开当前所有-terminal-窗口的-list" class="headerlink" title="快速打开当前所有 terminal 窗口的 list"></a>快速打开当前所有 terminal 窗口的 list</h3><p>当打开所有 terminal 的窗口之后，我们便可以快速地选择要切换的 terminal 窗口。</p><p>这个功能是通过 vim 的 <a href="https://github.com/Shougo/unite.vim" rel="external nofollow noopener noreferrer" target="_blank">Unite</a> 插件来实现的。 在安装完这个插件之后执行命令 <code>Unite buffer:t</code> 即可打开所有 terminal 的 list。 我们添加如下的 map ，即可实现按 <code>&lt;A-o&gt;</code> 来打开这个 list：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">tnoremap <span class="symbol">&lt;A-o&gt;</span> &lt;<span class="keyword">c</span>-\&gt;<span class="symbol">&lt;c-n&gt;</span>:Unite -<span class="keyword">no</span>-start-<span class="keyword">insert</span> <span class="keyword">buffer</span>:t<span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2020/05/06/vim-open-saz-file/">使用 Vim 查看 Fiddler 生成的 saz 格式 session 包</a></li><li><a href="https://hiberabyss.github.io/2018/05/03/add-async-support-for-vim-plugin/">给 Vim 插件添加上异步调用的功能</a></li><li><a href="https://hiberabyss.github.io/2018/04/24/vim-plug-rest-console/">实现类 Postman 功能的 VIM 插件</a></li><li><a href="https://hiberabyss.github.io/2018/04/13/vim-file-jumper/">Vim 文件快速跳转插件</a></li><li><a href="https://hiberabyss.github.io/2018/03/21/vim-plug-introduction/">VIM 插件管理工具 vim-plug 简明教程</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Neovim 原生支持 terminal 功能，在编辑文件的同时可以新开一个 terminal 窗口， 在其中执行命令。例如我可以在写博客的同时开启一个 terminal 窗口，在其中执行 &lt;code&gt;hexo s&lt;/code&gt;， 这样就可以实时预览博客：&lt;/p&gt;&lt;p&gt;NOTE: 最新版本的 Neoterm 插件已经原生支持 &lt;code&gt;Tnext&lt;/code&gt; 和 &lt;code&gt;Tprevious&lt;/code&gt; 命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Vim" scheme="https://hiberabyss.github.io/categories/vim/"/>
    
    
      <category term="Vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
      <category term="Neovim" scheme="https://hiberabyss.github.io/tags/neovim/"/>
    
  </entry>
  
  <entry>
    <title>【Vim】macOS 系统下 Vim 编辑中文 tips</title>
    <link href="https://hiberabyss.github.io/2017/11/14/vim-mac-chinese-input/"/>
    <id>https://hiberabyss.github.io/2017/11/14/vim-mac-chinese-input/</id>
    <published>2017-11-14T00:01:05.000Z</published>
    <updated>2021-02-10T07:01:06.372Z</updated>
    
    <content type="html"><![CDATA[<p>因为 VIM 里存在多个 mode ，使得编辑中文变得很痛苦。在 Insert mode 下需要使用中文输入法， 但当切换回 Normal 模式后又需要使用英文输入法。在 VIM 里切换 mode 是很经常的事儿， 在需要输入中文时，每次的 mode 切换都需要进行输入法的切换，很麻烦。 通过 <a href="https://github.com/CodeFalling/fcitx-vim-osx" rel="external nofollow noopener noreferrer" target="_blank">fcitx-vim-osx</a> 插件可以很好的解决这个问题。</p><a id="more"></a><h2 id="fcitx-vim-osx-是怎么解决这个问题的"><a href="#fcitx-vim-osx-是怎么解决这个问题的" class="headerlink" title="fcitx-vim-osx 是怎么解决这个问题的"></a>fcitx-vim-osx 是怎么解决这个问题的</h2><p>fcitx-vim-osx 会检查 VIM 的 mode，如果是 Normal 模式时会自动切换成英文输入法；同时， 它也会记录下 Insert 模式下的输入法状态，当进入 Insert 模式后悔自动恢复之前的输入法状态。 fcitx-vim-osx 目前只能在 macOS 系统下工作。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在安装之前需要先按照<a href="https://github.com/CodeFalling/fcitx-remote-for-osx" rel="external nofollow noopener noreferrer" target="_blank">这里</a>的教程配置安装对应的命令.</p><p>我使用 <a href="https://github.com/junegunn/vim-plug" rel="external nofollow noopener noreferrer" target="_blank">vim-plug</a> 来管理 VIM 插件，在 <code>.vimrc</code> 里加入下面这行:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Plug <span class="string">'https://github.com/CodeFalling/fcitx-vim-osx'</span></span><br></pre></td></tr></table></figure><p>并执行命令 <code>:PlugInstall fcitx-vim-osx</code> 即可成功安装。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2020/05/06/vim-open-saz-file/">使用 Vim 查看 Fiddler 生成的 saz 格式 session 包</a></li><li><a href="https://hiberabyss.github.io/2018/05/03/add-async-support-for-vim-plugin/">给 Vim 插件添加上异步调用的功能</a></li><li><a href="https://hiberabyss.github.io/2018/04/24/vim-plug-rest-console/">实现类 Postman 功能的 VIM 插件</a></li><li><a href="https://hiberabyss.github.io/2018/04/13/vim-file-jumper/">Vim 文件快速跳转插件</a></li><li><a href="https://hiberabyss.github.io/2018/03/21/vim-plug-introduction/">VIM 插件管理工具 vim-plug 简明教程</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为 VIM 里存在多个 mode ，使得编辑中文变得很痛苦。在 Insert mode 下需要使用中文输入法， 但当切换回 Normal 模式后又需要使用英文输入法。在 VIM 里切换 mode 是很经常的事儿， 在需要输入中文时，每次的 mode 切换都需要进行输入法的切换，很麻烦。 通过 &lt;a href=&quot;https://github.com/CodeFalling/fcitx-vim-osx&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;fcitx-vim-osx&lt;/a&gt; 插件可以很好的解决这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Vim" scheme="https://hiberabyss.github.io/categories/vim/"/>
    
    
      <category term="Vim" scheme="https://hiberabyss.github.io/tags/vim/"/>
    
      <category term="macOS" scheme="https://hiberabyss.github.io/tags/macos/"/>
    
  </entry>
  
  <entry>
    <title>【树莓派】利用 ngrok 进行远程访问</title>
    <link href="https://hiberabyss.github.io/2017/11/13/remote-access-raspberry/"/>
    <id>https://hiberabyss.github.io/2017/11/13/remote-access-raspberry/</id>
    <published>2017-11-13T23:23:42.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>当在树莓派上开启了 ssh 服务后，我们可以通过局域网 IP 来进行访问。但如果想要通过外网访问树莓派， 就需要有一个公网的 IP 地址。我们可以利用路由器的端口转发功能，把路由器的某个端口映射到树莓派的 22 端口， 这样就可以通过路由器的公网 IP 地址和端口访问树莓派。但路由器的公网 IP 每隔一段时间就会被更新， 这样就需要先查询路由器的公网 IP ，再去访问树莓派，会比较麻烦。而通过 ngrok ，可以一劳永逸地解决外网访问树莓派的问题。</p><a id="more"></a><h2 id="什么是-Ngrok"><a href="#什么是-Ngrok" class="headerlink" title="什么是 Ngrok"></a>什么是 Ngrok</h2><p>简单来说，ngrok 是一个端口转发服务提供商。它在自己的服务器和运行 ngrok 命令的机器之间建立了一条 tunnel。 这条 tunnel 的两端分别是 ngrok 服务器的某个地址和端口，以及执行 ngrok 命令的机器的地址和端口。 在执行完 ngrok 命令之后，我们会收到服务器的域名和端口，这个域名是公网可见的。通过访问这个域名我们就可以访问执行 ngrok 命令的机器。</p><h2 id="怎么用-Ngrok"><a href="#怎么用-Ngrok" class="headerlink" title="怎么用 Ngrok"></a>怎么用 Ngrok</h2><p>首先需要下载 <a href="https://ngrok.com/download" rel="external nofollow noopener noreferrer" target="_blank">ngrok</a> 的二进制文件， 然后在 ngrok 的<a href="https://ngrok.com/" rel="external nofollow noopener noreferrer" target="_blank">官网</a>上进行注册，注册完成后点击 Dashboard 就可以看到你自己的 token，然后执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./ngrok authtoken 5k7rUCwLksfx1qwpT17en_7tMFYmC1u8cHGeppJzic1</span><br></pre></td></tr></table></figure><p>再通过下面的命令映射出树莓派的 22 端口：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./ngrok tcp 22</span><br></pre></td></tr></table></figure><p>上面的命令执行完后会有下面这样的输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ngrok by @inconshreveable</span><br><span class="line"></span><br><span class="line">Session Status                online</span><br><span class="line">Account                       Hongbo Liu (Plan: Free)</span><br><span class="line">Version                       2.2.8</span><br><span class="line">Region                        United States (us)</span><br><span class="line">Web Interface                 http://127.0.0.1:4040</span><br><span class="line">Forwarding                    tcp://0.tcp.ngrok.io:15393 -&gt; localhost:22</span><br><span class="line"></span><br><span class="line">Connections                   ttl     opn     rt1     rt5     p50     p90</span><br><span class="line">                              2       0       0.00    0.00    35.11   58.65</span><br></pre></td></tr></table></figure><p>我们就可以通过 <code>ssh -p 15393 pi@0.tcp.ngrok.io</code> 来访问到树莓派了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当在树莓派上开启了 ssh 服务后，我们可以通过局域网 IP 来进行访问。但如果想要通过外网访问树莓派， 就需要有一个公网的 IP 地址。我们可以利用路由器的端口转发功能，把路由器的某个端口映射到树莓派的 22 端口， 这样就可以通过路由器的公网 IP 地址和端口访问树莓派。但路由器的公网 IP 每隔一段时间就会被更新， 这样就需要先查询路由器的公网 IP ，再去访问树莓派，会比较麻烦。而通过 ngrok ，可以一劳永逸地解决外网访问树莓派的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Raspberry" scheme="https://hiberabyss.github.io/tags/raspberry/"/>
    
  </entry>
  
  <entry>
    <title>Git Tips：修改 commits</title>
    <link href="https://hiberabyss.github.io/2017/03/21/git-amend-commits/"/>
    <id>https://hiberabyss.github.io/2017/03/21/git-amend-commits/</id>
    <published>2017-03-21T00:03:41.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>总是会存在这样的场景：在开开心心地用 git commit 提交了代码之后，才发现 commit message 里有 typo， 或者是有些文件忘记 commit 了，又或者是有些垃圾文件被不小心 commit 了；这时不要伤心、不要难过， 因为 git 给你提供了后悔药。</p><a id="more"></a><h2 id="修改最近的一个-commit"><a href="#修改最近的一个-commit" class="headerlink" title="修改最近的一个 commit"></a>修改最近的一个 commit</h2><p>如果想要修改最近的一个 commit 的 message，直接执行 <code>git commit --amend</code>，然后在编辑器里修改 message 信息， 保存退出即可。</p><p>如果想把当前未提交的更改添加到最近的一个 commit 里，则直接执行 <code>git commit -a --amend</code> 即可。</p><p>如果要删除最近 commit 里提交的一些内容则可能会稍显麻烦一些，需要先用 <code>git reset HEAD^</code> 来撤销最近的一次 commit， 然后再用 <code>git checkout file</code> 来进行操作。</p><h2 id="修改多个-commits"><a href="#修改多个-commits" class="headerlink" title="修改多个 commits"></a>修改多个 commits</h2><p>在开发的过程中，创建 commit 可能会比较随意，等到实际提交代码时，为了能有一个清晰的 git 提交历史， 我们可能需要重新编辑这些 commits，以使得每个 commit 都是有意义的。为了实现这个目的，我们需要使用到 git rebase。</p><p>进行 rebase 之前需要知道要进行 rebase 的 commits 的 list， 这个 list 是一个半开区间 (commit-before-you-want-to-change, HEAD], 然后通过下面的命令进行 rebase：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase -i commit-before-you-want-to-change</span><br></pre></td></tr></table></figure><p>修改每个 commit 前的命令即可实现对应的操作，常用的命令有：</p><ul><li>reword: 修改当前 commit 的 message</li><li>squash: 把当前 commit 合并到前一个 commit，包括 commit message</li><li>fixup: 类似 squash，但会丢弃当前 commit 的 message</li><li>edit: 修改当前 commit</li></ul><p>在进行 rebase 时比较麻烦的一点是获取要修改的最后一个 commit 的 hash 值。在多人协作的项目里，我们每次要进行 rebase 的 commit 应该都是由自己提交的， 基于这个假设，可以通过脚本获取最后一个不是当前作者的 commit 作为 git rebase 的参数，对应的 shell 脚本代码如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">username="`git config user.name`"</span><br><span class="line"></span><br><span class="line">firstOtherCommitIdx() &#123;</span><br><span class="line">idx=0</span><br><span class="line">for (( i = 0; i &lt; 100; i++ )); do</span><br><span class="line">current_user="$(git log --format="%an" -n 1 --skip $i)"</span><br><span class="line">if [[ $current_user != $username ]]; then</span><br><span class="line">idx=$i</span><br><span class="line">break</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line">echo $idx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main() &#123;</span><br><span class="line">local idx="$(firstOtherCommitIdx)"</span><br><span class="line">if [[ $idx == 0 ]]; then</span><br><span class="line">echo "There is no commit for user: $username"</span><br><span class="line">exit 0</span><br><span class="line">fi</span><br><span class="line">local other_commit="$(git log --format="%H" -n 1 --skip $idx)"</span><br><span class="line">git rebase -i $other_commit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main $*</span><br></pre></td></tr></table></figure><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/03/28/git-internal/">「Git」底层存储原理详解</a></li><li><a href="https://hiberabyss.github.io/2018/03/03/git-ignore-specific-file/">Git：在 merge 的时候忽略特定的文件</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总是会存在这样的场景：在开开心心地用 git commit 提交了代码之后，才发现 commit message 里有 typo， 或者是有些文件忘记 commit 了，又或者是有些垃圾文件被不小心 commit 了；这时不要伤心、不要难过， 因为 git 给你提供了后悔药。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://hiberabyss.github.io/categories/git/"/>
    
    
      <category term="Git" scheme="https://hiberabyss.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 入门教程</title>
    <link href="https://hiberabyss.github.io/2017/03/13/hexo-tutorial/"/>
    <id>https://hiberabyss.github.io/2017/03/13/hexo-tutorial/</id>
    <published>2017-03-13T21:41:42.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>晚上把搭好的博客发给了我的 Best Gay Friend 看，本来只是想赚一下浏览量，但基友说也想搭一个类似的博客系统。 寻思着可以写一篇利用 Github Pages 搭建 Hexo 博客系统的入门教程，既可以增加一篇“凑字数”的博客，又可以急基友之所急。</p><a id="more"></a><h2 id="Hexo-的安装及使用"><a href="#Hexo-的安装及使用" class="headerlink" title="Hexo 的安装及使用"></a>Hexo 的安装及使用</h2><p>Hexo 的安装很简单，只用一条命令即可搞定：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>安装完之后就可以用下面的命令来初始化一个博客：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br></pre></td></tr></table></figure><p>然后用 <code>hexo server -o</code> 在本地打开对应的博客网站。 这些在 <a href="https://github.com/hexojs/hexo#quick-start" rel="external nofollow noopener noreferrer" target="_blank">Hexo 官网</a>上都有介绍。</p><h2 id="自定义Hexo"><a href="#自定义Hexo" class="headerlink" title="自定义Hexo"></a>自定义Hexo</h2><p>可以通过编辑 <code>blog/_config.yml</code> 文件来对你的博客网站进行配置，例如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">始于珞尘</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Hongbo</span> <span class="string">Liu</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure><p>也可以修改博客的主题：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">maupassant-hexo</span></span><br></pre></td></tr></table></figure><p>主题 <code>maupassant</code> 的具体安装方法可以参考它的 <a href="https://github.com/tufu9441/maupassant-hexo" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a>。</p><h3 id="自定义-maupassant-主题"><a href="#自定义-maupassant-主题" class="headerlink" title="自定义 maupassant 主题"></a>自定义 maupassant 主题</h3><ul><li>启用博客阅读数统计：<code>busuanzi: true</code></li><li>启用对应的 Comment 插件：gitalk, gitment、valine</li></ul><h4 id="增加统计功能"><a href="#增加统计功能" class="headerlink" title="增加统计功能"></a>增加统计功能</h4><p>基于这个<a href="https://github.com/aimer1124/blog_theme" rel="external nofollow noopener noreferrer" target="_blank">文档</a>添加总阅读数的统计:</p><ul><li><p>在 <code>after_footer.pug</code> 文件中加入以下代码:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if theme.busuanzi == true</span><br><span class="line">  script(src=&apos;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&apos;, async)</span><br></pre></td></tr></table></figure></li><li><p>在 <code>footer.pug</code> 文件中加入以下代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if theme.busuanzi == true</span><br><span class="line">  div</span><br><span class="line">    | Total</span><br><span class="line">    span#busuanzi_container_site_pv</span><br><span class="line">      span= &apos; &apos;</span><br><span class="line">      span#busuanzi_value_site_pv</span><br><span class="line">    span(rel=&apos;nofollow&apos;)= &apos; &apos; + __(&apos; hits, &apos;)</span><br><span class="line">    span#busuanzi_container_site_uv</span><br><span class="line">      span#busuanzi_value_site_uv</span><br><span class="line">    span(rel=&apos;nofollow&apos;)= &apos; &apos; + __(&apos; visitors. &apos;)</span><br></pre></td></tr></table></figure></li></ul><p>通过<a href="https://web.umeng.com/main.php?c=site&amp;a=show" rel="external nofollow noopener noreferrer" target="_blank">友盟</a>添加站长统计信息. 注册完成后添加你的博客域名, 然后进入获取代码页面, 复制你期望的样式的代码, 去除掉代码中的 script tag, 把代码放到文件 <code>footer.pug</code> 中:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div</span><br><span class="line">  script.</span><br><span class="line">       var cnzz_protocol = ((&quot;https:&quot; == document.location.protocol) ? &quot; https://&quot; : &quot; http://&quot;);document.write(unescape(&quot;%3Cspan id=&apos;cnzz_stat_icon_avoid_use&apos;%3E%3C/span%3E%3Cscript src=&apos;&quot; + cnzz_protocol + &quot;s22.cnzz.com/z_stat.php%3Fid%3Dyour-id-number%26online%3D1%26show%3Dline&apos; type=&apos;text/javascript&apos;%3E%3C/script%3E&quot;));</span><br></pre></td></tr></table></figure><p>设置完成后可以看到类似下图的效果:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1523053025720.png" width="485"></p><p><a href="https://github.com/hiberabyss/maupassant-hexo/blob/master/layout/_partial/footer.pug" rel="external nofollow noopener noreferrer" target="_blank">这里</a> 是完整的代码文件.</p><h2 id="部署-Hexo-博客到-Github-Pages"><a href="#部署-Hexo-博客到-Github-Pages" class="headerlink" title="部署 Hexo 博客到 Github Pages"></a>部署 Hexo 博客到 Github Pages</h2><p>要使用 Github Pages 首先需要你建一个名称为 <code>your-github-id.github.io</code> 的 repository，同时需要在 repository 的设置里开启 Github Pages 功能。</p><p>然后在 <code>blog</code> 目录里安装 hexo deploy 插件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 文件里添加如下的配置：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:your-github-id/your-github-id.github.io.git</span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure><p>最后执行 <code>hexo generate -d</code>，大功告成！打开 <a href="http://your-github-id.github.io" rel="external nofollow noopener noreferrer" target="_blank">http://your-github-id.github.io</a> 就可以访问你的博客网站了！</p><h3 id="使用-443-端口连接"><a href="#使用-443-端口连接" class="headerlink" title="使用 443 端口连接"></a>使用 443 端口连接</h3><p>有时 22 端口可能会被防火墙拦截, 这时执行 <code>hexo deploy</code> 时可能会遇到下面的错误信息:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line"></span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (/Users/hbliu/Projects/Hexo/blog/node_modules/hexo-util/lib/spawn.js:37:17)</span><br><span class="line">    at ChildProcess.emit (events.js:180:13)</span><br><span class="line">    at maybeClose (internal/child_process.js:936:16)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (internal/child_process.js:220:5)</span><br></pre></td></tr></table></figure><p>这时我们可以利用 443 端口进行 ssh 连接. 修改 <code>~/.ssh/config</code> 文件, 添加以下内容:</p><ul><li><p>For Github:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    hostname ssh.github.com</span><br><span class="line">    port 443</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></li><li><p>For coding.net (<a href="https://coding.net/help/faq/git/git.html#_22_SSH" rel="external nofollow noopener noreferrer" target="_blank">git-faq</a>)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host git.coding.net</span><br><span class="line">    hostname git-ssh.coding.net</span><br><span class="line">    port 443</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></li></ul><h3 id="强制开启-https"><a href="#强制开启-https" class="headerlink" title="强制开启 https"></a>强制开启 https</h3><p>我们可以在 Github Pages 库里的设置中开启强制 https 功能, 这样当用户访问 http 的网页时 会自动重定向到 https 页面.</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1521450041622.png" width="491"></p><h2 id="搜索引擎检索"><a href="#搜索引擎检索" class="headerlink" title="搜索引擎检索"></a>搜索引擎检索</h2><p>为了让博客的内容能被百度和 Google 检索，首先需要生成对应的 sitemap：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>分别在 <a href="http://zhanzhang.baidu.com/site/index" rel="external nofollow noopener noreferrer" target="_blank">百度站长工具</a> 和 <a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" rel="external nofollow noopener noreferrer" target="_blank">Google 站长工具</a> 里对你的博客站点进行验证。</p><p>选择<code>文件验证</code>的方式进行验证，把下载的文件放在 <code>source</code> 目录下，并对文件内容进行编辑，在文件首部加入如下内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">layout:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">sitemap:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>这样就可以防止 Hexo 在生成博客网站时在验证文件里添加额外的内容，导致验证失败。</p><p>也可以在博客的配置文件里加入如下的配置来防止这些文件被渲染：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">baidu_verify*.html</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">google*.html</span></span><br></pre></td></tr></table></figure><p>具体的匹配规则可以参考这个 <a href="https://github.com/hexojs/hexo/issues/1146#issuecomment-88380140" rel="external nofollow noopener noreferrer" target="_blank">comment</a></p><p>当博客站点验证成功后便可以选择用 sitemap 的方式自动提交链接。对于百度，在站长平台工具里选择 “网页抓取–&gt;链接提交–&gt;自动提交–&gt;sitemap”， 如下图所示：</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1489936271715.png" width="560"></p><p>对于 Google 择选择 “抓取–&gt;站点地图–&gt;添加站点地图”，如下图所示：</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1489936644191.png" width="379"></p><p>当做完所有这些操作之后可以通过 <code>site:your-blog-site</code> 这个搜索来验证你的博客有没有被百度和 Google 收录。 一般需要几天的时间才能保证你的博客被搜索引擎检索到。</p><h2 id="利用-Hexo-部署-nodeppt-生成的-slides"><a href="#利用-Hexo-部署-nodeppt-生成的-slides" class="headerlink" title="利用 Hexo 部署 nodeppt 生成的 slides"></a>利用 Hexo 部署 nodeppt 生成的 slides</h2><p>我平时经常会用 nodeppt 来制作 slides, 它也是基于 markdown 文件来生成对应的 slides html 文件. 我们可以把 slides html 文件放在 hexo 中, 这样便可以实现在线的 slides, 方便和别人进行分享.</p><p>我把 slides 的入口地址放在了和 “关于” 平级的 tab 上, 如下图所示:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1521705301743.png" width="455"></p><p>对于基于 maupassant 的主题, 可以在 <code>menu</code> 下面加上 Slides 入口:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">page:</span> <span class="string">Slides</span></span><br><span class="line">    <span class="attr">directory:</span> <span class="string">slides/publish</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa-slideshare</span></span><br></pre></td></tr></table></figure><p>然后在 <code>source/slides/src</code> 中添加 markdown 源文件, 在目录 <code>sources/slides</code> 中使用 <code>nodeppt generate src -a</code> 生成对应的 html 文件.</p><p>当我们点击 Slides 的 tab 时便可进入如下的界面:</p><p><img src="http://on2hdrotz.bkt.clouddn.com/blog/1521711265507.png" width="290"></p><h2 id="使用七牛作为图床"><a href="#使用七牛作为图床" class="headerlink" title="使用七牛作为图床"></a>使用七牛作为图床</h2><p>注册 <a href="https://portal.qiniu.com/signup?code=3liikw6nls3ma" rel="external nofollow noopener noreferrer" target="_blank">七牛账户</a> 并创建一个新的 bucket（选择华东区，否则下面提到的插件无法正常使用）， 利用插件 <a href="https://github.com/tiann/markdown-img-upload" rel="external nofollow noopener noreferrer" target="_blank">markdown-img-upload</a> 可以很方便地上传图片到七牛并插入图片引用到 Markdown 文件。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/05/06/hexo-copyright-recommendations/">给 maupassant 主题添加文章版权信息和推荐阅读功能</a></li><li><a href="https://hiberabyss.github.io/2018/03/19/hexo-gitalk-integration/">给 Hexo 博客集成 gitalk 评论系统</a></li><li><a href="https://hiberabyss.github.io/2017/03/13/hexo-source-code-backup/">Hexo 源文件备份</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;晚上把搭好的博客发给了我的 Best Gay Friend 看，本来只是想赚一下浏览量，但基友说也想搭一个类似的博客系统。 寻思着可以写一篇利用 Github Pages 搭建 Hexo 博客系统的入门教程，既可以增加一篇“凑字数”的博客，又可以急基友之所急。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://hiberabyss.github.io/categories/hexo/"/>
    
    
      <category term="Hexo" scheme="https://hiberabyss.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 源文件备份</title>
    <link href="https://hiberabyss.github.io/2017/03/13/hexo-source-code-backup/"/>
    <id>https://hiberabyss.github.io/2017/03/13/hexo-source-code-backup/</id>
    <published>2017-03-13T01:00:26.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>在执行完 <code>hexo generate -d</code> 命令后会把生成的 html 文件上传到 github 上，我们还需要一种方法来备份源 markdown 文件及对应的 hexo 配置文件， 这样才能比较方便地在别的地方来生成对应的博客网站。对于这个备份机制会有以下几个需求：</p><a id="more"></a><h2 id="使用不同分支来分别保存博客源代码及生成的博客网站"><a href="#使用不同分支来分别保存博客源代码及生成的博客网站" class="headerlink" title="使用不同分支来分别保存博客源代码及生成的博客网站"></a>使用不同分支来分别保存博客源代码及生成的博客网站</h2><h3 id="使用-master-分支来保存生成的博客网站"><a href="#使用-master-分支来保存生成的博客网站" class="headerlink" title="使用 master 分支来保存生成的博客网站"></a>使用 master 分支来保存生成的博客网站</h3><p>因为 Github Page 要求使用 master 分支，我们便用 master 分支来保存生成的博客网站。 在装完 <code>hexo-deployer-git</code> 插件后，我们可以在 <code>_config.yml</code> 文件里添加如下的配置来指定博客的部署位置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:your-github-name/your-github-name.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>然后就可以使用 <code>hexo generate -d</code> 来基于你写的 markdown 文件来生成对应的博客网站，并部署到 github 上。</p><h3 id="使用-hexo-分支来保存博客源文件"><a href="#使用-hexo-分支来保存博客源文件" class="headerlink" title="使用 hexo 分支来保存博客源文件"></a>使用 hexo 分支来保存博客源文件</h3><p>在你的 Github Page Repository 里新建一个 hexo 分支，并把它设置成默认分支，这样以后打开这个 repository 的时候默认展示的就是这个分支里的内容。 需要把以下文件保存到 hexo 分支里：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">package.json</span><br><span class="line">scaffolds</span><br><span class="line">source</span><br><span class="line">themes</span><br></pre></td></tr></table></figure><p>其中 package.json 文件是为了在 clone 了博客源代码库之后可以很方便地通过 <code>npm install</code> 就能方便地生成 hexo 博客系统所依赖的所有包。 为了能在 package.json 里记录所有的包信息，需要在安装包时添加 <code>--save</code> 参数，例如：<code>npm install hexo-deployer-git --save</code>。</p><p>这篇<a href="http://www.dxjia.cn/2016/01/27/hexo-write-everywhere/" rel="external nofollow noopener noreferrer" target="_blank">博客</a>有详细介绍如何通过不同分支来保存博客源文件及对应生成的博客网站文件。</p><h2 id="同时保存生成的网站文件及对应的源代码"><a href="#同时保存生成的网站文件及对应的源代码" class="headerlink" title="同时保存生成的网站文件及对应的源代码"></a>同时保存生成的网站文件及对应的源代码</h2><p><code>hexo-cli</code> 工具里有提供自动部署网站到 github 的功能，但并没有提供保存对应的源代码的机制，我们可以利用 git hook 来实现在部署网站时也自动 push 源代码 改动到 github。</p><p><code>hexo-cli</code> 是把对应的网站代码保存到 <code>/path/to/blog/.deploy_git</code> 这个 git repository 里，我们可以在这个 git 库里添加如下的 <code>pre-push</code> hook 来实现 部署网站时自动保存源代码到 hexo 分支：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ..</span><br><span class="line">git add .</span><br><span class="line">git commit -m 'Regular save'</span><br><span class="line">git push origin</span><br></pre></td></tr></table></figure><p>可以通过脚本的方式来自动地添加这个 <code>pre-hook</code>，具体怎么实现可以参考我写的这个<a href="https://github.com/hiberabyss/hiberabyss.github.io/blob/hexo/blog" rel="external nofollow noopener noreferrer" target="_blank">脚本</a>。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray">（由<a href="https://github.com/huiwang/hexo-recommended-posts">hexo文章推荐插件</a>驱动）</span></h1><ul><li><a href="https://hiberabyss.github.io/2018/05/06/hexo-copyright-recommendations/">给 maupassant 主题添加文章版权信息和推荐阅读功能</a></li><li><a href="https://hiberabyss.github.io/2018/03/19/hexo-gitalk-integration/">给 Hexo 博客集成 gitalk 评论系统</a></li><li><a href="https://hiberabyss.github.io/2017/03/13/hexo-tutorial/">Hexo 入门教程</a></li></ul></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在执行完 &lt;code&gt;hexo generate -d&lt;/code&gt; 命令后会把生成的 html 文件上传到 github 上，我们还需要一种方法来备份源 markdown 文件及对应的 hexo 配置文件， 这样才能比较方便地在别的地方来生成对应的博客网站。对于这个备份机制会有以下几个需求：&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://hiberabyss.github.io/categories/hexo/"/>
    
    
      <category term="Hexo" scheme="https://hiberabyss.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>基于 Docker 搭建 Jenkins Pipeline 测试环境</title>
    <link href="https://hiberabyss.github.io/2017/03/12/jenkins-pipeline-tips/"/>
    <id>https://hiberabyss.github.io/2017/03/12/jenkins-pipeline-tips/</id>
    <published>2017-03-12T01:29:06.000Z</published>
    <updated>2021-02-10T07:01:06.356Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做 CD 相关的一些工作，会用到 Jenkins Pipeline，为了方便测试，利用 Docker 搭建了一个本地的 Jenkins 服务。</p><a id="more"></a><h2 id="基于-docker-compose-建-Jenkins-container"><a href="#基于-docker-compose-建-Jenkins-container" class="headerlink" title="基于 docker-compose 建 Jenkins container"></a>基于 docker-compose 建 Jenkins container</h2><p>使用 <code>docker-compose</code> 可以很方便地创建并启动 container，下面是用于创建 Jenkins container 的 <code>docker-compose.yml</code> 文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">jenkins:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">jenkins</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">jenkins</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jenkinsci/blueocean:latest</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_OPTS=-Djenkins.install.runSetupWizard=false</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./jenkins_home:/var/jenkins_home</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./entrypoint.sh:/entrypoint.sh</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8080:8080"</span></span><br></pre></td></tr></table></figure><p>其中 image 使用了预装了 <code>blue ocean</code> 插件的 <a href="https://hub.docker.com/r/jenkinsci/blueocean/" rel="external nofollow noopener noreferrer" target="_blank">jenkinsci/blueocean</a>。</p><p>通过把 <code>/var/jenkins_home</code> 映射到宿主机目录 <code>./jenkins_home</code> 来永久保存 Jenkins 的数据，当重启 Jenkins container 时， 类似创建的 Jenkins Job 之类的数据不会丢失。</p><p>默认的 Jenkins Container 每次启动时都会进行一遍初始化的操作，通过设置环境变量 <code>JAVA_OPTS=-Djenkins.install.runSetupWizard=false</code> 便可以防止这种行为。</p><p>通过端口映射 <code>8080:8080</code> 便可以直接在本地的 <code>8080</code> 端口访问到 container 内部的 Jenkins 服务。</p><h2 id="让-Jenkins-Job-自动加载修改后的-groovy-脚本"><a href="#让-Jenkins-Job-自动加载修改后的-groovy-脚本" class="headerlink" title="让 Jenkins Job 自动加载修改后的 groovy 脚本"></a>让 Jenkins Job 自动加载修改后的 groovy 脚本</h2><p>Jenkins 的 Pipeline 是基于 groovy 语言来实现的，为了方便测试，需要 Jenkins Job 能从本地 groovy 文件加载配置。 这可以通过 Jenkins 的 <code>load step</code> 来实现。</p><p>创建一个 Jenkins Job <code>CD-Test</code>，在它的 Pipeline 配置项里选择 <code>Pipeline script</code>，并填入以下代码：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">    load <span class="string">'../Jenkinsfile'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件夹 <code>/path/to/project/jenkins_home</code> 应该有这样的目录结构：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">workspace</span><br><span class="line">├── CD-Test</span><br></pre></td></tr></table></figure><p>通过硬连接的方式把 <code>Jenkinsfile</code> 脚本连接到 <code>workspace</code> 目录下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln /path/to/project/Jenkinsfile /path/to/project/jenkins_home/Jenkinsfile</span><br></pre></td></tr></table></figure><p>这样当你修改 <code>Jenkinsfile</code> 文件时，它会自动被 CD-Test 加载。</p><h2 id="使用-jenkins-cli-工具快速新建-Jenkins-build"><a href="#使用-jenkins-cli-工具快速新建-Jenkins-build" class="headerlink" title="使用 jenkins-cli 工具快速新建 Jenkins build"></a>使用 jenkins-cli 工具快速新建 Jenkins build</h2><p>通过 <code>jenkins-cli</code> 工具可以很方便地 实现创建一个 Jenkins Job 的 build、打开它最新的 build 等操作，下面是一个基于 <code>jenkins-cli</code> 的实用脚本：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Description: jenkins cli tool</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Author: Hongbo Liu</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Email: hbliu@freewheel.com</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CreatTime: 2017-03-10 17:43:58 CST</span></span><br><span class="line"></span><br><span class="line">export JENKINS_URL="http://localhost:8080"</span><br><span class="line">CLI_FILE="jenkins-cli.jar"</span><br><span class="line">JOBS_DIR="/Users/hbliu/gitlab/CICD/salt/jenkins_home/jobs"</span><br><span class="line"></span><br><span class="line">cd "$(dirname "$0")"</span><br><span class="line"></span><br><span class="line">if [[ ! -f jenkins-cli.jar ]]; then</span><br><span class="line">    wget "$JENKINS_URL/jnlpJars/jenkins-cli.jar"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">open_job_build() &#123;</span><br><span class="line">    local job_name="$1"</span><br><span class="line">    local url="$JENKINS_URL/blue/organizations/jenkins/$job_name/detail/$job_name"</span><br><span class="line"></span><br><span class="line">    local build_id=$(cat "$JOBS_DIR/$job_name/nextBuildNumber")</span><br><span class="line">    let build_id=build_id-1</span><br><span class="line"></span><br><span class="line">    shift 1</span><br><span class="line">    local OPT OPTARG OPTIND</span><br><span class="line">    while getopts 'rn:' OPT; do</span><br><span class="line">        case $OPT in</span><br><span class="line">            n) build_id=$OPTARG ;;</span><br><span class="line">            r)</span><br><span class="line">                main build $job_name</span><br><span class="line">                let build_id=build_id+1</span><br><span class="line">                ;;</span><br><span class="line">            ?) ;;</span><br><span class="line">        esac</span><br><span class="line">    done</span><br><span class="line">    shift $(($OPTIND - 1))</span><br><span class="line"></span><br><span class="line">    open "$url/$build_id"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    if [[ "$1" == "open" ]]; then</span><br><span class="line">        shift 1</span><br><span class="line">        open_job_build $*</span><br><span class="line">    else</span><br><span class="line">        java -jar $CLI_FILE $*</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main $*</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做 CD 相关的一些工作，会用到 Jenkins Pipeline，为了方便测试，利用 Docker 搭建了一个本地的 Jenkins 服务。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Jenkins" scheme="https://hiberabyss.github.io/tags/jenkins/"/>
    
      <category term="CICD" scheme="https://hiberabyss.github.io/tags/cicd/"/>
    
  </entry>
  
  <entry>
    <title>为什么我开始尝试使用 Emacs</title>
    <link href="https://hiberabyss.github.io/2017/03/04/why-I-try-to-use-emacs/"/>
    <id>https://hiberabyss.github.io/2017/03/04/why-I-try-to-use-emacs/</id>
    <published>2017-03-04T22:46:54.000Z</published>
    <updated>2021-02-10T07:01:06.372Z</updated>
    
    <content type="html"><![CDATA[<p>作为使用了四年多, 装了超过一百个插件的”资深” vim 用户, 最近开始尝试使用 Emacs. 做出这个决定主要是出于以下几个方面的考虑:</p><a id="more"></a><h2 id="Emacs-可以更方便地输入中文"><a href="#Emacs-可以更方便地输入中文" class="headerlink" title="Emacs 可以更方便地输入中文"></a>Emacs 可以更方便地输入中文</h2><p>打算以后都定期地写一些博客, 目前英文还太烂, 为了不打消写博客的积极性, 开始时还是写中文博客比较好. 但在 vim 里写中文的体验实在是太糟糕:</p><ul><li>在 <code>Insert</code> 模式下你需要使用中文输入法.</li><li>要执行 vim 的一些跳转等操作时你需要进入到 <code>Normal</code> 模式, 而这时你的按键会先被输入法获取, 没法直接执行 vim 的命令, 需要先把输入法切换到英文模式.</li><li>当执行完 vim 的操作, 重新进行编辑时, 你还需要把输入法再切换成中文.</li></ul><p>综上, 每次执行 vim 的操作你都需要切换两次输入法! 当然也有一些 vim 的插件, 如 OSX 下的 <a href="https://github.com/ybian/smartim.git" rel="external nofollow noopener noreferrer" target="_blank">SmartIM</a>, 可以帮助自动切换输入法, 但使用起来会经常有一些奇怪的问题, 例如会导致插件 VisIncr 变得极其缓慢.</p><p>相比于 vim, Emacs 就完全不会有这个问题, 因为它的命令操作都是和控制键绑定的, 而这些按键并不会被输入法截获, 所以就不会有 vim 的问题.</p><h2 id="使用-Orgmod"><a href="#使用-Orgmod" class="headerlink" title="使用 Orgmod"></a>使用 Orgmod</h2><p>早就听闻这个插件的大名, 一直想尝试下. Vim 下虽然也有类似的插件, 但目前都还只是半成品, 功能完全不能同日而语.</p><h2 id="传说中无所不能的-Emacs"><a href="#传说中无所不能的-Emacs" class="headerlink" title="传说中无所不能的 Emacs"></a>传说中无所不能的 Emacs</h2><p>传说 Emacs 无所不能, 比如直接浏览网页, 比如直接浏览 pdf 文件…</p><p>本来是想能在 Emacs 里变编辑 Markdown 文件, 变在另外一个窗口预览, 实现类似专业 Markdown 编辑器的功能, 但搜遍了 github 也没能找到这样一款称心如意的 Markdown 预览插件. 用 Emacs 自带窗口的预览效果奇丑无比, 不能忍! 推而求其次, 可以接受在第三方软件里显示效果, 然后把 Emacs 的编辑窗口设置成半透明来看实际效果. 但竟然都没能找到一款可以跟随 Emacs 编辑窗口里的光标自动 scroll 预览窗口内容的插件!!! 而我却找到了可以实现这样功能的 Vim 插件.</p><p>Emacs 也没有我最开始预想的那么无所不能…</p><h2 id="Elisp"><a href="#Elisp" class="headerlink" title="Elisp"></a>Elisp</h2><p>作为一名程序员, 现在如果没捣鼓过函数式编程语言, 就不好意思和别人说是科班出身的. Lisp 语言是最经典的函数式编程语言了, 而 Emacs 是用 lisp 作为它的插件编写语言, 学习 Emacs 也就可以顺便学习下 Lisp 了.</p><p>以上就是我开始学习 Emacs 的目的了. 学习 Emacs 这种和 Vim 完全不同操作模式、 不同设计理念的编辑器也可以开拓自己的视野， 或许将来可以进一步帮助自己提高 Vim 的使用效率。</p><p>最近的一段时间就会这样来使用 Vim 和 Emacs 了：</p><ul><li>Vim：依旧是主力编辑器，看代码，写代码；</li><li>Emacs：写博客，用 Orgmod 来记笔记和 Task 管理；</li></ul><p>这就是是我的第一篇正式博客了，晚安！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为使用了四年多, 装了超过一百个插件的”资深” vim 用户, 最近开始尝试使用 Emacs. 做出这个决定主要是出于以下几个方面的考虑:&lt;/p&gt;
    
    </summary>
    
    
      <category term="Emacs" scheme="https://hiberabyss.github.io/tags/emacs/"/>
    
  </entry>
  
</feed>
